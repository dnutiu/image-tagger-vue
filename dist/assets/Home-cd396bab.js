import{m as makeComponentProps,a as makeTagProps,b as useRender,u as useResizeObserver}from"./tag-18e42db8.js";import{t as includes,h as genericComponent,T as TransitionGroup,v as Transition,x as h,p as propsFactory,y as camelize,c as computed,z as isRef,A as destructComputed,B as isCssColor,C as getCurrentInstanceName,d as convertToUnit,I as IconValue,n as makeThemeProps,r as ref,q as provideTheme,D as useIcon,E as toRef,F as flattenFragments,G as Text,j as createVNode,H as mergeProps,S as SUPPORTS_INTERSECTION,s as shallowRef,J as watch,K as onBeforeMount,L as nextTick,M as withDirectives,N as resolveDirective,O as Fragment,P as vShow,Q as unref,g as getCurrentInstance,R as getUid,b as provide,i as inject,U as onBeforeUnmount,a as reactive,V as useProxiedModel,o as onMounted,W as deepEqual,X as wrapInArray,f as findChildrenWithProvide,Y as provideDefaults,Z as toRefs,_ as resolveDynamicComponent,$ as hasEvent,a0 as isObject,a1 as keyCodes,a2 as EventProp,a3 as useLocale,u as useRtl,a4 as isOn,a5 as pick,a6 as useToggleScope,a7 as filterInputAttrs,a8 as humanReadableFileSize,a9 as callEvent,aa as breakpoints,ab as capitalize,ac as watchEffect,ad as defineComponent,l as openBlock,m as createBlock,w as withCtx,ae as createBaseVNode,af as createCommentVNode,ag as createElementBlock,ah as renderList,ai as createTextVNode,aj as toDisplayString}from"./index-d33a1fd6.js";const block=["top","bottom"],inline=["start","end","left","right"];function parseAnchor(v,u){let[b,g]=v.split(" ");return g||(g=includes(block,b)?"start":includes(inline,b)?"top":"center"),{side:toPhysical(b,u),align:toPhysical(g,u)}}function toPhysical(v,u){return v==="start"?u?"right":"left":v==="end"?u?"left":"right":v}class Box{constructor(u){let{x:b,y:g,width:p,height:m}=u;this.x=b,this.y=g,this.width=p,this.height=m}get top(){return this.y}get bottom(){return this.y+this.height}get left(){return this.x}get right(){return this.x+this.width}}function nullifyTransforms(v){const u=v.getBoundingClientRect(),b=getComputedStyle(v),g=b.transform;if(g){let p,m,s,l,d;if(g.startsWith("matrix3d("))p=g.slice(9,-1).split(/, /),m=+p[0],s=+p[5],l=+p[12],d=+p[13];else if(g.startsWith("matrix("))p=g.slice(7,-1).split(/, /),m=+p[0],s=+p[3],l=+p[4],d=+p[5];else return new Box(u);const a=b.transformOrigin,o=u.x-l-(1-m)*parseFloat(a),t=u.y-d-(1-s)*parseFloat(a.slice(a.indexOf(" ")+1)),e=m?u.width/m:v.offsetWidth+1,n=s?u.height/s:v.offsetHeight+1;return new Box({x:o,y:t,width:e,height:n})}else return new Box(u)}function animate(v,u,b){if(typeof v.animate>"u")return{finished:Promise.resolve()};let g;try{g=v.animate(u,b)}catch{return{finished:Promise.resolve()}}return typeof g.finished>"u"&&(g.finished=new Promise(p=>{g.onfinish=()=>{p(g)}})),g}const standardEasing="cubic-bezier(0.4, 0, 0.2, 1)";var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(v,u){module.exports=u()})(self,()=>(()=>{var __webpack_modules__={8453:(v,u,b)=>{b.r(u),b.d(u,{InferenceSession:()=>n,Tensor:()=>t,env:()=>s,registerBackend:()=>m});const g={},p=[],m=(r,i,c)=>{if(!i||typeof i.init!="function"||typeof i.createSessionHandler!="function")throw new TypeError("not a valid backend");{const f=g[r];if(f===void 0)g[r]={backend:i,priority:c};else{if(f.priority>c)return;if(f.priority===c&&f.backend!==i)throw new Error(`cannot register backend "${r}" using priority ${c}`)}if(c>=0){const y=p.indexOf(r);y!==-1&&p.splice(y,1);for(let w=0;w<p.length;w++)if(g[p[w]].priority<=c)return void p.splice(w,0,r);p.push(r)}}},s=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(r){if(r!==void 0){if(typeof r!="string"||["verbose","info","warning","error","fatal"].indexOf(r)===-1)throw new Error(`Unsupported logging level: ${r}`);this.logLevelInternal=r}}get logLevel(){return this.logLevelInternal}},l=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),d=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let a=!1;class o{constructor(i,c,f){let y,w,x;if((()=>{if(!a){a=!0;const S=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",I=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";S&&(l.set("int64",BigInt64Array),d.set(BigInt64Array,"int64")),I&&(l.set("uint64",BigUint64Array),d.set(BigUint64Array,"uint64"))}})(),typeof i=="string")if(y=i,x=f,i==="string"){if(!Array.isArray(c))throw new TypeError("A string tensor's data must be a string array.");w=c}else{const S=l.get(i);if(S===void 0)throw new TypeError(`Unsupported tensor type: ${i}.`);if(Array.isArray(c))w=S.from(c);else{if(!(c instanceof S))throw new TypeError(`A ${y} tensor's data must be type of ${S}`);w=c}}else if(x=c,Array.isArray(i)){if(i.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const S=typeof i[0];if(S==="string")y="string",w=i;else{if(S!=="boolean")throw new TypeError(`Invalid element type of data array: ${S}.`);y="bool",w=Uint8Array.from(i)}}else{const S=d.get(i.constructor);if(S===void 0)throw new TypeError(`Unsupported type for tensor data: ${i.constructor}.`);y=S,w=i}if(x===void 0)x=[w.length];else if(!Array.isArray(x))throw new TypeError("A tensor's dims must be a number array");const _=(S=>{let I=1;for(let O=0;O<S.length;O++){const T=S[O];if(typeof T!="number"||!Number.isSafeInteger(T))throw new TypeError(`dims[${O}] must be an integer, got: ${T}`);if(T<0)throw new RangeError(`dims[${O}] must be a non-negative integer, got: ${T}`);I*=T}return I})(x);if(_!==w.length)throw new Error(`Tensor's size(${_}) does not match data length(${w.length}).`);this.dims=x,this.type=y,this.data=w,this.size=_}static bufferToTensor(i,c){if(i===void 0)throw new Error("Image buffer must be defined");if(c.height===void 0||c.width===void 0)throw new Error("Image height and width must be defined");if(c.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:f,width:y}=c,w=c.norm??{mean:255,bias:0};let x,_;x=typeof w.mean=="number"?[w.mean,w.mean,w.mean,w.mean]:[w.mean[0],w.mean[1],w.mean[2],w.mean[3]??255],_=typeof w.bias=="number"?[w.bias,w.bias,w.bias,w.bias]:[w.bias[0],w.bias[1],w.bias[2],w.bias[3]??0];const S=c.bitmapFormat!==void 0?c.bitmapFormat:"RGBA",I=c.tensorFormat!==void 0&&c.tensorFormat!==void 0?c.tensorFormat:"RGB",O=f*y,T=I==="RGBA"?new Float32Array(4*O):new Float32Array(3*O);let A=4,P=0,R=1,D=2,$=3,M=0,C=O,k=2*O,z=-1;S==="RGB"&&(A=3,P=0,R=1,D=2,$=-1),I==="RGBA"?z=3*O:I==="RBG"?(M=0,k=O,C=2*O):I==="BGR"&&(k=0,C=O,M=2*O);for(let G=0;G<O;G++,P+=A,D+=A,R+=A,$+=A)T[M++]=(i[P]+_[0])/x[0],T[C++]=(i[R]+_[1])/x[1],T[k++]=(i[D]+_[2])/x[2],z!==-1&&$!==-1&&(T[z++]=(i[$]+_[3])/x[3]);return new o("float32",T,I==="RGBA"?[1,4,f,y]:[1,3,f,y])}static async fromImage(i,c){const f=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,y=typeof ImageData<"u"&&i instanceof ImageData,w=typeof ImageBitmap<"u"&&i instanceof ImageBitmap,x=typeof i=="string";let _,S=c??{};if(f){const I=document.createElement("canvas");I.width=i.width,I.height=i.height;const O=I.getContext("2d");if(O==null)throw new Error("Can not access image data");{let T=i.height,A=i.width;if(c!==void 0&&c.resizedHeight!==void 0&&c.resizedWidth!==void 0&&(T=c.resizedHeight,A=c.resizedWidth),c!==void 0){if(S=c,c.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(S.tensorFormat="RGBA",c.height!==void 0&&c.height!==T)throw new Error("Image input config height doesn't match HTMLImageElement height");if(S.height=T,c.width!==void 0&&c.width!==A)throw new Error("Image input config width doesn't match HTMLImageElement width");S.width=A}else S.tensorFormat="RGBA",S.height=T,S.width=A;O.drawImage(i,0,0),_=O.getImageData(0,0,A,T).data}}else{if(!y){if(w){if(c===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(c.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const I=document.createElement("canvas").getContext("2d");if(I!=null){const O=i.height,T=i.width;if(I.drawImage(i,0,0,T,O),_=I.getImageData(0,0,T,O).data,c!==void 0){if(c.height!==void 0&&c.height!==O)throw new Error("Image input config height doesn't match ImageBitmap height");if(S.height=O,c.width!==void 0&&c.width!==T)throw new Error("Image input config width doesn't match ImageBitmap width");S.width=T}else S.height=O,S.width=T;return o.bufferToTensor(_,S)}throw new Error("Can not access image data")}if(x)return new Promise((I,O)=>{const T=document.createElement("canvas"),A=T.getContext("2d");if(!i||!A)return O();const P=new Image;P.crossOrigin="Anonymous",P.src=i,P.onload=()=>{T.width=P.width,T.height=P.height,A.drawImage(P,0,0,T.width,T.height);const R=A.getImageData(0,0,T.width,T.height);if(c!==void 0){if(c.height!==void 0&&c.height!==T.height)throw new Error("Image input config height doesn't match height");if(S.height=T.height,c.width!==void 0&&c.width!==T.width)throw new Error("Image input config width doesn't match width");S.width=T.width}else S.height=T.height,S.width=T.width;I(o.bufferToTensor(R.data,S))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const I="RGBA";let O,T;if(c!==void 0&&c.resizedWidth!==void 0&&c.resizedHeight!==void 0?(O=c.resizedHeight,T=c.resizedWidth):(O=i.height,T=i.width),c!==void 0){if(S=c,c.bitmapFormat!==void 0&&c.bitmapFormat!==I)throw new Error("Image input config format must be RGBA for ImageData");S.bitmapFormat="RGBA"}else S.bitmapFormat="RGBA";if(S.height=O,S.width=T,c!==void 0){const A=document.createElement("canvas");A.width=T,A.height=O;const P=A.getContext("2d");if(P==null)throw new Error("Can not access image data");P.putImageData(i,0,0),_=P.getImageData(0,0,T,O).data}else _=i.data}}if(_!==void 0)return o.bufferToTensor(_,S);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(i){const c=document.createElement("canvas");c.width=this.dims[3],c.height=this.dims[2];const f=c.getContext("2d");if(f!=null){let y,w;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(y=this.dims[2],w=this.dims[3]):(y=this.dims[3],w=this.dims[2]);const x=(i==null?void 0:i.format)!==void 0?i.format:"RGB",_=i==null?void 0:i.norm;let S,I;_===void 0||_.mean===void 0?S=[255,255,255,255]:typeof _.mean=="number"?S=[_.mean,_.mean,_.mean,_.mean]:(S=[_.mean[0],_.mean[1],_.mean[2],0],_.mean[3]!==void 0&&(S[3]=_.mean[3])),_===void 0||_.bias===void 0?I=[0,0,0,0]:typeof _.bias=="number"?I=[_.bias,_.bias,_.bias,_.bias]:(I=[_.bias[0],_.bias[1],_.bias[2],0],_.bias[3]!==void 0&&(I[3]=_.bias[3]));const O=w*y;let T=0,A=O,P=2*O,R=-1;x==="RGBA"?(T=0,A=O,P=2*O,R=3*O):x==="RGB"?(T=0,A=O,P=2*O):x==="RBG"&&(T=0,P=O,A=2*O);for(let D=0;D<w;D++)for(let $=0;$<y;$++){const M=(this.data[T++]-I[0])*S[0],C=(this.data[A++]-I[1])*S[1],k=(this.data[P++]-I[2])*S[2],z=R===-1?255:(this.data[R++]-I[3])*S[3];f.fillStyle="rgba("+M+","+C+","+k+","+z+")",f.fillRect($,D,1,1)}return c.toDataURL()}throw new Error("Can not access image data")}toImageData(i){const c=document.createElement("canvas").getContext("2d");let f;if(c==null)throw new Error("Can not access image data");{let y,w,x;(i==null?void 0:i.tensorLayout)!==void 0&&i.tensorLayout==="NHWC"?(y=this.dims[2],w=this.dims[1],x=this.dims[3]):(y=this.dims[3],w=this.dims[2],x=this.dims[1]);const _=i!==void 0&&i.format!==void 0?i.format:"RGB",S=i==null?void 0:i.norm;let I,O;S===void 0||S.mean===void 0?I=[255,255,255,255]:typeof S.mean=="number"?I=[S.mean,S.mean,S.mean,S.mean]:(I=[S.mean[0],S.mean[1],S.mean[2],255],S.mean[3]!==void 0&&(I[3]=S.mean[3])),S===void 0||S.bias===void 0?O=[0,0,0,0]:typeof S.bias=="number"?O=[S.bias,S.bias,S.bias,S.bias]:(O=[S.bias[0],S.bias[1],S.bias[2],0],S.bias[3]!==void 0&&(O[3]=S.bias[3]));const T=w*y;if(i!==void 0){if(i.height!==void 0&&i.height!==w)throw new Error("Image output config height doesn't match tensor height");if(i.width!==void 0&&i.width!==y)throw new Error("Image output config width doesn't match tensor width");if(i.format!==void 0&&x===4&&i.format!=="RGBA"||x===3&&i.format!=="RGB"&&i.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const A=4;let P=0,R=1,D=2,$=3,M=0,C=T,k=2*T,z=-1;_==="RGBA"?(M=0,C=T,k=2*T,z=3*T):_==="RGB"?(M=0,C=T,k=2*T):_==="RBG"&&(M=0,k=T,C=2*T),f=c.createImageData(y,w);for(let G=0;G<w*y;P+=A,R+=A,D+=A,$+=A,G++)f.data[P]=(this.data[M++]-O[0])*I[0],f.data[R]=(this.data[C++]-O[1])*I[1],f.data[D]=(this.data[k++]-O[2])*I[2],f.data[$]=z===-1?255:(this.data[z++]-O[3])*I[3]}return f}reshape(i){return new o(this.type,this.data,i)}}const t=o;class e{constructor(i){this.handler=i}async run(i,c,f){const y={};let w={};if(typeof i!="object"||i===null||i instanceof t||Array.isArray(i))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let x=!0;if(typeof c=="object"){if(c===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(c instanceof t)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(c)){if(c.length===0)throw new TypeError("'fetches' cannot be an empty array.");x=!1;for(const I of c){if(typeof I!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(I)===-1)throw new RangeError(`'fetches' contains invalid output name: ${I}.`);y[I]=null}if(typeof f=="object"&&f!==null)w=f;else if(f!==void 0)throw new TypeError("'options' must be an object.")}else{let I=!1;const O=Object.getOwnPropertyNames(c);for(const T of this.outputNames)if(O.indexOf(T)!==-1){const A=c[T];(A===null||A instanceof t)&&(I=!0,x=!1,y[T]=A)}if(I){if(typeof f=="object"&&f!==null)w=f;else if(f!==void 0)throw new TypeError("'options' must be an object.")}else w=c}}else if(c!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const I of this.inputNames)if(i[I]===void 0)throw new Error(`input '${I}' is missing in 'feeds'.`);if(x)for(const I of this.outputNames)y[I]=null;const _=await this.handler.run(i,y,w),S={};for(const I in _)Object.hasOwnProperty.call(_,I)&&(S[I]=new t(_[I].type,_[I].data,_[I].dims));return S}static async create(i,c,f,y){let w,x={};if(typeof i=="string"){if(w=i,typeof c=="object"&&c!==null)x=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else if(i instanceof Uint8Array){if(w=i,typeof c=="object"&&c!==null)x=c;else if(c!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const O=i;let T=0,A=i.byteLength;if(typeof c=="object"&&c!==null)x=c;else if(typeof c=="number"){if(T=c,!Number.isSafeInteger(T))throw new RangeError("'byteOffset' must be an integer.");if(T<0||T>=O.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${O.byteLength}).`);if(A=i.byteLength-T,typeof f=="number"){if(A=f,!Number.isSafeInteger(A))throw new RangeError("'byteLength' must be an integer.");if(A<=0||T+A>O.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${O.byteLength-T}].`);if(typeof y=="object"&&y!==null)x=y;else if(y!==void 0)throw new TypeError("'options' must be an object.")}else if(f!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(c!==void 0)throw new TypeError("'options' must be an object.");w=new Uint8Array(O,T,A)}}const _=(x.executionProviders||[]).map(O=>typeof O=="string"?O:O.name),S=await(async O=>{const T=O.length===0?p:O,A=[];for(const P of T){const R=g[P];if(R){if(R.initialized)return R.backend;if(R.aborted)continue;const D=!!R.initPromise;try{return D||(R.initPromise=R.backend.init()),await R.initPromise,R.initialized=!0,R.backend}catch($){D||A.push({name:P,err:$}),R.aborted=!0}finally{delete R.initPromise}}}throw new Error(`no available backend found. ERR: ${A.map(P=>`[${P.name}] ${P.err}`).join(", ")}`)})(_),I=await S.createSessionHandler(w,x);return new e(I)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const n=e},5716:(v,u,b)=>{u.R=void 0;const g=b(6027),p=b(1723);u.R=new class{async init(){}async createSessionHandler(m,s){const l=new g.Session(s);return await l.loadModel(m),new p.OnnxjsSessionHandler(l)}}},2818:(v,u,b)=>{u.c8=u.rX=void 0;const g=b(8453),p=b(5381),m=b(9544),s=b(6640);u.rX=()=>{if((typeof g.env.wasm.initTimeout!="number"||g.env.wasm.initTimeout<0)&&(g.env.wasm.initTimeout=0),typeof g.env.wasm.simd!="boolean"&&(g.env.wasm.simd=!0),typeof g.env.wasm.proxy!="boolean"&&(g.env.wasm.proxy=!1),typeof g.env.wasm.numThreads!="number"||!Number.isInteger(g.env.wasm.numThreads)||g.env.wasm.numThreads<=0){const l=typeof navigator>"u"?(0,p.cpus)().length:navigator.hardwareConcurrency;g.env.wasm.numThreads=Math.min(4,Math.ceil((l||1)/2))}},u.c8=new class{async init(){(0,u.rX)(),await(0,m.initWasm)()}async createSessionHandler(l,d){const a=new s.OnnxruntimeWebAssemblySessionHandler;return await a.loadModel(l,d),Promise.resolve(a)}}},1057:function(v,u,b){var g=this&&this.__createBinding||(Object.create?function(s,l,d,a){a===void 0&&(a=d);var o=Object.getOwnPropertyDescriptor(l,d);o&&!("get"in o?!l.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return l[d]}}),Object.defineProperty(s,a,o)}:function(s,l,d,a){a===void 0&&(a=d),s[a]=l[d]}),p=this&&this.__exportStar||function(s,l){for(var d in s)d==="default"||Object.prototype.hasOwnProperty.call(l,d)||g(l,s,d)};Object.defineProperty(u,"__esModule",{value:!0}),p(b(8453),u);const m=b(8453);{const s=b(5716).R;(0,m.registerBackend)("webgl",s,-10)}{const s=b(2818).c8;(0,m.registerBackend)("cpu",s,10),(0,m.registerBackend)("wasm",s,10),(0,m.registerBackend)("xnnpack",s,9)}},4910:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createAttributeWithCacheKey=void 0;class b{constructor(p){Object.assign(this,p)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(p=>`${this[p]}`).join(";")),this._cacheKey}}u.createAttributeWithCacheKey=g=>new b(g)},6874:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Attribute=void 0;const g=b(1446),p=b(1287),m=b(9240),s=b(7273);var l=p.onnxruntime.experimental.fbs;class d{constructor(o){if(this._attributes=new Map,o!=null){for(const t of o)t instanceof g.onnx.AttributeProto?this._attributes.set(t.name,[d.getValue(t),d.getType(t)]):t instanceof l.Attribute&&this._attributes.set(t.name(),[d.getValue(t),d.getType(t)]);if(this._attributes.size<o.length)throw new Error("duplicated attribute names")}}set(o,t,e){this._attributes.set(o,[e,t])}delete(o){this._attributes.delete(o)}getFloat(o,t){return this.get(o,"float",t)}getInt(o,t){return this.get(o,"int",t)}getString(o,t){return this.get(o,"string",t)}getTensor(o,t){return this.get(o,"tensor",t)}getFloats(o,t){return this.get(o,"floats",t)}getInts(o,t){return this.get(o,"ints",t)}getStrings(o,t){return this.get(o,"strings",t)}getTensors(o,t){return this.get(o,"tensors",t)}get(o,t,e){const n=this._attributes.get(o);if(n===void 0){if(e!==void 0)return e;throw new Error(`required attribute not found: ${o}`)}if(n[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${n[1]}`);return n[0]}static getType(o){const t=o instanceof g.onnx.AttributeProto?o.type:o.type();switch(t){case g.onnx.AttributeProto.AttributeType.FLOAT:return"float";case g.onnx.AttributeProto.AttributeType.INT:return"int";case g.onnx.AttributeProto.AttributeType.STRING:return"string";case g.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case g.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case g.onnx.AttributeProto.AttributeType.INTS:return"ints";case g.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case g.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${g.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(o){const t=o instanceof g.onnx.AttributeProto?o.type:o.type();if(t===g.onnx.AttributeProto.AttributeType.GRAPH||t===g.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const e=this.getValueNoCheck(o);if(t===g.onnx.AttributeProto.AttributeType.INT&&s.LongUtil.isLong(e))return s.LongUtil.longToNumber(e);if(t===g.onnx.AttributeProto.AttributeType.INTS){const n=e,r=new Array(n.length);for(let i=0;i<n.length;i++){const c=n[i];r[i]=s.LongUtil.longToNumber(c)}return r}if(t===g.onnx.AttributeProto.AttributeType.TENSOR)return o instanceof g.onnx.AttributeProto?m.Tensor.fromProto(e):m.Tensor.fromOrtTensor(e);if(t===g.onnx.AttributeProto.AttributeType.TENSORS){if(o instanceof g.onnx.AttributeProto)return e.map(n=>m.Tensor.fromProto(n));if(o instanceof l.Attribute)return e.map(n=>m.Tensor.fromOrtTensor(n))}if(t===g.onnx.AttributeProto.AttributeType.STRING&&o instanceof g.onnx.AttributeProto){const n=e;return(0,s.decodeUtf8String)(n)}return t===g.onnx.AttributeProto.AttributeType.STRINGS&&o instanceof g.onnx.AttributeProto?e.map(s.decodeUtf8String):e}static getValueNoCheck(o){return o instanceof g.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(o):this.getValueNoCheckFromOrtFormat(o)}static getValueNoCheckFromOnnxFormat(o){switch(o.type){case g.onnx.AttributeProto.AttributeType.FLOAT:return o.f;case g.onnx.AttributeProto.AttributeType.INT:return o.i;case g.onnx.AttributeProto.AttributeType.STRING:return o.s;case g.onnx.AttributeProto.AttributeType.TENSOR:return o.t;case g.onnx.AttributeProto.AttributeType.GRAPH:return o.g;case g.onnx.AttributeProto.AttributeType.FLOATS:return o.floats;case g.onnx.AttributeProto.AttributeType.INTS:return o.ints;case g.onnx.AttributeProto.AttributeType.STRINGS:return o.strings;case g.onnx.AttributeProto.AttributeType.TENSORS:return o.tensors;case g.onnx.AttributeProto.AttributeType.GRAPHS:return o.graphs;default:throw new Error(`unsupported attribute type: ${g.onnx.AttributeProto.AttributeType[o.type]}`)}}static getValueNoCheckFromOrtFormat(o){switch(o.type()){case l.AttributeType.FLOAT:return o.f();case l.AttributeType.INT:return o.i();case l.AttributeType.STRING:return o.s();case l.AttributeType.TENSOR:return o.t();case l.AttributeType.GRAPH:return o.g();case l.AttributeType.FLOATS:return o.floatsArray();case l.AttributeType.INTS:{const t=[];for(let e=0;e<o.intsLength();e++)t.push(o.ints(e));return t}case l.AttributeType.STRINGS:{const t=[];for(let e=0;e<o.stringsLength();e++)t.push(o.strings(e));return t}case l.AttributeType.TENSORS:{const t=[];for(let e=0;e<o.tensorsLength();e++)t.push(o.tensors(e));return t}default:throw new Error(`unsupported attribute type: ${l.AttributeType[o.type()]}`)}}}u.Attribute=d},1975:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.resolveBackend=u.backend=void 0;const g=b(4418),p=new Map;async function m(s){const l=u.backend;if(l[s]!==void 0&&function(d){const a=d;return"initialize"in a&&typeof a.initialize=="function"&&"createSessionHandler"in a&&typeof a.createSessionHandler=="function"&&"dispose"in a&&typeof a.dispose=="function"}(l[s])){const d=l[s];let a=d.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return p.set(s,d),d}}u.backend={webgl:new g.WebGLBackend},u.resolveBackend=async function s(l){if(!l)return s(["webgl"]);{const d=typeof l=="string"?[l]:l;for(const a of d){const o=p.get(a);if(o)return o;const t=await m(a);if(t)return t}}throw new Error("no available backend to use")}},4418:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLBackend=void 0;const g=b(8453),p=b(1315),m=b(2171),s=b(3389);u.WebGLBackend=class{get contextId(){return g.env.webgl.contextId}set contextId(l){g.env.webgl.contextId=l}get matmulMaxBatchSize(){return g.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(l){g.env.webgl.matmulMaxBatchSize=l}get textureCacheMode(){return g.env.webgl.textureCacheMode}set textureCacheMode(l){g.env.webgl.textureCacheMode=l}get pack(){return g.env.webgl.pack}set pack(l){g.env.webgl.pack=l}get async(){return g.env.webgl.async}set async(l){g.env.webgl.async=l}initialize(){try{return this.glContext=(0,s.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),p.Logger.setWithEnv(g.env),p.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(l){return p.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${l}`),!1}}createSessionHandler(l){return new m.WebGLSessionHandler(this,l)}dispose(){this.glContext.dispose()}}},6859:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.CoordsGlslLib=void 0;const g=b(7273),p=b(1997),m=b(6757),s=b(7618),l=b(432);class d extends p.GlslLib{constructor(o){super(o)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new p.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new p.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const o=this.context.outputTextureLayout;return o.isPacked?this.getPackedOutputSamplingSnippet(o):this.getUnpackedOutputSamplingSnippet(o)}getPackedOutputSamplingSnippet(o){const t=o.unpackedShape,e=[o.width,o.height],n={},r="getOutputCoords";switch(t.length){case 0:n[r]=this.getOutputScalarCoords();break;case 1:n[r]=this.getOutputPacked1DCoords(t,e);break;case 2:n[r]=this.getOutputPacked2DCoords(t,e);break;case 3:n[r]=this.getOutputPacked3DCoords(t,e);break;default:n[r]=this.getOutputPackedNDCoords(t,e)}const i=`
      void setOutput(vec4 val) {
        ${(0,m.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return n.floatTextureSetRGBA=new p.GlslLibRoutine(i),n}getUnpackedOutputSamplingSnippet(o){const t=o.unpackedShape,e=[o.width,o.height],n={},r="getOutputCoords";switch(t.length){case 0:n[r]=this.getOutputScalarCoords();break;case 1:n[r]=this.getOutputUnpacked1DCoords(t,e);break;case 2:n[r]=this.getOutputUnpacked2DCoords(t,e);break;case 3:n[r]=this.getOutputUnpacked3DCoords(t,e);break;case 4:n[r]=this.getOutputUnpacked4DCoords(t,e);break;case 5:n[r]=this.getOutputUnpacked5DCoords(t,e);break;case 6:n[r]=this.getOutputUnpacked6DCoords(t,e);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const i=`
        void setOutput(float val) {
          ${(0,m.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return n.floatTextureSetR=new p.GlslLibRoutine(i),n}getOutputScalarCoords(){return new p.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(o,t){const e=t;let n="";return e[0]===1?(n=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${e[1]}.0);
          }
        `,new p.GlslLibRoutine(n)):e[1]===1?(n=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${e[0]}.0);
          }
        `,new p.GlslLibRoutine(n)):(n=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${e[0]}, ${e[1]}));
          return 2 * (resTexRC.y * ${e[0]} + resTexRC.x);
        }
      `,new p.GlslLibRoutine(n))}getOutputPacked2DCoords(o,t){let e="";if(g.ArrayUtil.arraysEqual(o,t))return e=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new p.GlslLibRoutine(e);const n=t,r=Math.ceil(o[1]/2);return e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));

          int index = resTexRC.y * ${n[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${r}) * 2;
          int c = 2 * (index / ${r});

          return ivec2(r, c);
        }
      `,new p.GlslLibRoutine(e)}getOutputPacked3DCoords(o,t){const e=[t[0],t[1]],n=Math.ceil(o[2]/2),r=n*Math.ceil(o[1]/2),i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e[0]}, ${e[1]}));
          int index = resTexRC.y * ${e[0]} + resTexRC.x;

          int b = index / ${r};
          index -= b * ${r};

          // reverse r and c order for packed texture
          int r = imod(index, ${n}) * 2;
          int c = 2 * (index / ${n});

          return ivec3(b, r, c);
        }
      `;return new p.GlslLibRoutine(i)}getOutputPackedNDCoords(o,t){const e=[t[0],t[1]],n=Math.ceil(o[o.length-1]/2),r=n*Math.ceil(o[o.length-2]/2);let i=r,c="",f="b, r, c";for(let w=2;w<o.length-1;w++)i*=o[o.length-w-1],c=`
      int b${w} = index / ${i};
      index -= b${w} * ${i};
    `+c,f=`b${w}, `+f;const y=`
      ivec${o.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.y * ${e[0]} + resTexRC.x;

        ${c}

        int b = index / ${r};
        index -= b * ${r};

        // reverse r and c order for packed texture
        int r = imod(index, ${n}) * 2;
        int c = 2 * (index / ${n});

        return ivec${o.length}(${f});
      }
    `;return new p.GlslLibRoutine(y)}getOutputUnpacked1DCoords(o,t){const e=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new p.GlslLibRoutine(e)}getOutputUnpacked2DCoords(o,t){const e=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${o[1]};
          int c = index - r * ${o[1]};
          return ivec2(r, c);
        }
      `;return new p.GlslLibRoutine(e)}getOutputUnpacked3DCoords(o,t){let e="";const n=o.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=o[n-1];for(let f=n-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d"],c=r.map((f,y)=>`int ${i[y]} = index / ${f}; ${y===r.length-1?`int ${i[y+1]} = index - ${i[y]} * ${f}`:`index -= ${i[y]} * ${f}`};`).join("");return e=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${c}
          return ivec3(r, c, d);
        }
      `,new p.GlslLibRoutine(e)}getOutputUnpacked4DCoords(o,t){let e="";const n=o.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=o[n-1];for(let f=n-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2"],c=r.map((f,y)=>`int ${i[y]} = index / ${f}; ${y===r.length-1?`int ${i[y+1]} = index - ${i[y]} * ${f}`:`index -= ${i[y]} * ${f}`};`).join("");return e=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${c}
          return ivec4(r, c, d, d2);
        }
      `,new p.GlslLibRoutine(e)}getOutputUnpacked5DCoords(o,t){let e="";const n=o.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=o[n-1];for(let f=n-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2","d3"],c=r.map((f,y)=>`int ${i[y]} = index / ${f}; ${y===r.length-1?`int ${i[y+1]} = index - ${i[y]} * ${f}`:`index -= ${i[y]} * ${f}`};`).join("");return e=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${c}
          return ivec5(r, c, d, d2, d3);
        }
      `,new p.GlslLibRoutine(e)}getOutputUnpacked6DCoords(o,t){let e="";const n=o.length;let r=null;n<2&&(r=[]),r=new Array(n-1),r[n-2]=o[n-1];for(let f=n-3;f>=0;--f)r[f]=r[f+1]*o[f+1];const i=["r","c","d","d2","d3","d4"],c=r.map((f,y)=>`int ${i[y]} = index / ${f}; ${y===r.length-1?`int ${i[y+1]} = index - ${i[y]} * ${f}`:`index -= ${i[y]} * ${f}`};`).join("");return e=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${c}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new p.GlslLibRoutine(e)}getCommonUtilFuncs(){const o={};let t="uvFromFlat";o[t]=new p.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",o[t]=new p.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",o[t]=new p.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",o[t]=new p.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";const e=(0,m.getGlsl)(this.context.glContext.version);return o[t]=new p.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${e.texture2D}(textureSampler, uv).r;
        }`),o}getInputsSamplingSnippets(){const o={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((e,n)=>{const r=this.context.inputTextureLayouts[n],i=(0,l.generateShaderFuncNameFromInputSamplerName)(e);r.isPacked?o[i]=this.getPackedSamplerFromInput(i,e,r):o[i]=this.getUnpackedSamplerFromInput(i,e,r);const c=(0,l.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(e);r.unpackedShape.length<=t.unpackedShape.length&&(r.isPacked?o[c]=this.getPackedSamplerAtOutputCoords(c,r,t,e):o[c]=this.getUnpackedSamplerAtOutputCoords(c,r,t,e))}),o}getPackedSamplerAtOutputCoords(o,t,e,n){const r=t.unpackedShape,i=e.unpackedShape,c=n,f=(0,l.generateShaderFuncNameFromInputSamplerName)(c),y=r.length,w=i.length,x=g.BroadcastUtil.getBroadcastDims(r,i),_=(0,l.getCoordsDataType)(w),S=w-y;let I;const O=(0,l.getGlChannels)();I=y===0?"":w<2&&x.length>=1?"coords = 0;":x.map($=>`coords.${O[$+S]} = 0;`).join(`
`);let T="";T=w<2&&y>0?"coords":r.map(($,M)=>`coords.${O[M+S]}`).join(", ");let A="return outputValue;";const P=g.ShapeUtil.size(r)===1,R=g.ShapeUtil.size(i)===1;if(y!==1||P||R){if(P&&!R)A=w===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(x.length){const $=y-2,M=y-1;x.indexOf($)>-1&&x.indexOf(M)>-1?A="return vec4(outputValue.x);":x.indexOf($)>-1?A="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":x.indexOf(M)>-1&&(A="return vec4(outputValue.xx, outputValue.zz);")}}else A=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const D=`
      vec4 ${o}() {
        ${_} coords = getOutputCoords();
        
        int lastDim = coords.${O[w-1]};
        coords.${O[w-1]} = coords.${O[w-2]};
        coords.${O[w-2]} = lastDim;
      
        ${I}
        vec4 outputValue = ${f}(${T});
        ${A}
      }
    `;return new p.GlslLibRoutine(D,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(o,t,e,n){const r=[e.width,e.height],i=[t.width,t.height],c=t.unpackedShape.length,f=e.unpackedShape.length,y=t.unpackedShape,w=e.unpackedShape,x=(0,l.generateShaderFuncNameFromInputSamplerName)(n);if(c===f&&g.ArrayUtil.arraysEqual(i,r)){const R=`
          float ${o}() {
            return sampleTexture(${n}, TexCoords);
          }
        `;return new p.GlslLibRoutine(R,["coordinates.sampleTexture"])}const _=(0,l.getCoordsDataType)(f),S=g.BroadcastUtil.getBroadcastDims(y,w),I=f-c;let O;const T=(0,l.getGlChannels)();O=c===0?"":f<2&&S.length>=1?"coords = 0;":S.map(R=>`coords.${T[R+I]} = 0;`).join(`
`);let A="";A=f<2&&c>0?"coords":t.unpackedShape.map((R,D)=>`coords.${T[D+I]}`).join(", ");const P=`
        float ${o}() {
          ${_} coords = getOutputCoords();
          ${O}
          return ${x}(${A});
        }
      `;return new p.GlslLibRoutine(P,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(o,t,e){switch(e.unpackedShape.length){case 0:return this.getPackedSamplerScalar(o,t);case 1:return this.getPackedSampler1D(o,t,e);case 2:return this.getPackedSampler2D(o,t,e);case 3:return this.getPackedSampler3D(o,t,e);default:return this.getPackedSamplerND(o,t,e)}}getUnpackedSamplerFromInput(o,t,e){const n=e.unpackedShape;switch(n.length){case 0:return this.getUnpackedSamplerScalar(o,t,e);case 1:return this.getUnpackedSampler1D(o,t,e);case 2:return this.getUnpackedSampler2D(o,t,e);case 3:return this.getUnpackedSampler3D(o,t,e);case 4:return this.getUnpackedSampler4D(o,t,e);case 5:return this.getUnpackedSampler5D(o,t,e);case 6:return this.getUnpackedSampler6D(o,t,e);default:throw new Error(`Unsupported dimension ${n.length}-D`)}}getPackedSamplerScalar(o,t){const e=`
          vec4 ${o}() {
            return ${(0,m.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);
          }
        `;return new p.GlslLibRoutine(e)}getPackedSampler1D(o,t,e){const n=[e.width,e.height],r=[n[1],n[0]],i=(0,m.getGlsl)(this.context.glContext.version),c=`vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
      ${r[0]}, ${r[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }`;return new p.GlslLibRoutine(c,["coordinates.packedUVfrom1D"])}getPackedSampler2D(o,t,e){const n=e.unpackedShape,r=[e.width,e.height],i=(0,m.getGlsl)(this.context.glContext.version),c=r[0],f=r[1];if(r!=null&&g.ArrayUtil.arraysEqual(n,r)){const _=`vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${c}.0);
        return ${i.texture2D}(${t}, uv);
      }`;return new p.GlslLibRoutine(_)}const y=r,w=Math.ceil(n[1]/2),x=`vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${y[1]}, ${y[0]}, ${w}, row, col);
      return ${i.texture2D}(${t}, uv);
    }`;return new p.GlslLibRoutine(x,["coordinates.packedUVfrom2D"])}getPackedSampler3D(o,t,e){const n=e.unpackedShape,r=[e.width,e.height],i=[r[0],r[1]],c=(0,m.getGlsl)(this.context.glContext.version);if(n[0]===1){const _=n.slice(1),S=[1,2],I=(0,l.squeezeInputShape)(n,_),O=["b","row","col"],T=JSON.parse(JSON.stringify(e));T.unpackedShape=I;const A=this.getPackedSamplerFromInput(o,t,T),P=`${A.routineBody}
      vec4 ${o}(int b, int row, int col) {
        return ${o}(${(0,l.getSqueezedParams)(O,S)});
      } `;return new p.GlslLibRoutine(P,A.dependencies)}const f=i[0],y=i[1],w=Math.ceil(n[2]/2),x=`vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${y}, ${f}, ${w*Math.ceil(n[1]/2)}, ${w}, b, row, col);
      return ${c.texture2D}(${t}, uv);}`;return new p.GlslLibRoutine(x,["coordinates.packedUVfrom3D"])}getPackedSamplerND(o,t,e){const n=e.unpackedShape,r=n.length,i=[e.width,e.height],c=(0,m.getGlsl)(this.context.glContext.version),f=[i[0],i[1]],y=f[1],w=f[0],x=Math.ceil(n[r-1]/2);let _=x*Math.ceil(n[r-2]/2),S="int b, int row, int col",I=`b * ${_} + (row / 2) * ${x} + (col / 2)`;for(let T=2;T<r-1;T++)S=`int b${T}, `+S,_*=n[r-T-1],I=`b${T} * ${_} + `+I;const O=`vec4 ${o}(${S}) {
      int index = ${I};
      int texR = index / ${w};
      int texC = index - texR * ${w};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${w}, ${y});
      return ${c.texture2D}(${t}, uv);
    }`;return new p.GlslLibRoutine(O)}getUnpackedSamplerScalar(o,t,e){const[n,r]=[e.width,e.height];if(n===1&&r===1){const c=`
          float ${o}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new p.GlslLibRoutine(c,["coordinates.sampleTexture"])}const i=`
        float ${o}() {
          int offset_${t} = coordsToOffset(TexCoords, ${n}, ${r});
          vec2 uv = uvFromFlat(${n}, ${r}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new p.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(o,t,e){const n=e.width,r=e.height;if(r===1&&n===1){const c=`
        float ${o}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new p.GlslLibRoutine(c,["coordinates.sampleTexture"])}if(r===1){const c=`
          float ${o}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(c,["coordinates.sampleTexture"])}if(n===1){const c=`
          float ${o}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${r}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(c,["coordinates.sampleTexture"])}const i=`
        float ${o}(int index) {
          vec2 uv = uvFromFlat(${n}, ${r}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new p.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(o,t,e){const n=e.unpackedShape,r=[e.height,e.width];if(r!=null&&g.ArrayUtil.arraysEqual(n,r)){const _=`
          float ${o}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${r[1]}.0, ${r[0]}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(_,["coordinates.sampleTexture"])}const{newShape:i,keptDims:c}=(0,s.squeezeShape)(n),f=i;if(f.length<n.length){const _=(0,l.squeezeInputShape)(n,f),S=JSON.parse(JSON.stringify(e));S.unpackedShape=_;const I=["col","row"],O=`
          ${this.getUnpackedSamplerFromInput(o,t,S).routineBody}
          float ${o}(int row, int col) {
            return ${o}(${(0,l.getSqueezedParams)(I,c)});
          }
        `;return new p.GlslLibRoutine(O,["coordinates.sampleTexture"])}const y=r[1],w=r[0];if(w===1){const _=`
          float ${o}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${y}, ${w});
            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${y}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(_,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(y===1){const _=`
          float ${o}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${y}, ${w});
            float index = dot(vec3(row, col, offset_${t}), vec3(${n[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${w}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(_,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const x=`
        float ${o}(int row, int col) {
          int index = col * ${n[1]} + row;
          vec2 uv = uvFromFlat(${y}, ${w}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new p.GlslLibRoutine(x,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(o,t,e){const n=e.unpackedShape,r=n[1]*n[2],i=n[2],{newShape:c,keptDims:f}=(0,s.squeezeShape)(n),y=c;if(y.length<n.length){const x=(0,l.squeezeInputShape)(n,y),_=["batch","col","row"],S=JSON.parse(JSON.stringify(e));S.unpackedShape=x;const I=this.getUnpackedSamplerFromInput(o,t,S),O=f.reverse(),T=`
          ${I.routineBody}
          float ${o}(int batch, int row, int col) {
            return ${o}(${(0,l.getSqueezedParams)(_,O)});
          }
        `;return new p.GlslLibRoutine(T,I.dependencies)}const w=`
          float ${o}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${r} + col * ${i} + row;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new p.GlslLibRoutine(w,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(o,t,e){const n=e.unpackedShape,r=n[3],i=n[2]*r,c=`
        float ${o}(int row, int col, int depth, int depth2) {
          int index = row * ${n[1]*i} + col * ${i} +
              depth2 * ${r} + depth;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new p.GlslLibRoutine(c,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(o,t,e){const n=e.unpackedShape,r=n[4],i=n[3]*r,c=n[2]*i,f=n[1]*c,{newShape:y,keptDims:w}=(0,s.squeezeShape)(n);if(y.length<n.length){const _=(0,l.squeezeInputShape)(n,y),S=["row","col","depth","depth2","depth3"],I=JSON.parse(JSON.stringify(e));I.unpackedShape=_;const O=`
          ${this.getUnpackedSamplerFromInput(o,t,I).routineBody}
          float ${o}(int row, int col, int depth, int depth2, int depth3) {
            return ${o}(${(0,l.getSqueezedParams)(S,w)});
          }
        `;return new p.GlslLibRoutine(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const x=`
        float ${o}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${f} + col * ${c} + depth * ${i} +
          depth3 * ${r} + depth2;
          vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new p.GlslLibRoutine(x,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(o,t,e){const n=e.unpackedShape,r=n[5],i=n[4]*r,c=n[3]*i,f=n[2]*c,y=n[1]*f,{newShape:w,keptDims:x}=(0,s.squeezeShape)(n);if(w.length<n.length){const S=(0,l.squeezeInputShape)(n,w),I=["row","col","depth","depth2","depth3","depth4"],O=JSON.parse(JSON.stringify(e));O.unpackedShape=S;const T=`
            ${this.getUnpackedSamplerFromInput(o,t,O).routineBody}
            float ${o}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${o}(${(0,l.getSqueezedParams)(I,x)});
            }
          `;return new p.GlslLibRoutine(T,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const _=`
          float ${o}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${y} + col * ${f} + depth * ${c} +
            depth2 * ${i} + depth3 * ${r} + depth4;
            vec2 uv = uvFromFlat(${e.width}, ${e.height}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new p.GlslLibRoutine(_,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const o=this.context.outputTextureLayout,t=o.shape.length,e=o.strides,n=o.width,r=o.height,i=[];for(let f=0;f<t-1;++f)i.push(`
        c[${f}] = offset / ${e[f]};`),i.push(`
        offset -= c[${f}] * ${e[f]};`);i.push(`
        c[${t-1}] = offset;`);const c=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${n}, ${r});
        ${i.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${i.join("")}
      }
    `;return{toVec:new p.GlslLibRoutine(c,["coordinates.coordsToOffset"])}}valueFrom(){const o={};return this.context.programInfo.inputNames.forEach((t,e)=>{const n=this.context.inputTextureLayouts[e],r=(n.unpackedShape.length>0?n.unpackedShape:n.shape).length;let i=`_${t}`;o[i]=new p.GlslLibRoutine(this.getValueFromSingle(t,r,n.width,n.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",o[i]=new p.GlslLibRoutine(this.getValueFromSingle(t,r,n.width,n.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),o}getValueFromSingle(o,t,e,n,r){let i=`_${o}`;return r&&(i+="_T"),`
        float ${i}(int m[${t}]) {
          int offset = indicesToOffset${i}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${n});
          float value = getColorAsFloat(${(0,m.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords));
          return value;
        }
        `}getPackedValueFrom(o,t,e,n,r){let i=`_${o}_Pack`;return r&&(i+="_T"),`
        vec4 ${i}(int m[${t}]) {
          int offset = indicesToOffset_${o}(m);
          vec2 coords = offsetToCoords(offset, ${e}, ${n});
          return ${(0,m.getGlsl)(this.context.glContext.version).texture2D}(${o}, coords);
        }
        `}}u.CoordsGlslLib=d},1997:(v,u)=>{var b;Object.defineProperty(u,"__esModule",{value:!0}),u.TopologicalSortGlslRoutines=u.GlslLibRoutineNode=u.GlslLibRoutine=u.GlslLib=u.GlslContext=u.FunctionType=void 0,(b=u.FunctionType||(u.FunctionType={}))[b.ValueBased=0]="ValueBased",b[b.Positional=1]="Positional",u.GlslContext=class{constructor(g,p,m,s){this.glContext=g,this.programInfo=p,this.inputTextureLayouts=m,this.outputTextureLayout=s}},u.GlslLib=class{constructor(g){this.context=g}},u.GlslLibRoutine=class{constructor(g,p){this.routineBody=g,this.dependencies=p}},u.GlslLibRoutineNode=class{constructor(g,p,m){this.name=g,this.dependencies=m||[],p&&(this.routineBody=p)}addDependency(g){g&&this.dependencies.push(g)}},u.TopologicalSortGlslRoutines=class{static returnOrderedNodes(g){if(!g||g.length===0)return[];if(g.length===1)return g;const p=new Set,m=new Set,s=new Array;return this.createOrderedNodes(g,p,m,s),s}static createOrderedNodes(g,p,m,s){for(let l=0;l<g.length;++l)this.dfsTraverse(g[l],p,m,s)}static dfsTraverse(g,p,m,s){if(!g||m.has(g.name))return;if(p.has(g.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");p.add(g.name);const l=g.dependencies;if(l&&l.length>0)for(let d=0;d<l.length;++d)this.dfsTraverse(l[d],p,m,s);s.push(g),m.add(g.name),p.delete(g.name)}}},1371:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.EncodingGlslLib=void 0;const g=b(1997);class p extends g.GlslLib{constructor(s){super(s)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new g.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new g.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const s=p.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new g.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${s}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const s=p.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new g.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${s}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const s=new ArrayBuffer(4),l=new Uint32Array(s),d=new Uint8Array(s);if(l[0]=3735928559,d[0]===239)return!0;if(d[0]===222)return!1;throw new Error("unknown endianness")}}u.EncodingGlslLib=p},2691:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.FragColorGlslLib=void 0;const g=b(1997),p=b(6757);class m extends g.GlslLib{constructor(l){super(l)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const l=(0,p.getGlsl)(this.context.glContext.version);return{setFragColor:new g.GlslLibRoutine(`
        void setFragColor(float value) {
            ${l.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new g.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}u.FragColorGlslLib=m},3878:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.replaceInlines=void 0;const b=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;u.replaceInlines=function(g){const p={};let m;for(;(m=b.exec(g))!==null;){const s=m[3].split(",").map(l=>{const d=l.trim().split(" ");return d&&d.length===2?{type:d[0],name:d[1]}:null}).filter(l=>l!==null);p[m[2]]={params:s,body:m[4]}}for(const s in p){const l="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",s),d=new RegExp(l,"gm");for(;(m=d.exec(g))!==null;){const a=m[1],o=m[2],t=m[3].split(","),e=a?`${a} ${o};`:"";let n=p[s].body,r="";p[s].params.forEach((c,f)=>{c&&(r+=`${c.type} ${c.name} = ${t[f]};
`)}),n=`${r}
 ${n}`,n=n.replace("return",`${o} = `);const i=`
      ${e}
      {
        ${n}
      }
      `;g=g.replace(m[0],i)}}return g.replace(b,"")}},8897:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.GlslPreprocessor=void 0;const g=b(1997),p=b(3878),m=b(1248),s=b(6757);u.GlslPreprocessor=class{constructor(l,d,a,o){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new g.GlslContext(l,d,a,o),Object.keys(m.glslRegistry).forEach(e=>{const n=new m.glslRegistry[e](this.context);this.libs[e]=n});const t=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const n=this.libs[e].getFunctions();for(const r in n){const i=e+"."+r;let c;t[i]?(c=t[i],c.routineBody=n[r].routineBody):(c=new g.GlslLibRoutineNode(i,n[r].routineBody),t[i]=c);const f=n[r].dependencies;if(f)for(let y=0;y<f.length;++y)if(t[f[y]])c.addDependency(t[f[y]]);else{const w=new g.GlslLibRoutineNode(f[y]);t[f[y]]=w,c.addDependency(w)}}}}preprocess(){const l=this.context.programInfo;let d=l.shaderSource;return this.context.programInfo.hasMain||(d=`${d}
      ${(0,s.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),d=(0,p.replaceInlines)(d),`${(0,s.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(l.inputNames,l.variables)}
    ${this.getImports(d)}
    ${d}`}getImports(l){const d=this.selectGlslLibRoutinesToBeIncluded(l);if(d.length===0)return"";let a="";for(let o=0;o<d.length;++o){if(!d[o].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${d[o].name}`);a+=d[o].routineBody+`
`}return a}selectGlslLibRoutinesToBeIncluded(l){const d=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(a=>{const o=a.split(".")[1];l.indexOf(o)!==-1&&d.push(this.glslLibRoutineDependencyGraph[a])}),g.TopologicalSortGlslRoutines.returnOrderedNodes(d)}getUniforms(l,d){const a=[];if(l)for(const o of l)a.push(`uniform sampler2D ${o};`);if(d)for(const o of d)a.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return a.join(`
`)}}},1248:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.glslRegistry=void 0;const g=b(6859),p=b(1371),m=b(2691),s=b(9183),l=b(9314);u.glslRegistry={encoding:p.EncodingGlslLib,fragcolor:m.FragColorGlslLib,vec:l.VecGlslLib,shapeUtils:s.ShapeUtilsGlslLib,coordinates:g.CoordsGlslLib}},9183:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ShapeUtilsGlslLib=void 0;const g=b(1997);class p extends g.GlslLib{constructor(s){super(s)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const s=this.context.outputTextureLayout.shape.length,l={};return this.context.programInfo.inputNames.forEach((d,a)=>{const o=this.context.inputTextureLayouts[a].unpackedShape;if(o.length<=s){const t=o.length,e=s-t,n=`bcastIndices_${d}`;let r="";for(let c=0;c<t;++c)r+=`
          realIndices[${c}] = int( mod(float(bcastedIndices[${e+c}]), ${o[c]}.0) );
          `;const i=`
        void ${n} (int bcastedIndices[${s}], out int realIndices[${t}]) {
          ${r}
        }
        `;l[n]=new g.GlslLibRoutine(i)}}),l}bcastMatmulIndex(){const s=this.context.outputTextureLayout.shape.length,l={};return this.context.programInfo.inputNames.forEach((d,a)=>{const o=this.context.inputTextureLayouts[a].shape;if(!(o.length<2||o.length>s)){const t=o.length,e=s-t,n=`bcastMatmulIndices_${d}`;let r="";for(let c=0;c<t-2;++c)r+=`
          realIndices[${c}] = int( mod(float(bcastedIndices[${e+c}]), ${o[c]}.0) );
          `;const i=`
        void ${n}(int bcastedIndices[${s}], out int realIndices[${t}]) {
          ${r}
          realIndices[${t-1}] = bcastedIndices[${s-1}];
          realIndices[${t-2}] = bcastedIndices[${s-2}];
        }
        `;l[n]=new g.GlslLibRoutine(i)}}),l}indicesToOffset(){const s={};return this.context.programInfo.inputNames.forEach((l,d)=>{const a=this.context.inputTextureLayouts[d].shape,o=this.context.inputTextureLayouts[d].strides,t=a.length;let e=`indicesToOffset_${l}`;s[e]=new g.GlslLibRoutine(p.indexToOffsetSingle(e,t,o)),e=`indicesToOffset_${l}_T`,s[e]=new g.GlslLibRoutine(p.indexToOffsetSingle(e,t,o.slice().reverse()))}),s}static indexToOffsetSingle(s,l,d){let a="";for(let o=l-1;o>=0;--o)a+=`
        offset += indices[${o}] * ${d[o]};
        `;return`
      int ${s}(int indices[${l}]) {
        int offset = 0;
        ${a}
        return offset;
      }
      `}offsetToIndices(){const s={};return this.context.programInfo.inputNames.forEach((l,d)=>{const a=this.context.inputTextureLayouts[d].shape,o=this.context.inputTextureLayouts[d].strides,t=a.length;let e=`offsetToIndices_${l}`;s[e]=new g.GlslLibRoutine(p.offsetToIndicesSingle(e,t,o)),e=`offsetToIndices_${l}_T`,s[e]=new g.GlslLibRoutine(p.offsetToIndicesSingle(e,t,o.slice().reverse()))}),s}static offsetToIndicesSingle(s,l,d){const a=[];for(let o=0;o<l-1;++o)a.push(`
      indices[${o}] = offset / ${d[o]};`),a.push(`
        offset -= indices[${o}] * ${d[o]};`);return a.push(`
      indices[${l-1}] = offset;`),`
      void ${s}(int offset, out int indices[${l}]) {
        ${a.join("")}
      }
      `}incrementIndices(){const s={};return this.context.programInfo.inputNames.forEach((l,d)=>{const a=this.context.inputTextureLayouts[d].shape,o=a.length,t=`incrementIndices_${l}`;let e="";for(let r=0;r<o;++r)e+=`
        shape[${r}] = ${a[r]};`;const n=`
        void ${t}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${e};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;s[t]=new g.GlslLibRoutine(n)}),s}}u.ShapeUtilsGlslLib=p},6757:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getDefaultFragShaderMain=u.getFragShaderPreamble=u.getVertexShaderSource=u.getGlsl=void 0;const b={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},g={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function p(m){return m===1?b:g}u.getGlsl=p,u.getVertexShaderSource=function(m){const s=p(m);return`${s.version}
      precision highp float;
      ${s.attribute} vec3 position;
      ${s.attribute} vec2 textureCoord;

      ${s.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},u.getFragShaderPreamble=function(m){const s=p(m);return`${s.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${s.varyingFrag} vec2 TexCoords;
    ${s.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},u.getDefaultFragShaderMain=function(m,s){return`
  void main() {
    int indices[${s}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${p(m).output} = result;
  }
  `}},9314:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.VecGlslLib=void 0;const g=b(1997);class p extends g.GlslLib{constructor(s){super(s)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const s=this.context.outputTextureLayout.shape.length,l={add:"+=",sub:"-=",mul:"*=",div:"/="},d={};for(const a in l){const o=`${a}Vec`;let t="";for(let n=0;n<s;++n)t+=`
          dest[${n}] ${l[a]} src[${n}];
          `;const e=`
        void ${o}(int src[${s}], out int dest[${s}]) {
          ${t}
        }
        `;d[o]=new g.GlslLibRoutine(e)}return d}copyVec(){const s=this.context.outputTextureLayout.shape.length;let l="";for(let a=0;a<s;++a)l+=`
        dest[${a}] = src[${a}];
        `;const d=`
      void copyVec(int src[${s}], out int dest[${s}]) {
        ${l}
      }
      `;return{copyVec:new g.GlslLibRoutine(d)}}setVecItem(){const s=this.context.outputTextureLayout.shape.length;let l=`
        if(index < 0)
            index =${s} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<s-1;++a)l+=`
        else if (index == ${a})
            m[${a}] = value;
            `;l+=`
        else
            m[${s-1}] = value;
        `;const d=`
      void setVecItem(out int m[${s}], int index, int value) {
        ${l}
      }
        `;return{setVecItem:new g.GlslLibRoutine(d)}}getVecItem(){const s=this.context.outputTextureLayout.shape.length;let l=`
        if(index < 0)
            index = ${s} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<s-1;++a)l+=`
        else if (index == ${a})
            return m[${a}];
      `;l+=`
        else
            return m[${s-1}];
        `;const d=`
      int getVecItem(int m[${s}], int index) {
        ${l}
      }
    `;return{getVecItem:new g.GlslLibRoutine(d)}}}u.VecGlslLib=p},7860:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLInferenceHandler=void 0;const g=b(1315),p=b(9240),m=b(7273),s=b(9),l=b(7379),d=b(2488),a=b(540),o=b(3314),t=b(5639);u.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,n){return(0,o.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,n)}executeProgram(e,n){if(n.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const r=[];for(let x=0;x<e.inputNames.length;++x)r[x]=this.getOrCreateTextureData(n[x],e.inputTypes[x]);const i=((x,_)=>{const S=_.map(O=>`${O.unpackedShape.join(",")};${O.width}x${O.height}`).join("_");let I=x.name;return x.cacheHint&&(I+="["+x.cacheHint+"]"),I+=":"+S,I})(e,r);let c=this.session.programManager.getArtifact(i);const f=c?c.programInfo:typeof e.get=="function"?e.get():e,y=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,f.output.dims,f.output.textureType),w=this.createTextureData(y,f.output.type);return c||(c=this.session.programManager.build(f,r,w),this.session.programManager.setArtifact(i,c)),this.runProgram(c,r,w),w}run(e,n){return this.executeProgram(e,n).tensor}runProgram(e,n,r){for(let i=0;i<n.length;++i)if(!!n[i].isPacked!=(e.programInfo.inputTypes[i]===t.TextureType.packed))throw new Error(`input[${i}] property packed inconsistent`);if(!!r.isPacked!=(e.programInfo.output.textureType===t.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,n,r)}getOrCreateTextureData(e,n){let r=this.getTextureData(e.dataId,n===t.TextureType.packed);if(!r&&(r=this.getTextureData(e.dataId,n!==t.TextureType.packed),r))return n===t.TextureType.packed?this.pack(r):this.unpack(r);if(!r){const i=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,n);if(n===t.TextureType.packedLastDimension){const y=e.dims;if(y.length===4){const w=[y[0],Math.ceil(y[1]*y[2]*y[3]/4)],x=(0,o.createTextureLayoutFromTextureType)(this.session.layoutStrategy,w,n);let _=e.numberData;if(y[1]*y[2]*y[3]%4!=0){const S=y[0],I=y[1]*y[2]*y[3],O=Math.ceil(I*1/4)*4;_=new Float32Array(S*O);for(let T=0;T<S;++T){const A=T*I,P=T*O+T%1*I;_.set(e.numberData.subarray(A,A+I),P)}}return this.createTextureData(x,e.type,_,e,1)}}if(n===t.TextureType.packed){const c=(0,o.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),f=this.createTextureData(c,e.type,e.numberData,e,1);r=this.pack(f)}else r=this.createTextureData(i,e.type,e.numberData,e,1)}return r}createTextureDataFromLayoutBindTensor(e,n,r,i){return this.createTextureData(e,n,r,i,1)}createTextureData(e,n,r,i,c){g.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const f=this.session.textureManager.createTextureFromLayout(n,e,r,c);return this.createTextureDataFromTexture(e,n,f,i)}reshapeUnpacked(e,n){const r=this.getOrCreateTextureData(e,t.TextureType.unpacked),i={channels:r.channels,height:r.height,width:r.width,shape:n.length!==0?n:[1],strides:m.ShapeUtil.computeStrides(n),unpackedShape:n};return this.createTextureDataFromTexture(i,e.type,r.texture).tensor}reshapePacked(e,n){const r=this.getOrCreateTextureData(e,t.TextureType.packed);if((0,l.isReshapeCheap)(e.dims,n)){const w={channels:r.channels,height:r.height,width:r.width,shape:n.length!==0?n:[1],strides:m.ShapeUtil.computeStrides(n),unpackedShape:n,isPacked:!0};return this.createTextureDataFromTexture(w,e.type,r.texture).tensor}const i=(0,l.processDims3D)(e.dims),c=(0,l.processDims3D)(n),f=this.reshapePacked(e,i),y=this.run((0,l.createPackedReshape3DProgramInfoLoader)(this,f,c),[f]);return this.reshapePacked(y,n)}cast(e,n){const r=this.getOrCreateTextureData(e,t.TextureType.unpacked);return this.createTextureDataFromTexture(r,n,r.texture).tensor}createTextureDataFromTexture(e,n,r,i,c){const f=Object.assign(Object.assign({},e),{tensor:i||new p.Tensor(e.unpackedShape,n,y=>this.readTexture(f),async y=>this.readTextureAsync(f),void 0,c),texture:r});return this.setTextureData(f.tensor.dataId,f,e.isPacked),f}getTextureData(e,n=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,n):n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,r=!1){this.session.isInitializer(e)?this.session.setTextureData(e,n,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,n)}isTextureLayoutCached(e,n=!1){return!!this.getTextureData(e.dataId,n)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,d.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,d.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,s.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,a.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},4110:function(v,u,b){var g=this&&this.__createBinding||(Object.create?function(Y,K,ee,oe){oe===void 0&&(oe=ee);var Q=Object.getOwnPropertyDescriptor(K,ee);Q&&!("get"in Q?!K.__esModule:Q.writable||Q.configurable)||(Q={enumerable:!0,get:function(){return K[ee]}}),Object.defineProperty(Y,oe,Q)}:function(Y,K,ee,oe){oe===void 0&&(oe=ee),Y[oe]=K[ee]}),p=this&&this.__setModuleDefault||(Object.create?function(Y,K){Object.defineProperty(Y,"default",{enumerable:!0,value:K})}:function(Y,K){Y.default=K}),m=this&&this.__importStar||function(Y){if(Y&&Y.__esModule)return Y;var K={};if(Y!=null)for(var ee in Y)ee!=="default"&&Object.prototype.hasOwnProperty.call(Y,ee)&&g(K,Y,ee);return p(K,Y),K};Object.defineProperty(u,"__esModule",{value:!0}),u.WEBGL_OP_RESOLVE_RULES=void 0;const s=b(8817),l=m(b(5194)),d=b(4752),a=b(6668),o=b(9754),t=b(5042),e=b(6742),n=b(4125),r=b(6149),i=b(5378),c=b(6981),f=b(7413),y=b(7006),w=b(8276),x=b(5565),_=b(2834),S=b(1010),I=b(8126),O=b(2801),T=b(565),A=b(2444),P=b(815),R=b(564),D=b(5416),$=b(1240),M=b(5944),C=b(5707),k=m(b(9087)),z=b(7862),G=b(3980);u.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",k.abs],["Acos","","7+",k.acos],["Add","","7+",l.add],["And","","7+",l.and],["Asin","","7+",k.asin],["Atan","","7+",k.atan],["AveragePool","","7+",_.averagePool,_.parseAveragePoolAttributes],["BatchNormalization","","7+",s.batchNormalization,s.parseBatchNormalizationAttributes],["Cast","","6+",d.cast,d.parseCastAttributes],["Ceil","","6+",k.ceil],["Clip","","6-10",k.clip,k.parseClipAttributes],["Clip","","11+",k.clipV11],["Concat","","4+",a.concat,a.parseConcatAttributes],["Conv","","1+",o.conv,o.parseConvAttributes],["ConvTranspose","","1+",t.convTranspose,t.parseConvTransposeAttributes],["Cos","","7+",k.cos],["Div","","7+",l.div],["Dropout","","7+",k.identity],["DepthToSpace","","1+",e.depthToSpace,e.parseDepthToSpaceAttributes],["Equal","","7+",l.equal],["Elu","","6+",k.elu,k.parseEluAttributes],["Exp","","6+",k.exp],["Flatten","","1+",n.flatten,n.parseFlattenAttributes],["Floor","","6+",k.floor],["FusedConv","com.microsoft","1+",o.conv,o.parseConvAttributes],["Gather","","1+",r.gather,r.parseGatherAttributes],["Gemm","","7-10",i.gemm,i.parseGemmAttributesV7],["Gemm","","11+",i.gemm,i.parseGemmAttributesV11],["GlobalAveragePool","","1+",_.globalAveragePool,_.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",_.globalMaxPool],["Greater","","7+",l.greater],["Identity","","1+",k.identity],["ImageScaler","","1+",c.imageScaler,c.parseImageScalerAttributes],["InstanceNormalization","","6+",f.instanceNormalization,f.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",k.leakyRelu,k.parseLeakyReluAttributes],["Less","","7+",l.less],["LRN","","1+",y.lrn,y.parseLrnAttributes],["Log","","6+",k.log],["MatMul","","1+",w.matMul,w.parseMatMulAttributes],["MaxPool","","1+",_.maxPool,_.parseMaxPoolAttributes],["Mul","","7+",l.mul],["Neg","","6+",k.neg],["Not","","1+",k.not],["Or","","7+",l.or],["Pad","","2-10",x.padV2,x.parsePadAttributesV2],["Pad","","11+",x.padV11,x.parsePadAttributesV11],["Pow","","7+",l.pow],["PRelu","","7+",l.pRelu],["ReduceLogSum","","1+",S.reduceLogSum,S.parseReduceAttributes],["ReduceMax","","1+",S.reduceMax,S.parseReduceAttributes],["ReduceMean","","1+",S.reduceMean,S.parseReduceAttributes],["ReduceMin","","1+",S.reduceMin,S.parseReduceAttributes],["ReduceProd","","1+",S.reduceProd,S.parseReduceAttributes],["ReduceSum","","1-12",S.reduceSum,S.parseReduceAttributes],["ReduceSumSquare","","1+",S.reduceLogSumSquare,S.parseReduceAttributes],["Relu","","6+",k.relu],["Reshape","","5+",I.reshape],["Resize","","10",O.resize,O.parseResizeAttributesV10],["Resize","","11+",O.resize,O.parseResizeAttributesV11],["Shape","","1+",T.shape],["Sigmoid","","6+",k.sigmoid],["Sin","","7+",k.sin],["Slice","","10+",A.sliceV10],["Slice","","1-9",A.slice,A.parseSliceAttributes],["Softmax","","1-12",P.softmax,P.parseSoftmaxAttributes],["Softmax","","13+",P.softmaxV13,P.parseSoftmaxAttributesV13],["Split","","2-12",R.split,R.parseSplitAttributes],["Sqrt","","6+",k.sqrt],["Squeeze","","1-12",D.squeeze,D.parseSqueezeAttributes],["Squeeze","","13+",D.squeezeV13],["Sub","","7+",l.sub],["Sum","","6+",$.sum],["Tan","","7+",k.tan],["Tanh","","6+",k.tanh],["Tile","","6+",M.tile],["Transpose","","1+",C.transpose,C.parseTransposeAttributes],["Upsample","","7-8",G.upsample,G.parseUpsampleAttributesV7],["Upsample","","9",G.upsample,G.parseUpsampleAttributesV9],["Unsqueeze","","1-12",z.unsqueeze,z.parseUnsqueezeAttributes],["Unsqueeze","","13+",z.unsqueezeV13],["Xor","","7+",l.xor]]},8817:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseBatchNormalizationAttributes=u.batchNormalization=void 0;const g=b(4910),p=b(6757),m=b(5639),s={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked]};u.batchNormalization=(a,o,t)=>(d(o),[a.run(Object.assign(Object.assign({},s),{cacheHint:t.cacheKey,get:()=>l(a,o,t)}),o)]),u.parseBatchNormalizationAttributes=a=>{const o=a.attributes.getFloat("epsilon",1e-5),t=a.attributes.getFloat("momentum",.9),e=a.attributes.getInt("spatial",1);return(0,g.createAttributeWithCacheKey)({epsilon:o,momentum:t,spatial:e})};const l=(a,o,t)=>{const e=(0,p.getGlsl)(a.session.backend.glContext.version),n=o[0].dims.length,[r,i]=a.calculateTextureWidthAndHeight(o[1].dims,m.TextureType.unpacked),c=`
  float process(int[${n}] indices) {
    vec2 position = offsetToCoords(indices[1], ${r}, ${i});
    float scale = getColorAsFloat(${e.texture2D}(Scale, position));
    float mean = getColorAsFloat(${e.texture2D}(Mean, position));
    float variance = getColorAsFloat(${e.texture2D}(Variance, position));
    float b = getColorAsFloat(${e.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${t.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},s),{output:{dims:o[0].dims,type:o[0].type,textureType:m.TextureType.unpacked},shaderSource:c})},d=a=>{if(!a||a.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const o=a[0],t=a[1],e=a[2],n=a[3],r=a[4];if(o.dims.length<3||t.dims.length!==1||e.dims.length!==1||n.dims.length!==1||r.dims.length!==1)throw new Error("invalid input shape.");if(t.dims[0]!==o.dims[1]||e.dims[0]!==o.dims[1]||n.dims[0]!==o.dims[1]||r.dims[0]!==o.dims[1])throw new Error("invalid input shape.");if(o.type!=="float32"&&o.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||r.type!=="float32"&&r.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.xor=u.sub=u.pRelu=u.pow=u.or=u.mul=u.less=u.greater=u.equal=u.div=u.and=u.add=u.glslPRelu=u.glslPow=u.glslXor=u.glslOr=u.glslAnd=u.glslLess=u.glslGreater=u.glslEqual=u.glslSub=u.glslMul=u.glslDiv=u.glslAdd=void 0;const g=b(7273),p=b(1997),m=b(6757),s=b(5639);function l(){const _="add_";return{body:`
  float ${_}(float a, float b) {
    return a + b;
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:_,type:p.FunctionType.ValueBased}}function d(){const _="div_";return{body:`
  float ${_}(float a, float b) {
    return a / b;
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:_,type:p.FunctionType.ValueBased}}function a(){const _="mul_";return{body:`
  float ${_}(float a, float b) {
    return a * b;
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:_,type:p.FunctionType.ValueBased}}function o(){const _="sub_";return{body:`
  float ${_}(float a, float b) {
    return a - b;
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:_,type:p.FunctionType.ValueBased}}function t(){const _="equal_";return{body:`
  float ${_}(float a, float b) {
    return float(a == b);
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:_,type:p.FunctionType.ValueBased}}function e(){const _="greater_";return{body:`
  float ${_}(float a, float b) {
    return float(a > b);
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:_,type:p.FunctionType.ValueBased}}function n(){const _="less_";return{body:`
  float ${_}(float a, float b) {
    return float(a < b);
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:_,type:p.FunctionType.ValueBased}}function r(){const _="and_";return{body:`
  float ${_}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:_,type:p.FunctionType.ValueBased}}function i(){const _="or_";return{body:`
  float ${_}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:_,type:p.FunctionType.ValueBased}}function c(){const _="xor_";return{body:`
  float ${_}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:_,type:p.FunctionType.ValueBased}}function f(){return function(_){const S=`${_}_`;return{body:`
  float ${S}(float a, float b) {
    return ${_}(a, b);
  }
  vec4 ${S}(vec4 v1, vec4 v2) {
    return ${_}(v1, v2);
  }
  `,name:S,type:p.FunctionType.ValueBased}}("pow")}function y(){const _="prelu_";return{body:`
  float ${_}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${_}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:_,type:p.FunctionType.ValueBased}}u.glslAdd=l,u.glslDiv=d,u.glslMul=a,u.glslSub=o,u.glslEqual=t,u.glslGreater=e,u.glslLess=n,u.glslAnd=r,u.glslOr=i,u.glslXor=c,u.glslPow=f,u.glslPRelu=y;const w=(_,S,I,O=S[0].type,T)=>{const A=_.session.pack?s.TextureType.packed:s.TextureType.unpacked;return{name:I.name,inputNames:["A","B"],inputTypes:[A,A],cacheHint:T,get:()=>x(_,S,I,O)}},x=(_,S,I,O=S[0].type)=>{const T=_.session.pack?s.TextureType.packed:s.TextureType.unpacked,A=!g.ShapeUtil.areEqual(S[0].dims,S[1].dims);let P=S[0].dims;const R=_.session.pack;if(A){const M=g.BroadcastUtil.calcShape(S[0].dims,S[1].dims,!1);if(!M)throw new Error("Can't perform binary op on the given tensors");P=M;const C=P.length,k=S[0].dims.length!==0?S[0].dims.length:1,z=S[1].dims.length!==0?S[1].dims.length:1,G=S[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Y=S[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",K=(0,m.getGlsl)(_.session.backend.glContext.version),ee=R?`
      ${I.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${I.name}(a, b);
        ${K.output} = result;
      }`:`
      ${I.body}
      float process(int indices[${C}]) {
        int aindices[${k}];
        int bindices[${z}];
        ${G}
        ${Y}
        return ${I.name}(_A(aindices), _B(bindices));
      }`;return{name:I.name,inputNames:["A","B"],inputTypes:[T,T],output:{dims:P,type:O,textureType:T},shaderSource:ee,hasMain:R}}const D=(0,m.getGlsl)(_.session.backend.glContext.version),$=`
    ${I.body}
    void main() {
      vec4 v1 = ${D.texture2D}(A, TexCoords);
      vec4 v2 = ${D.texture2D}(B, TexCoords);
      vec4 result = ${I.name}(v1, v2);
      ${D.output} = result;
    }
    `;return{name:I.name,inputNames:["A","B"],inputTypes:[T,T],output:{dims:S[0].dims,type:O,textureType:T},shaderSource:$,hasMain:!0}};u.add=(_,S)=>[_.run(w(_,S,l()),S)],u.and=(_,S)=>[_.run(w(_,S,r(),"bool"),S)],u.div=(_,S)=>[_.run(w(_,S,d()),S)],u.equal=(_,S)=>[_.run(w(_,S,t(),"bool"),S)],u.greater=(_,S)=>[_.run(w(_,S,e(),"bool"),S)],u.less=(_,S)=>[_.run(w(_,S,n(),"bool"),S)],u.mul=(_,S)=>[_.run(w(_,S,a()),S)],u.or=(_,S)=>[_.run(w(_,S,i(),"bool"),S)],u.pow=(_,S)=>[_.run(w(_,S,f()),S)],u.pRelu=(_,S)=>[_.run(w(_,S,y()),S)],u.sub=(_,S)=>[_.run(w(_,S,o()),S)],u.xor=(_,S)=>[_.run(w(_,S,c(),"bool"),S)]},4752:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseCastAttributes=u.cast=void 0;const g=b(7273);u.cast=(m,s,l)=>(p(s),[m.cast(s[0],l)]),u.parseCastAttributes=m=>g.ProtoUtil.tensorDataTypeFromProto(m.attributes.getInt("to"));const p=m=>{if(!m||m.length!==1)throw new Error("Cast requires 1 input.");if(m[0].type==="string")throw new Error("Invalid input type.")}},4595:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedConcatProgramInfoLoader=void 0;const g=b(6757),p=b(5639),m=b(432),s=b(5614);u.createPackedConcatProgramInfoLoader=(d,a,o)=>{const t=(e=a.length,n=o.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:e},(r,i)=>`X${i}`),inputTypes:Array(e).fill(p.TextureType.packed),cacheHint:n});var e,n;return Object.assign(Object.assign({},t),{get:()=>((r,i,c,f)=>{const y=c[0].dims.slice();if(f>=y.length||f<-1*y.length)throw new Error("axis specified for concat doesn't match input dimensionality");f<0&&(f=y.length+f);const w=y.slice(0);for(let G=1;G<c.length;G++){const Y=c[G].dims.slice();for(let K=0;K<y.length;K++)if(K===f)w[f]+=Y[K];else if(y[K]!==Y[K])throw new Error("non concat dimensions must match")}const x=w.length,_=(0,s.getChannels)("coords",x),S=(0,m.getCoordsDataType)(x),I=(0,s.unpackFromChannel)(),O=c.map(G=>G.dims),T=(0,m.getGlChannels)(x),A=new Array(O.length-1);A[0]=O[0][f];for(let G=1;G<A.length;G++)A[G]=A[G-1]+O[G][f];const P=T[f],R=T.slice(-2),D=T.join();let $=`if (${P} < ${A[0]}) {
        return getChannel(
            getX0(${D}), vec2(${R.join()}));
        }`;for(let G=1;G<A.length;G++){const Y=A[G-1];$+=`
            if (${P} < ${A[G]}  && ${P} >= ${A[G-1]}) {
              return getChannel(
                getX${G}(${l(T,P,Y)}),
                vec2(${l(R,P,Y)}));
            }`}const M=A.length,C=A[A.length-1];$+=`
            return getChannel(
              getX${M}(${l(T,P,C)}),
              vec2(${l(R,P,C)}));`;const k=(0,g.getGlsl)(r.session.backend.glContext.version),z=`
          ${I}
          float getValue(${T.map(G=>"int "+G)}) {
            ${$}
          }

          void main() {
            ${S} coords = getOutputCoords();
            int lastDim = coords.${T[x-1]};
            coords.${T[x-1]} = coords.${T[x-2]};
            coords.${T[x-2]} = lastDim;

            vec4 result = vec4(getValue(${_}), 0., 0., 0.);

            ${_[x-1]} = ${_[x-1]} + 1;
            if (${_[x-1]} < ${w[x-1]}) {
              result.g = getValue(${_});
            }

            ${_[x-2]} = ${_[x-2]} + 1;
            if (${_[x-2]} < ${w[x-2]}) {
              result.a = getValue(${_});
            }

            ${_[x-1]} = ${_[x-1]} - 1;
            if (${_[x-2]} < ${w[x-2]} &&
                ${_[x-1]} < ${w[x-1]}) {
              result.b = getValue(${_});
            }
            ${k.output} = result;
          }
        `;return Object.assign(Object.assign({},i),{output:{dims:w,type:c[0].type,textureType:p.TextureType.packed},shaderSource:z,hasMain:!0})})(d,t,a,o.axis)})};const l=(d,a,o)=>{const t=d.indexOf(a);return d.map((e,n)=>n===t?`${e} - ${o}`:e).join()}},6668:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConcatAttributes=u.concat=void 0;const g=b(4910),p=b(5639),m=b(4595);u.concat=(e,n,r)=>(t(n),e.session.pack&&n[0].dims.length>1?[e.run((0,m.createPackedConcatProgramInfoLoader)(e,n,r),n)]:[e.run(s(e,n,r),n)]);const s=(e,n,r)=>{const i=(c=n.length,f=r.cacheKey,{name:"Concat",inputNames:Array.from({length:c},(y,w)=>`X${w}`),inputTypes:Array(c).fill(p.TextureType.unpacked),cacheHint:f});var c,f;return Object.assign(Object.assign({},i),{get:()=>((y,w,x,_)=>{const S=x[0].dims.slice();if(_>=S.length||_<-1*S.length)throw new Error("axis specified for concat doesn't match input dimensionality");_<0&&(_=S.length+_);const I=S.slice(0);for(let D=1;D<x.length;D++){const $=x[D].dims.slice();for(let M=0;M<S.length;M++)if(M===_)I[_]+=$[M];else if(S[M]!==$[M])throw new Error("non concat dimensions must match")}const O=I.length,T=new Array(x.length);let A=0;for(let D=0;D<T.length;++D)A+=x[D].dims[_],T[D]=A;let P="";P=x.length<5?l(T):d(T);const R=`
        ${a(x.length,O)}
        ${o(T)}
        ${P}
        float process(int indices[${O}]) {
          int textureIndex = getTextureWhereDataResides (indices[${_}]);

          if(textureIndex != 0) {
            indices[${_}] = indices[${_}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},w),{output:{dims:I,type:x[0].type,textureType:p.TextureType.unpacked},shaderSource:R})})(0,i,n,r.axis)})},l=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((n,r)=>`if(index<${n}) {return ${r};}
`).join("")}
    }`,d=e=>l(e),a=(e,n)=>{const r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${n}]) {`];for(let i=0;i<e;++i)i===0?r.push(`	if (textureIndex == ${i}) { return _X${i}(indices); }`):i===e-1?r.push(`	else { return _X${i}(indices); }`):r.push(`	else if (textureIndex == ${i}) { return _X${i}(indices); }`);return r.push("	}"),r.join(`
`)},o=e=>{const n=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<e.length;++r)r===0?n.push(`	if (index == ${r}) { return ${e[r]}; }`):r===e.length-1?n.push(`	else { return ${e[r]}; }`):n.push(`	else if (index == ${r}) { return ${e[r]}; }`);return n.push("	}"),n.join(`
`)};u.parseConcatAttributes=e=>(0,g.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const t=e=>{if(!e||e.length<1)throw new Error("too few inputs");const n=e[0].type,r=e[0].dims.length;if(n==="string")throw new Error("string tensor is not supported yet");for(const i of e){if(i.type!==n)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}}},7825:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createUnpackedGroupedConvProgramInfoLoader=void 0;const g=b(1315),p=b(6757),m=b(5639),s=b(9754),l=b(2150);u.createUnpackedGroupedConvProgramInfoLoader=(d,a,o)=>{const t=(e=a.length>2,n=o.cacheKey,{name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked]:[m.TextureType.unpacked,m.TextureType.unpacked],cacheHint:n});var e,n;return Object.assign(Object.assign({},t),{get:()=>((r,i,c,f)=>{const y=i.length>2?"value += getBias(output_channel);":"",w=i[0].dims.slice(),x=i[1].dims.slice(),_=x[0]/f.group;g.Logger.verbose("GroupedConv",`autpPad:${f.autoPad}, dilations:${f.dilations}, group:${f.group}, kernelShape:${f.kernelShape}, pads:${f.pads}, strides:${f.strides}`);const S=(0,s.calculateOutputShape)(w,x,f.dilations,f.pads,f.strides),I=(0,p.getGlsl)(r.session.backend.glContext.version),{activationFunction:O,applyActivation:T}=(0,l.getActivationSnippet)(f),A=`
  const ivec2 strides = ivec2(${f.strides[0]}, ${f.strides[1]});
  const ivec2 pads = ivec2(${f.pads[0]}, ${f.pads[1]});
  ${O}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${_};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${x[1]}; wInChannel++) {
      int input_channel = group_id * ${x[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${x[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${f.dilations[0]};

        if (xHeight < 0 || xHeight >= ${w[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${x[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${f.dilations[1]};
          if (xWidth < 0 || xWidth >= ${w[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${y}
    ${T}
    ${I.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},c),{output:{dims:S,type:i[0].type,textureType:m.TextureType.unpacked},shaderSource:A,hasMain:!0})})(d,a,t,o)})}},7708:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.conv2DPacked=u.conv2DPackedPointwise=void 0;const g=b(9754),p=b(5950),m=b(5632);u.conv2DPackedPointwise=(s,l,d)=>{const a=l[0].dims,o=l[1].dims,t=(0,g.calculateOutputShape)(a,o,d.dilations,d.pads,d.strides),e=s.reshapePacked(l[0],[a[1],a[2]*a[3]]),n=s.reshapePacked(l[1],[o[0],o[1]]),r=l.length>2?[n,e,l[2]]:[n,e],i=s.run((0,m.createPackedMatmulProgramInfoLoader)(s,r,d),r);return s.reshapePacked(i,t)},u.conv2DPacked=(s,l,d)=>{const a=l[0].dims,o=l[1].dims,t=(0,g.calculateOutputShape)(a,o,d.dilations,d.pads,d.strides),e=s.run((0,p.createPackedIm2ColProgramInfoLoader)(s,l[0],l[1],t,d),[l[0]]),n=s.reshapePacked(l[1],[o[0],o[1]*o[2]*o[3]]),r=l.length===3?[n,e,l[2]]:[n,e],i=s.run((0,m.createPackedMatmulProgramInfoLoader)(s,r,d),r);return s.reshapePacked(i,t)}},5042:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConvTransposeAttributes=u.convTranspose=void 0;const g=b(4910),p=b(6757),m=b(5639),s=b(2150),l=(n,r,i,c,f,y)=>(n-1)*r+i+(c-1)*f+1-y,d=(n,r,i,c,f)=>{const y=Math.floor(n/2);r==="SAME_UPPER"?(i[c]=y,i[f]=n-y):r==="SAME_LOWER"&&(i[c]=n-y,i[f]=y)};u.convTranspose=(n,r,i)=>(e(r,i),a(n,r,i));const a=(n,r,i)=>{const c=t(i,r);return[o(n,r,c)]},o=(n,r,i)=>n.run(((c,f,y)=>{const w=(x=f.length>2,_=y.cacheKey,{name:"ConvTranspose",inputNames:x?["X","W","B"]:["X","W"],inputTypes:x?[m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked]:[m.TextureType.unpacked,m.TextureType.unpacked],cacheHint:_});var x,_;return Object.assign(Object.assign({},w),{get:()=>((S,I,O,T)=>{const A=I.length>2?"getB(output_channel)":"0.0",P=I[0].dims,R=I[1].dims,D=R[1],$=R[0]/T.group,M=[I[0].dims[0],I[1].dims[1]*T.group,...T.outputShape],C=(0,p.getGlsl)(S.session.backend.glContext.version),{activationFunction:k,applyActivation:z}=(0,s.getActivationSnippet)(T),G=`
  const ivec2 strides = ivec2(${T.strides[0]}, ${T.strides[1]});
  const ivec2 pads = ivec2(${T.pads[0]}, ${T.pads[1]});
  ${k}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${D};
    int wOutChannel = output_channel - group_id * ${D};

    float value = ${A};
    for (int inChannelOffset = 0; inChannelOffset < ${$}; inChannelOffset++) {
      int input_channel = group_id * ${$} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${R[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${R[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${T.dilations[0]}, wHOff * ${T.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${P[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${P[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${z}
    ${C.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},O),{output:{dims:M,type:I[0].type,textureType:m.TextureType.unpacked},shaderSource:G,hasMain:!0})})(c,f,w,y)})})(n,r,i),r),t=(n,r)=>{const i=n.kernelShape.slice();if(n.kernelShape.length===0)for(let w=2;w<r[1].dims.length;++w)i.push(r[1].dims[w]);const c=n.pads.slice(),f=n.outputShape.slice();((w,x,_,S,I,O,T,A)=>{const P=w.length-2,R=A.length===0;for(let D=0;D<P;++D){const $=R?w[D+2]*O[D]:A[D],M=l(w[D+2],O[D],I[D],x[D],_[D],$);d(M,S,I,D,D+P),R&&A.push(O[D]*(w[D+2]-1)+T[D]+(x[D]-1)*_[D]+1-I[D]-I[D+P])}})(r[0].dims,i,n.dilations,n.autoPad,c,n.strides,n.outputPadding,f);const y=Object.assign({},n);return Object.assign(y,{kernelShape:i,pads:c,outputShape:f,cacheKey:n.cacheKey}),y};u.parseConvTransposeAttributes=n=>{const r=n.attributes,i=(0,s.parseInternalActivationAttributes)(r),c=r.getString("auto_pad","NOTSET"),f=r.getInts("dilations",[1,1]),y=r.getInt("group",1),w=r.getInts("kernel_shape",[]),x=r.getInts("output_padding",[0,0]),_=r.getInts("output_shape",[]),S=r.getInts("pads",[0,0,0,0]),I=r.getInts("strides",[1,1]);return(0,g.createAttributeWithCacheKey)(Object.assign({autoPad:c,dilations:f,group:y,kernelShape:w,outputPadding:x,outputShape:_,pads:S,strides:I},i))};const e=(n,r)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(n[0].dims[1]!==n[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const i=n[1].dims[1]*r.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==i))throw new Error("invalid bias");const c=n[0].dims.length-2;if(r.dilations.length!==c)throw new Error(`dilations should be ${c}D`);if(r.strides.length!==c)throw new Error(`strides should be ${c}D`);if(r.pads.length!==2*c)throw new Error(`pads should be ${2*c}D`);if(r.outputPadding.length!==c)throw new Error(`output_padding should be ${c}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(r.outputShape.length!==0&&r.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseConvAttributes=u.conv=u.calculateOutputShape=void 0;const g=b(4910),p=b(7273),m=b(7825),s=b(7708),l=b(3281),d=b(2150),a=b(1625),o=b(8276);u.calculateOutputShape=(c,f,y,w,x)=>{const _=c[0],S=c.slice(2),I=S.length,O=f[0],T=f.slice(2).map((P,R)=>P+(P-1)*(y[R]-1)),A=S.map((P,R)=>P+w[R]+w[R+I]).map((P,R)=>Math.floor((P-T[R]+x[R])/x[R]));return[_,O].concat(...A)},u.conv=(c,f,y)=>(i(f,y),t(c,f,y));const t=(c,f,y)=>{const w=r(y,f),x=c.session.pack,_=w.kernelShape[0]===1&&w.kernelShape[1]===1;return w.group>1?[c.run((0,m.createUnpackedGroupedConvProgramInfoLoader)(c,f,w),f)]:_&&x?[e(c,f,w)]:x&&f[0].dims.length===4&&f[0].dims[0]===1&&!_?[(0,s.conv2DPacked)(c,f,w)]:[n(c,f,w)]},e=(c,f,y)=>{const w=f[0].dims,x=f[1].dims,_=(0,u.calculateOutputShape)(w,x,y.dilations,y.pads,y.strides),S=c.reshapeUnpacked(f[0],[w[1],w[2]*w[3]]),I=c.reshapeUnpacked(f[1],[x[0],x[1]]),O=f.length>2?[I,S,f[2]]:[I,S],T=c.run((0,o.createMatmulProgramInfoLoader)(O,y),O);return c.reshapeUnpacked(T,_)},n=(c,f,y)=>{const w=f[0].dims,x=f[1].dims,_=(0,u.calculateOutputShape)(w,x,y.dilations,y.pads,y.strides),S=c.run((0,a.createIm2ColProgramInfoLoader)(c,f[0],f[1],_,y),[f[0]]),I=f.length===3?[S,f[1],f[2]]:[S,f[1]];return c.run((0,l.createDotProductProgramInfoLoader)(c,f,_,y),I)},r=(c,f)=>{const y=c.kernelShape.slice();if(c.kernelShape.length===0)for(let _=2;_<f[1].dims.length;++_)y.push(f[1].dims[_]);const w=c.pads.slice();p.PoolConvUtil.adjustPadsBasedOnAutoPad(f[0].dims,c.strides,c.dilations,y,w,c.autoPad);const x=Object.assign({},c);return Object.assign(x,{kernelShape:y,pads:w,cacheKey:c.cacheKey}),x};u.parseConvAttributes=c=>{const f=c.attributes,y=(0,d.parseInternalActivationAttributes)(f),w=f.getString("auto_pad","NOTSET"),x=f.getInts("dilations",[1,1]),_=f.getInt("group",1),S=f.getInts("kernel_shape",[]),I=f.getInts("pads",[0,0,0,0]),O=f.getInts("strides",[1,1]);return(0,g.createAttributeWithCacheKey)(Object.assign({autoPad:w,dilations:x,group:_,kernelShape:S,pads:I,strides:O},y))};const i=(c,f)=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(c[0].dims.length!==4||c[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(c[0].dims[1]!==c[1].dims[1]*f.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(c.length===3&&(c[2].dims.length!==1||c[1].dims[0]!==c[2].dims[0]))throw new Error("invalid bias");const y=c[0].dims.length-2;if(f.dilations.length!==y)throw new Error(`dilations should be ${y}D`);if(f.strides.length!==y)throw new Error(`strides should be ${y}D`);if(f.pads.length!==2*y)throw new Error(`pads should be ${2*y}D`);if(f.kernelShape.length!==0&&f.kernelShape.length!==c[1].dims.length-2)throw new Error("invalid kernel shape");if(c[0].type!=="float32"||c[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(c.length===3&&c[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseDepthToSpaceAttributes=u.depthToSpace=void 0;const g=b(5707);u.depthToSpace=(m,s,l)=>{p(s);const d=l.blocksize,a=d*d,o=l.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],t=l.mode==="DCR"?[s[0].dims[0],d,d,s[0].dims[1]/a,s[0].dims[2],s[0].dims[3]]:[s[0].dims[0],s[0].dims[1]/a,d,d,s[0].dims[2],s[0].dims[3]],e=m.reshapeUnpacked(s[0],t),n={perm:o,cacheKey:`${o}`},[r]=(0,g.transpose)(m,[e],n),i=[s[0].dims[0],s[0].dims[1]/a,s[0].dims[2]*d,s[0].dims[3]*d];return[m.reshapeUnpacked(r,i)]},u.parseDepthToSpaceAttributes=m=>{const s=m.attributes.getInt("blocksize");if(s<1)throw new Error(`blocksize must be >= 1, but got : ${s} for DepthToSpace`);const l=m.attributes.getString("mode","DCR");if(l!=="DCR"&&l!=="CRD")throw new Error(`unrecognized mode: ${l} for DepthToSpace`);return{mode:l,blocksize:s}};const p=m=>{if(m.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${m.length}`);if(m[0].type==="string"||m[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createDotProductProgramInfoLoader=void 0;const g=b(7273),p=b(6757),m=b(5639),s=b(2150),l=b(1625);u.createDotProductProgramInfoLoader=(d,a,o,t)=>{const e=((n,r)=>({name:"ConvDotProduct",inputNames:n?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:n?[m.TextureType.unpacked,m.TextureType.packedLastDimension,m.TextureType.unpacked]:[m.TextureType.unpacked,m.TextureType.packedLastDimension],cacheKey:r.activationCacheKey}))(a.length>2,t);return Object.assign(Object.assign({},e),{get:()=>((n,r,i,c,f)=>{const y=i[0].dims,w=i[1].dims,x=[w[0],Math.ceil(y[1]*w[2]*w[3]/4)],_=(0,l.calculateIm2ColDims)(y,w,c),[S,I]=n.calculateTextureWidthAndHeight(x,m.TextureType.packedLastDimension),O=g.ShapeUtil.computeStrides(_),[T,A]=n.calculateTextureWidthAndHeight(_,m.TextureType.packedLastDimension),P=c.length,R=i.length<3?"0.0":"_B(b)",D=Math.ceil(y[1]*w[2]*w[3]/4),{activationFunction:$,applyActivation:M}=(0,s.getActivationSnippet)(f),C=(0,p.getGlsl)(n.session.backend.glContext.version),k=`
${$}
float process(int indices[${P}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${O[0]} + im2col[1] * ${O[1]} + im2col[2] * ${O[2]};
  int kernelOffset = indices[1] * ${x[1]};
  float value = ${R};
  for (int i = 0; i < ${D}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${T}, ${A});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${S}, ${I});
    value += dot(${C.texture2D}(Im2Col, im2colCoords), ${C.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${M}
  return value;
}`;return Object.assign(Object.assign({},r),{output:{dims:c,type:i[0].type,textureType:m.TextureType.unpacked},shaderSource:k})})(d,e,a,o,t)})}},4125:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseFlattenAttributes=u.flatten=void 0;const g=b(7273);u.flatten=(m,s,l)=>{p(s,l);const d=g.ShapeUtil.flattenShape(s[0].dims,l);return[m.reshapeUnpacked(s[0],d)]},u.parseFlattenAttributes=m=>m.attributes.getInt("axis",1);const p=(m,s)=>{if(!m||m.length!==1)throw new Error("Flatten requires 1 input.");const l=m[0].dims.length;if(l===0)throw new Error("scalar tensor is not supported.");if(s<-l||s>l)throw new Error("Invalid axis");if(m[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInternalActivationAttributes=u.getActivationSnippet=void 0;const g=b(7273),p=b(9087);u.getActivationSnippet=function(m){let s;switch(m.activation){case"Relu":s=(0,p.glslRelu)();break;case"Sigmoid":s=(0,p.glslSigmoid)();break;case"Clip":s=(0,p.glslClip)(m.clipMin,m.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const l=s.name;return{activationFunction:s.body,applyActivation:`value = ${l}_(value);`}},u.parseInternalActivationAttributes=m=>{const s=m.getString("activation","");if(s==="Clip"){const[l,d]=m.getFloats("activation_params",[g.MIN_CLIP,g.MAX_CLIP]);return{activation:s,clipMax:d,clipMin:l,activationCacheKey:`${s}:${l},${d}`}}return{activation:s,activationCacheKey:s}}},6149:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGatherAttributes=u.gather=void 0;const g=b(4910),p=b(6145),m=b(7273),s=b(5639);u.gather=(o,t,e)=>(a(t,e.axis),[o.run(d(o,t,e),t)]),u.parseGatherAttributes=o=>(0,g.createAttributeWithCacheKey)({axis:o.attributes.getInt("axis",0)});const l={name:"Gather",inputNames:["A","B"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked]},d=(o,t,e)=>{const n=Object.assign(Object.assign({},l),{cacheHint:e.cacheKey});return Object.assign(Object.assign({},n),{get:()=>((r,i,c,f)=>{const y=c[0].dims.slice(),w=c[1].dims.slice(),x=new Array(y.length+w.length-1);f=m.ShapeUtil.normalizeAxis(f,y.length);const _=[];for(let I=0;I<x.length;I++)I<f?(x[I]=y[I],_.push(`inputIdx[${I}] = outputIdx[${I}];`)):I<f+w.length?(x[I]=w[I-f],_.push(`indexDataIdx[${I-f}] = outputIdx[${I}];`)):(x[I]=y[I-w.length+1],_.push(`inputIdx[${I-w.length+1}] = outputIdx[${I}];`));const S=`
      float process(int outputIdx[${x.length||1}]) {
        int inputIdx[${y.length}];
        int indexDataIdx[${w.length||1}];
        indexDataIdx[0] = 0;
        ${_.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${f}] = idx < 0 ? idx + ${y[f]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},i),{output:{dims:x,type:c[0].type,textureType:s.TextureType.unpacked},shaderSource:S})})(0,n,t,e.axis)})},a=(o,t)=>{if(!o||o.length!==2)throw new Error("Gather requires 2 inputs.");const e=o[0].dims.length;if(e<1)throw new Error("Invalid input shape.");if(t<-e||t>e-1)throw new Error("Invalid axis.");if(p.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invaid input type.");if(o[1].type!=="int32"&&o[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGemmAttributesV11=u.parseGemmAttributesV7=u.gemm=void 0;const g=b(4910),p=b(7273),m=b(5639);u.gemm=(o,t,e)=>(a(t,e),[o.run(l(t,e),t)]);const s=(o,t)=>{const e=o.attributes.getInt("transA",0)!==0,n=o.attributes.getInt("transB",0)!==0,r=o.attributes.getFloat("alpha",1),i=o.attributes.getFloat("beta",1);return(0,g.createAttributeWithCacheKey)({transA:e,transB:n,alpha:r,beta:i,isOptionalC:t})};u.parseGemmAttributesV7=o=>s(o,!1),u.parseGemmAttributesV11=o=>s(o,!0);const l=(o,t)=>{const e={name:"Gemm",inputNames:o.length===3?["A","B","C"]:["A","B"],inputTypes:o.length===3?[m.TextureType.unpacked,m.TextureType.unpacked,m.TextureType.unpacked]:[m.TextureType.unpacked,m.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},e),{get:()=>d(e,o,t)})},d=(o,t,e)=>{const n=t[0].dims.slice(),r=t[1].dims.slice(),[i,c]=p.GemmUtil.getShapeOfGemmResult(n,e.transA,r,e.transB,t.length===3?t[2].dims:void 0),f=[i,c];if(!f)throw new Error("Can't use gemm on the given tensors");let y=n[n.length-1],w="";e.transA&&(y=n[0]),e.transA&&e.transB?w="value += _A_T(a) * _B_T(b);":e.transA&&!e.transB?w="value += _A_T(a) * _B(b);":!e.transA&&e.transB?w="value += _A(a) * _B_T(b);":e.transA||e.transB||(w="value += _A(a) * _B(b);");const x=f.length,_=`
      float process(int indices[${x}]) {
          int a[${x}];
          int b[${x}];
          ${t.length===3?`int c[${t[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${t.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${y}; ++k) {
              a[${x-1}] = k;
              b[${x-2}] = k;
              ${w}
          }

          value = value * alpha;
          ${t.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},o),{output:{dims:f,type:t[0].type,textureType:m.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:e.alpha},{name:"beta",type:"float",data:e.beta}],shaderSource:_})},a=(o,t)=>{if(!o)throw new Error("Input is missing");if(t.isOptionalC&&(o.length<2||o.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&o.length!==3)throw new Error("Gemm requires 3 inputs");if(o.length===3&&o[2].dims.length!==1&&o[2].dims.length!==2)throw new Error("Invalid input shape of C");if(o[0].type!=="float32"&&o[0].type!=="float64"||o[1].type!=="float32"&&o[1].type!=="float64"||o.length===3&&o[2].type!=="float32"&&o[2].type!=="float64")throw new Error("Invalid input type.");if(o[0].type!==o[1].type||o.length===3&&o[0].type!==o[2].type)throw new Error("Input types are mismatched")}},5950:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedIm2ColProgramInfoLoader=void 0;const g=b(6757),p=b(5639),m=b(5614);u.createPackedIm2ColProgramInfoLoader=(s,l,d,a,o)=>{const t=(e=o.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[p.TextureType.packed],cacheHint:e});var e;return Object.assign(Object.assign({},t),{get:()=>((n,r,i,c,f,y)=>{const w=i.dims,x=c.dims,_=f.length,S=[x[1]*x[2]*x[3],f[2]*f[3]],I=x[2]*x[3],O=(0,m.unpackFromChannel)(),T=(0,g.getGlsl)(n.session.backend.glContext.version);let A="";for(let R=0;R<=1;R++)for(let D=0;D<=1;D++)A+=`
            blockIndex = rc.x + ${D};
            pos = rc.y + ${R};

            if(blockIndex < ${S[1]} && pos < ${S[0]}) {
              offsetY = int(blockIndex / (${f[_-1]})) * ${y.strides[0]} -
                ${y.pads[0]};
              d0 = offsetY + ${y.dilations[0]} * (imod(pos, ${I}) / ${x[2]});

              if(d0 < ${w[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${f[_-1]}) * ${y.strides[1]} -
                  ${y.pads[1]};
                d1 = offsetX + ${y.dilations[1]} * imod(imod(pos, ${I}), ${x[2]});

                if(d1 < ${w[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${I}.);
                    innerDims = vec2(d0, d1);
                    result[${2*R+D}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const P=`
      ${O}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${A}
          ${T.output} = result;
      }
            `;return Object.assign(Object.assign({},r),{output:{dims:S,type:i.type,textureType:p.TextureType.packed},shaderSource:P,hasMain:!0})})(s,t,l,d,a,o)})}},1625:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.calculateIm2ColDims=u.createIm2ColProgramInfoLoader=void 0;const g=b(5639);u.createIm2ColProgramInfoLoader=(p,m,s,l,d)=>{const a=(o=d.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[g.TextureType.unpacked],cacheHint:o});var o;return Object.assign(Object.assign({},a),{get:()=>((t,e,n,r,i,c)=>{const f=n.dims,y=r.dims,w=i.length,x=(0,u.calculateIm2ColDims)(f,y,i,4),_=`
        const int XC = ${f[1]};
        const int XH = ${f[2]};
        const int XW = ${f[3]};
        const int KH = ${c.kernelShape[0]};
        const int KW = ${c.kernelShape[1]};
        const int dilationH = ${c.dilations[0]};
        const int dilationW = ${c.dilations[1]};
        const int strideH = ${c.strides[0]};
        const int strideW = ${c.strides[1]};
        const int padH = ${c.pads[0]};
        const int padW = ${c.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${w}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${f.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},e),{output:{dims:x,type:n.type,textureType:g.TextureType.packedLastDimension},shaderSource:_})})(0,a,m,s,l,d)})},u.calculateIm2ColDims=(p,m,s,l=4)=>[s[0],s[2],s[3],Math.ceil(p[1]*m[2]*m[3]/l)]},6981:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseImageScalerAttributes=u.imageScaler=void 0;const g=b(4910),p=b(5639);u.imageScaler=(a,o,t)=>(d(o),[a.run(s(a,o,t),o)]),u.parseImageScalerAttributes=a=>{const o=a.attributes.getFloat("scale"),t=a.attributes.getFloats("bias");return(0,g.createAttributeWithCacheKey)({scale:o,bias:t})};const m={name:"ImageScaler",inputNames:["X"],inputTypes:[p.TextureType.unpacked]},s=(a,o,t)=>{const e=Object.assign(Object.assign({},m),{cacheHint:t.cacheKey});return Object.assign(Object.assign({},e),{get:()=>((n,r,i,c)=>{const f=i[0].dims.slice(),y=f.length,w=`
      ${l(c.bias.length)}
      float process(int indices[${y}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},r),{output:{dims:f,type:i[0].type,textureType:p.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:c.bias.length,data:c.bias},{name:"scale",type:"float",data:c.scale}],shaderSource:w})})(0,e,o,t)})},l=a=>{const o=[`float getBias(float bias[${a}], int channel) {`];for(let t=0;t<a;++t)t===0?o.push(`	if (channel == ${t}) { return bias[${t}]; }`):t===a-1?o.push(`	else { return bias[${t}]; }`):o.push(`	else if (channel == ${t}) { return bias[${t}]; }`);return o.push("	}"),o.join(`
`)},d=a=>{if(!a||a.length!==1)throw new Error("ImageScaler requires 1 input.");if(a[0].dims.length!==4)throw new Error("Invalid input shape.");if(a[0].type!=="float32"&&a[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInstanceNormalizationAttributes=u.instanceNormalization=void 0;const g=b(6757),p=b(5639);u.instanceNormalization=(o,t,e)=>{a(t);const n=o.run(s(t[0]),t);return[o.run(d(o,t[0],e,n.dims),[t[0],n,t[1],t[2]])]},u.parseInstanceNormalizationAttributes=o=>o.attributes.getFloat("epsilon",1e-5);const m={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[p.TextureType.unpacked]},s=o=>Object.assign(Object.assign({},m),{get:()=>((t,e)=>{const n=e.dims.slice(),r=n[1],i=n[2]*n[3],c=[n[0],r],f=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${i});
        temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${i});

        return v;
      }`;return Object.assign(Object.assign({},t),{output:{dims:c,type:e.type,textureType:p.TextureType.packedLastDimension},shaderSource:f})})(m,o)}),l={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[p.TextureType.unpacked,p.TextureType.packedLastDimension,p.TextureType.unpacked,p.TextureType.unpacked]},d=(o,t,e,n)=>{const r=Object.assign(Object.assign({},l),{cacheHint:`${e}`});return Object.assign(Object.assign({},r),{get:()=>((i,c,f,y,w)=>{const x=(0,g.getGlsl)(i.session.backend.glContext.version),[_,S]=i.calculateTextureWidthAndHeight(w,p.TextureType.packedLastDimension),[I,O]=[_/4,S],T=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${I}, ${O});
        return ${x.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},c),{output:{dims:f.dims,type:f.type,textureType:p.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:y}],shaderSource:T})})(o,r,t,e,n)})},a=o=>{if(!o||o.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const t=o[0],e=o[1],n=o[2];if(t.dims.length<3||e.dims.length!==1||n.dims.length!==1)throw new Error("Invalid input shape.");if(e.dims[0]!==t.dims[1]||n.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if(t.type!=="float32"&&t.type!=="float64"||e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64")throw new Error("Invalid input type.");if(o[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createLrnProgramInfoLoader=u.parseLrnAttributes=u.lrn=void 0;const g=b(4910),p=b(5639);u.lrn=(d,a,o)=>(l(a),[d.run(s(a,o),a)]),u.parseLrnAttributes=d=>{const a=d.attributes.getFloat("alpha",1e-4),o=d.attributes.getFloat("beta",.75),t=d.attributes.getFloat("bias",1),e=d.attributes.getInt("size");return(0,g.createAttributeWithCacheKey)({alpha:a,beta:o,bias:t,size:e})};const m={name:"LRN",inputNames:["X"],inputTypes:[p.TextureType.unpacked]};function s(d,a){return Object.assign(Object.assign({},m),{cacheHint:a.cacheKey,get:()=>function(o,t){const e=o[0].dims[1],n=o[0].dims.length,r=-Math.floor((t.size-1)/2),i=Math.ceil((t.size-1)/2),c=`float(${t.alpha}) / float(${t.size})`,f=`
    float process(int indices[${n}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${r}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${e}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${t.bias}) + ${c} * square_sum, float(${t.beta}));
    }`;return Object.assign(Object.assign({},m),{cacheHint:t.cacheKey,output:{dims:o[0].dims,type:o[0].type,textureType:p.TextureType.unpacked},shaderSource:f})}(d,a)})}u.createLrnProgramInfoLoader=s;const l=d=>{if(!d||d.length!==1)throw new Error("LRN requires 1 input.");if(d[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(d[0].type!=="float32")throw new Error("input should be float type")}},5632:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackedMatmulProgramInfoLoader=void 0;const g=b(7273),p=b(6757),m=b(5639),s=b(432),l=b(2150),d=b(8276);u.createPackedMatmulProgramInfoLoader=(a,o,t)=>{const e=(n=o.length>2,r=t.activationCacheKey,{name:"MatMul (packed)",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[m.TextureType.packed,m.TextureType.packed,m.TextureType.packed]:[m.TextureType.packed,m.TextureType.packed],cacheHint:r});var n,r;return Object.assign(Object.assign({},e),{get:()=>((i,c,f,y)=>{const w=f.length>2,x=w?"value += getBiasForMatmul();":"",_=f[0].dims,S=f[1].dims,I=g.BroadcastUtil.calcShape(_,S,!0),O=!g.ShapeUtil.areEqual(f[0].dims,f[1].dims);if(!I)throw new Error("Can't use matmul on the given tensors");const T=_[_.length-1],A=Math.ceil(T/2),P=_.length,R=S.length,D=(0,p.getGlsl)(i.session.backend.glContext.version),$=(0,s.getCoordsDataType)(I.length),M=I.length,C=(0,s.getGlChannels)(),{activationFunction:k,applyActivation:z}=(0,l.getActivationSnippet)(y),G=w?`${(0,d.getBiasForMatmul)($,C,f[2].dims,I,!0)}`:"",Y=O?`${function(Q,ae,re,ne){let fe=[],ie=[];const me=re[0].dims,de=re[1].dims,be=me.length,le=de.length,we=ne.length,Ee=we-be,Ce=we-le;fe=me.map((xe,Te)=>`coords.${ae[Te+Ee]}`),fe[be-1]="i*2",fe.join(", "),ie=de.map((xe,Te)=>`coords.${ae[Te+Ce]}`),ie[le-2]="i*2",ie.join(", ");const ke=g.BroadcastUtil.getBroadcastDims(me,ne),Re=g.BroadcastUtil.getBroadcastDims(de,ne),Ne=ke.map(xe=>`coords.${ae[xe+Ee]} = 0;`).join(`
`),ye=Re.map(xe=>`coords.${ae[xe+Ce]} = 0;`).join(`
`),Pe=`int lastDim = coords.${ae[we-1]};
  coords.${ae[we-1]} = coords.${ae[we-2]};
  coords.${ae[we-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Q} coords = getOutputCoords();
  ${Pe}
  ${Ne}
  vec4 outputValue = getA(${fe});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Q} coords = getOutputCoords();
  ${Pe}
  ${ye}
  vec4 outputValue = getB(${ie});
  return outputValue;
}`}($,C,f,I)}`:"",K=O?"getAAtOutCoordsMatmul(i)":`getA(${function(Q,ae){let re="";for(let ne=0;ne<ae-2;ne++)re+=`rc.${Q[ne]}, `;return re+=`rc.${Q[ae-2]}, i*2`,re}(C,P)})`,ee=O?"getBAtOutCoordsMatmul(i)":`getB(${function(Q,ae){let re="";for(let ne=0;ne<ae-2;ne++)re+=`rc.${Q[ne]}, `;return re+=`i*2, rc.${Q[ae-1]}`,re}(C,R)})`,oe=`
            ${Y}
            ${G}
            ${k}
            void main() {
              ${O?"":`${$} rc =
          getOutputCoords(); int lastDim = rc.${C[M-1]}; rc.${C[M-1]} =
          rc.${C[M-2]}; rc.${C[M-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${A}; i++) {
                vec4 a = ${K};
                vec4 b = ${ee};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${x}
              ${z}
              ${D.output} = value;
            }`;return Object.assign(Object.assign({},c),{output:{dims:I,type:f[0].type,textureType:m.TextureType.packed},shaderSource:oe,hasMain:!0})})(a,e,o,t)})}},8276:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getBiasForMatmul=u.createMatmulProgramInfoLoader=u.parseMatMulAttributes=u.matMul=void 0;const g=b(7273),p=b(5639),m=b(432),s=b(2150),l=b(5632);u.matMul=(e,n,r)=>(o(n),e.session.pack?[e.run((0,l.createPackedMatmulProgramInfoLoader)(e,n,r),n)]:[e.run(a(n,r),n)]),u.parseMatMulAttributes=e=>(0,s.parseInternalActivationAttributes)(e.attributes);const d=(e,n)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[p.TextureType.unpacked,p.TextureType.unpacked,p.TextureType.unpacked]:[p.TextureType.unpacked,p.TextureType.unpacked],cacheHint:n});function a(e,n){const r=d(e.length>2,n.activationCacheKey);return Object.assign(Object.assign({},r),{get:()=>function(i,c,f){const y=c[0].dims,w=c[1].dims,x=g.BroadcastUtil.calcShape(y,w,!0);if(!x)throw new Error("Can't use matmul on the given tensors");const _=(0,m.getCoordsDataType)(x.length),S=(0,m.getGlChannels)(),{activationFunction:I,applyActivation:O}=(0,s.getActivationSnippet)(f),T=c.length>2,A=T?"value += getBiasForMatmul();":"",P=T?`${t(_,S,c[2].dims,x,!1)}`:"",R=x.length,D=y.length,$=w.length,M=`
    ${I}
    ${P}
    float process(int indices[${R}]) {
        int a[${D}];
        int b[${$}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${y[y.length-1]}; ++k) {
            a[${D-1}] = k;
            b[${$-2}] = k;
            value += _A(a) * _B(b);
        }
        ${A}
        ${O}
        return value;
    }`;return Object.assign(Object.assign({},i),{output:{dims:x,type:c[0].type,textureType:p.TextureType.unpacked},shaderSource:M})}(r,e,n)})}u.createMatmulProgramInfoLoader=a;const o=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function t(e,n,r,i,c){let f="";const y=r.length,w=i.length,x=w-y;f=w<2&&y>0?"coords":r.map((I,O)=>`coords.${n[O+x]}`).join(", ");const _=g.BroadcastUtil.getBroadcastDims(r,i).map(I=>`coords.${n[I+x]} = 0;`).join(`
`);let S="vec4(outputValue.xx, outputValue.yy)";return g.ShapeUtil.size(r)===1&&(S="vec4(outputValue.x)"),c?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${_}
  vec4 outputValue = getBias(${f});
  return ${S};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${_}
  return getBias(coords.x);
}`}u.getBiasForMatmul=t},9:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createPackProgramInfoLoader=void 0;const g=b(6757),p=b(5639),m=b(432),s=b(5614),l={name:"pack",inputNames:["A"],inputTypes:[p.TextureType.unpackedReversed]};u.createPackProgramInfoLoader=(d,a)=>Object.assign(Object.assign({},l),{get:()=>((o,t)=>{const e=(0,g.getGlsl)(o.session.backend.glContext.version),n=t.dims,r=n.length,i=t.dims.length,c=(0,m.getCoordsDataType)(i),f=(0,s.getChannels)("rc",i),y=(w=i,x=f,_=n[n.length-2],S=n[n.length-1],w===0||w===1?"":`
    int r = ${x[w-2]};
    int c = ${x[w-1]};
    int rp1 = ${x[w-2]} + 1;
    int cp1 = ${x[w-1]} + 1;
    bool rEdge = rp1 >= ${S};
    bool cEdge = cp1 >= ${_};
    `);var w,x,_,S;let I;I=r===0?[1,1]:r===1?[n[0],1]:[n[i-1],n[i-2]];const O=function(P,R,D){if(P===0)return"false";if(P===1)return`rc > ${R[0]}`;let $="";for(let M=P-2;M<P;M++)$+=`${D[M]} >= ${R[M-P+2]}`,M<P-1&&($+="||");return $}(i,I,f),T=function(P,R){const D=P.length;if(D===0)return"getA(), 0, 0, 0";if(D===1)return`getA(rc),
            rc + 1 >= ${P[0]} ? 0. : getA(rc + 1),
            0, 0`;let $="";if(D>2)for(let M=0;M<D-2;++M)$+=`${R[M]},`;return`getA(${$}r, c),
          rEdge ? 0. : getA(${$}rp1, c),
          cEdge ? 0. : getA(${$}r, cp1),
          rEdge || cEdge ? 0. : getA(${$}rp1, cp1)`}(n,f),A=`
        void main() {
          ${c} rc = getOutputCoords();

          if(${O}) {
            ${e.output} = vec4(0);
          } else {
            ${y}

            ${e.output} = vec4(${T});
          }
        }
      `;return Object.assign(Object.assign({},l),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:p.TextureType.packed},shaderSource:A})})(d,a)})},5614:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.unpackFromChannel=u.getChannels=u.getVecChannels=void 0;const g=b(432);function p(m,s){return(0,g.getGlChannels)(s).map(l=>`${m}.${l}`)}u.getVecChannels=p,u.getChannels=function(m,s){return s===1?[m]:p(m,s)},u.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parsePadAttributesV11=u.padV11=u.parsePadAttributesV2=u.padV2=void 0;const g=b(4910),p=b(7273),m=b(6757),s=b(5639),l={name:"Pad",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};u.padV2=(c,f,y)=>(o(f),[c.run(Object.assign(Object.assign({},l),{cacheHint:y.cacheKey,get:()=>a(c,f[0],y)}),f)]),u.parsePadAttributesV2=c=>{const f=c.attributes.getString("mode","constant"),y=c.attributes.getFloat("value",0),w=c.attributes.getInts("pads");return(0,g.createAttributeWithCacheKey)({mode:f,value:y,pads:w})},u.padV11=(c,f,y)=>{t(f);const w=d(c,f,y);return(0,u.padV2)(c,[f[0]],w)},u.parsePadAttributesV11=c=>c.attributes.getString("mode","constant");const d=(c,f,y)=>{if(!c.session.isInitializer(f[1].dataId)||f.length>=3&&!c.session.isInitializer(f[2].dataId))throw new Error("dynamic pad attributes are not allowed");const w=Array.from(f[1].integerData),x=f.length>=3?f[2].floatData[0]:0;return(0,g.createAttributeWithCacheKey)({mode:y,pads:w,value:x})},a=(c,f,y)=>{const w=p.ShapeUtil.padShape(f.dims.slice(),y.pads),x=w.length,_=`
      ${e(c,f,y)}
      float process(int[${x}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[s.TextureType.unpacked],output:{dims:w,type:f.type,textureType:s.TextureType.unpacked},shaderSource:_}},o=c=>{if(!c||c.length!==1)throw new Error("Pad requires 1 input");if(c[0].type!=="float32"&&c[0].type!=="float64")throw new Error("Invalid input type.")},t=c=>{if(!c||c.length!==2&&c.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(c[1].type!=="int32")throw new Error("Invalid input type.");if(c.length>=3&&c[2].type==="string")throw new Error("Invalid input type.")},e=(c,f,y)=>{const w=(0,m.getGlsl)(c.session.backend.glContext.version),[x,_]=c.calculateTextureWidthAndHeight(f.dims,s.TextureType.unpacked),S=p.ShapeUtil.computeStrides(f.dims);switch(y.mode){case"constant":return n(w,f.dims,S,x,_,y.pads,y.value);case"reflect":return r(w,f.dims,S,x,_,y.pads);case"edge":return i(w,f.dims,S,x,_,y.pads);default:throw new Error("Invalid mode")}},n=(c,f,y,w,x,_,S)=>{const I=f.length;let O="";for(let T=I-1;T>=0;--T)O+=`
        k = m[${T}] - ${_[T]};
        if (k < 0)  return constant;
        if (k >= ${f[T]}) return constant;
        offset += k * ${y[T]};
        `;return`
      float padA(int m[${I}]) {
        const float constant = float(${S});
        int offset = 0;
        int k = 0;
        ${O}
        vec2 coords = offsetToCoords(offset, ${w}, ${x});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `},r=(c,f,y,w,x,_)=>{const S=f.length;let I="";for(let O=S-1;O>=0;--O)I+=`
        k = m[${O}] - ${_[O]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(f[O]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${f[O]}) { k = _2n_1 - k; }
        }
        offset += k * ${y[O]};
        `;return`
      float padA(int m[${S}]) {
        int offset = 0;
        int k = 0;
        ${I}
        vec2 coords = offsetToCoords(offset, ${w}, ${x});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `},i=(c,f,y,w,x,_)=>{const S=f.length;let I="";for(let O=S-1;O>=0;--O)I+=`
        k = m[${O}] - ${_[O]};
        if (k < 0)  k = 0;
        if (k >= ${f[O]}) k = ${f[O]-1};
        offset += k * ${y[O]};
      `;return`
      float padA(int m[${S}]) {
        int offset = 0;
        int k = 0;
        ${I}
        vec2 coords = offsetToCoords(offset, ${w}, ${x});
        float value = getColorAsFloat(${c.texture2D}(A, coords));
        return value;
      }
      `}},2834:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.globalMaxPool=u.parseMaxPoolAttributes=u.maxPool=u.parseGlobalAveragePoolAttributes=u.globalAveragePool=u.parseAveragePoolAttributes=u.averagePool=void 0;const g=b(4910),p=b(7273),m=b(5639);u.averagePool=(i,c,f)=>{t(c);const y={name:"AveragePool",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:f.cacheKey};return[i.run(Object.assign(Object.assign({},y),{get:()=>s(c,y,!1,f)}),c)]},u.parseAveragePoolAttributes=i=>{const c=i.attributes.getString("auto_pad","NOTSET"),f=i.attributes.getInt("ceil_mode",0),y=i.attributes.getInt("count_include_pad",0)!==0,w=i.attributes.getInts("kernel_shape"),x=i.attributes.getInts("strides",[]),_=i.attributes.getInts("pads",[]);if(f!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,g.createAttributeWithCacheKey)({autoPad:c,ceilMode:f,countIncludePad:y,kernelShape:w,strides:x,pads:_})};const s=(i,c,f,y)=>{const[w,x]=d(i,y,f),_=p.ShapeUtil.size(w.kernelShape);let S="";w.countIncludePad?S+=`value /= float(${_});`:S+=`value /= float(${_} - pad);`;const I=`
        ${e(i[0].dims,w,"value += _X(x);",S,"0.0")}
      `;return Object.assign(Object.assign({},c),{output:{dims:x,type:i[0].type,textureType:m.TextureType.unpacked},shaderSource:I})};u.globalAveragePool=(i,c,f)=>{t(c);const y={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:`${f.countIncludePad}`};return[i.run(Object.assign(Object.assign({},y),{get:()=>s(c,y,!0,f)}),c)]},u.parseGlobalAveragePoolAttributes=i=>{const c=i.attributes.getInt("count_include_pad",0)!==0;return(0,g.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:c,kernelShape:[],strides:[],pads:[]})},u.maxPool=(i,c,f)=>{t(c);const y={name:"MaxPool",inputNames:["X"],inputTypes:[m.TextureType.unpacked],cacheHint:f.cacheKey};return[i.run(Object.assign(Object.assign({},y),{get:()=>l(c,y,!1,f)}),c)]},u.parseMaxPoolAttributes=i=>{const c=i.attributes.getString("auto_pad","NOTSET"),f=i.attributes.getInt("ceil_mode",0),y=i.attributes.getInts("kernel_shape"),w=i.attributes.getInts("strides",[]),x=i.attributes.getInts("pads",[]),_=i.attributes.getInt("storage_order",0),S=i.attributes.getInts("dilations",[]);if(_!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(f!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,g.createAttributeWithCacheKey)({autoPad:c,ceilMode:f,countIncludePad:!1,kernelShape:y,strides:w,pads:x,storageOrder:_,dilations:S})};const l=(i,c,f,y)=>{const[w,x]=d(i,y,f),_=`
      ${e(i[0].dims,w,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},c),{output:{dims:x,type:i[0].type,textureType:m.TextureType.unpacked},shaderSource:_})},d=(i,c,f)=>{const y=i[0].dims.slice(),w=Object.hasOwnProperty.call(c,"dilations"),x=c.kernelShape.slice(),_=c.strides.slice(),S=w?c.dilations.slice():[],I=c.pads.slice();p.PoolConvUtil.adjustPoolAttributes(f,y,x,_,S,I);const O=p.PoolConvUtil.computePoolOutputShape(f,y,_,S,x,I,c.autoPad),T=Object.assign({},c);return w?Object.assign(T,{kernelShape:x,strides:_,pads:I,dilations:S,cacheKey:c.cacheKey}):Object.assign(T,{kernelShape:x,strides:_,pads:I,cacheKey:c.cacheKey}),[T,O]},a={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},o={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[m.TextureType.unpacked]};u.globalMaxPool=(i,c)=>(t(c),[i.run(Object.assign(Object.assign({},o),{get:()=>l(c,o,!0,a)}),c)]);const t=i=>{if(!i||i.length!==1)throw new Error("Pool ops requires 1 input.");if(i[0].type!=="float32"&&i[0].type!=="float64")throw new Error("Invalid input type.")},e=(i,c,f,y,w)=>{const x=i.length;if(c.kernelShape.length<=2){const _=c.kernelShape[c.kernelShape.length-1],S=c.strides[c.strides.length-1],I=c.pads[c.pads.length/2-1],O=c.pads[c.pads.length-1],T=i[x-1];let A="",P="",R="";if(A=I+O!==0?`
          for (int i = 0; i < ${_}; i++) {
            x[${x} - 1] = indices[${x} - 1] * ${S} - ${I} + i;
            if (x[${x} - 1] < 0 || x[${x} - 1] >= ${T}) {
              pad++;
              continue;
            }
            ${f}
          }`:`
          for (int i = 0; i < ${_}; i++) {
            x[${x} - 1] = indices[${x} - 1] * ${S} - ${I} + i;
            ${f}
          }`,c.kernelShape.length===2){const D=c.kernelShape[c.kernelShape.length-2],$=c.strides[c.strides.length-2],M=c.pads[c.pads.length/2-2],C=c.pads[c.pads.length-2],k=i[x-2];P=M+C!==0?`
            for (int j = 0; j < ${D}; j++) {
              x[${x} - 2] = indices[${x} - 2] * ${$} - ${M} + j;
              if (x[${x} - 2] < 0 || x[${x} - 2] >= ${k}) {
                pad+= ${_};
                continue;
              }
          `:`
            for (int j = 0; j < ${D}; j++) {
              x[${x} - 2] = indices[${x} - 2] * ${$} - ${M} + j;
            `,R=`
          }
        `}return`
        float process(int indices[${x}]) {
          int x[${x}];
          copyVec(indices, x);

          float value = ${w};
          int pad = 0;
          ${P}
          ${A}
          ${R}
          ${y}
          return value;
        }
      `}{const _=p.ShapeUtil.size(c.kernelShape),S=p.ShapeUtil.computeStrides(c.kernelShape),I=S.length,O=c.pads.length,T=r(I),A=n(i,"inputDims"),P=n(c.pads,"pads"),R=n(S,"kernelStrides"),D=n(c.strides,"strides");let $="";return $=c.pads.reduce((M,C)=>M+C)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${f}
          }`:`
          }
          ${f}
        `,`
        ${T}
        float process(int indices[${x}]) {
          int x[${x}];
          copyVec(indices, x);
          int offset[${I}];
          int pads[${O}];
          int inputDims[${x}];
          int kernelStrides[${I}];
          int strides[${I}];
          ${P}
          ${A}
          ${D}
          ${R}

          float value = ${w};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${_}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${x} - ${I}; j < ${x}; j++) {
              x[j] = indices[j] * strides[j - ${x} + ${I}]
                + offset[j - ${x} + ${I}] - pads[j - 2];
              ${$}
          }
          ${y}

          return value;
        }
      `}},n=(i,c)=>{let f="";for(let y=0;y<i.length;y++)f+=`
      ${c}[${y}] = ${i[y]};
    `;return f},r=i=>`
  void offsetToIndices(int offset, int[${i}] strides, out int[${i}] indices) {
    if (${i} == 0) {
      return;
    }
    for (int i = 0; i < ${i} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${i} - 1] = offset;
  }`},1010:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.reduceLogSumSquare=u.reduceLogSum=u.reduceProd=u.reduceMin=u.reduceMax=u.reduceMean=u.reduceSum=u.parseReduceAttributes=void 0;const g=b(4910),p=b(6145),m=b(7273),s=b(5639),l=(o,t,e,n,r)=>{a(t);const i={name:n,inputNames:["A"],inputTypes:[s.TextureType.unpacked]};return[o.run(Object.assign(Object.assign({},i),{cacheHint:e.cacheKey,get:()=>d(o,t,e,n,r,i)}),t)]};u.parseReduceAttributes=o=>{const t=o.attributes.getInts("axes",[]),e=o.attributes.getInt("keepdims",1)===1;return(0,g.createAttributeWithCacheKey)({axes:t,keepDims:e})};const d=(o,t,e,n,r,i)=>{const c=[],f=t[0].dims.length||1,y=[],w=m.ShapeUtil.normalizeAxes(e.axes,t[0].dims.length),x=r(t,w);let _=x[1];for(let I=0;I<t[0].dims.length;I++)w.indexOf(I)>=0||w.length===0?(e.keepDims&&c.push(1),_=`
          for(int j${I} = 0; j${I} < ${t[0].dims[I]}; j${I}++) {
            inputIdx[${I}] = j${I};
            ${_}
          }`):(y.push(`inputIdx[${I}] = outputIdx[${c.length}];`),c.push(t[0].dims[I]));const S=`
      float process(int outputIdx[${c.length||1}]) {
        float value;                 // final result
        int inputIdx[${f}];      // addressing input data
        ${y.join(`
`)}
        ${x[0]}       // init ops for reduce max/min
        ${_}
        ${x[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},i),{output:{dims:c,type:t[0].type,textureType:s.TextureType.unpacked},shaderSource:S})},a=o=>{if(!o||o.length!==1)throw new Error("Reduce op requires 1 input.");if(p.NUMBER_TYPES.indexOf(o[0].type)===-1)throw new Error("Invalid input type.")};u.reduceSum=(o,t,e)=>l(o,t,e,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),u.reduceMean=(o,t,e)=>l(o,t,e,"ReduceMean",(n,r)=>{let i=1;for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&(i*=n[0].dims[c]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${i}.;`]}),u.reduceMax=(o,t,e)=>l(o,t,e,"ReduceMax",(n,r)=>{const i=[];for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&i.push(`inputIdx[${c}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),u.reduceMin=(o,t,e)=>l(o,t,e,"ReduceMin",(n,r)=>{const i=[];for(let c=0;c<n[0].dims.length;c++)(r.indexOf(c)>=0||r.length===0)&&i.push(`inputIdx[${c}] = 0;`);return[`${i.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),u.reduceProd=(o,t,e)=>l(o,t,e,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),u.reduceLogSum=(o,t,e)=>l(o,t,e,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),u.reduceLogSumSquare=(o,t,e)=>l(o,t,e,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.isReshapeCheap=u.processDims3D=u.createPackedReshape3DProgramInfoLoader=void 0;const g=b(7273),p=b(6757),m=b(5639),s=b(5614);u.createPackedReshape3DProgramInfoLoader=(l,d,a)=>{const o=(t=>({name:"Reshape (packed)",inputTypes:[m.TextureType.packed],inputNames:["A"],cacheHint:`${t}`}))(a);return Object.assign(Object.assign({},o),{get:()=>((t,e,n,r)=>{const i=e.dims,c=r;let f="";for(let x=0;x<4;x++){let _="";switch(x){case 0:_="outputCoords = rc;";break;case 1:_="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:_="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:_="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}f+=`
        ${_}
        ${x>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${x}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${x>0?"}":""}
      `}const y=(0,p.getGlsl)(t.session.backend.glContext.version),w=`
      ${function(x){const _=g.ShapeUtil.computeStrides(x),S=["b","r","c"],I="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${_.map((O,T)=>`int ${S[T]} = ${I} / ${O}; ${T===_.length-1?`int ${S[T+1]} = ${I} - ${S[T]} * ${O}`:`index -= ${S[T]} * ${O}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(i)}
      ${function(x){const _=g.ShapeUtil.computeStrides(x);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${_[0]} + coords.z * ${_[1]} + coords.y;
  }
`}(c)}
      ${(0,s.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${f}
        ${y.output} = result;
      }
    `;return Object.assign(Object.assign({},n),{output:{dims:c,type:e.type,textureType:m.TextureType.packed},shaderSource:w,hasMain:!0})})(l,d,o,a)})},u.processDims3D=function(l){if(l.length===0)return[1,1,1];let d=1;for(let a=0;a<l.length-2;++a)d*=l[a];return[d,l.length>1?l[l.length-2]:1,l[l.length-1]]},u.isReshapeCheap=function(l,d){let a=!1;return a=l.length===0||d.length===0||(l.length<2||d.length<2?l[l.length-1]===d[d.length-1]:l[l.length-1]===d[d.length-1]&&l[l.length-2]===d[d.length-2]),a}},8126:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.reshape=void 0;const g=b(7273);u.reshape=(p,m)=>{const s=g.ShapeUtil.calculateReshapedDims(m[0].dims,m[1].integerData);return p.session.pack?[p.reshapePacked(m[0],s)]:[p.reshapeUnpacked(m[0],s)]}},2801:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseResizeAttributesV11=u.parseResizeAttributesV10=u.resize=void 0;const g=b(6757),p=b(5639),m=b(432),s=b(5614),l=b(3980),d={name:"Resize",inputNames:["A"],inputTypes:[p.TextureType.packed]};u.resize=(n,r,i)=>((0,l.validateInputs)(r,i),[n.run(Object.assign(Object.assign({},d),{cacheHint:i.cacheKey,get:()=>a(n,r,i)}),r)]),u.parseResizeAttributesV10=n=>(0,l.parseUpsampleAttributes)(n,10),u.parseResizeAttributesV11=n=>(0,l.parseUpsampleAttributes)(n,11);const a=(n,r,i)=>{const c=(0,g.getGlsl)(n.session.backend.glContext.version),[f,y]=o(r,i);if(f.every($=>$===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},d),{output:{dims:y,type:r[0].type,textureType:p.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${c.texture2D}(X, TexCoords);
                    ${c.output} = v;
                }`});const w=y.length;if(w<2)throw new Error(`output dimension should be at least 2, but got ${w}`);const x=y[w-2],_=y[w-1],S=r[0].dims;if(w!==S.length)throw new Error(`output dimension should match input ${S.length}, but got ${w}`);const I=S[w-2],O=S[w-1],T=f[w-2],A=f[w-1];let P="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":P=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":P=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":P=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${_}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${x}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${_}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${x}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":P=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${_}.0 - 1.0, ${x}.0 - 1.0, ${_}.0 - 1.0,
                            ${x}.0 - 1.0);
                        vec4 original = vec4(${O}.0 - 1.0, ${I}.0 - 1.0, ${O}.0 - 1.0,
                            ${I}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}const R=(0,m.getCoordsDataType)(w),D=`
            const vec2 inputWH = vec2(${I}.0, ${O}.0);
            const vec4 scaleWHWH = vec4(float(${T}), float(${A}), float(${T}), float(${A}));
            ${(0,s.unpackFromChannel)()}
            ${P}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${R} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${x-1};
                bool hasNextCol = rc.z < ${_-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${c.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},d),{output:{dims:y,type:r[0].type,textureType:p.TextureType.packed},hasMain:!0,shaderSource:D})},o=(n,r)=>{const i=n[0].dims;let c,f=r.scales;if(f.length===0){const w=n[r.scalesInputIdx];if(w&&w.size!==0){if(n[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");f=t(w,r.mode,r.isResize)}else{const x=n[r.sizesInputIdx];if(!x||x.size===0)throw new Error("Either scales or sizes MUST be provided as input.");c=Array.from(x.integerData),f=e(c,i,r.mode,r.isResize)}}else if(n[r.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const y=c||i.map((w,x)=>Math.floor(w*f[x]));return[f,y]},t=(n,r,i)=>{const c=Array.from(n.floatData);return(0,l.scalesValidation)(c,r,i),c},e=(n,r,i,c)=>{const f=r.length,y=new Array(f);for(let w=0,x=f;w<x;w++)if(r[w]===0){if(n[w]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");y[w]=1}else y[w]=n[w]/r[w];return(0,l.scalesValidation)(y,i,c),y}},565:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.shape=void 0;const g=b(9240);u.shape=(m,s)=>(p(s),[new g.Tensor([s[0].dims.length],"int32",void 0,void 0,new Int32Array(s[0].dims))]);const p=m=>{if(!m||m.length!==1)throw new Error("Shape requires 1 input.")}},2444:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sliceV10=u.parseSliceAttributes=u.slice=void 0;const g=b(4910),p=b(6145),m=b(7273),s=b(5639),l={name:"Slice",inputNames:["A"],inputTypes:[s.TextureType.unpacked]};u.slice=(e,n,r)=>(a(n),[e.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>d(e,n[0],r)}),n)]),u.parseSliceAttributes=e=>{const n=e.attributes.getInts("starts"),r=e.attributes.getInts("ends"),i=e.attributes.getInts("axes",[]);return(0,g.createAttributeWithCacheKey)({starts:n,ends:r,axes:i})};const d=(e,n,r)=>{const i=r.axes.length===0?n.dims.slice(0).map((S,I)=>I):r.axes,c=m.ShapeUtil.normalizeAxes(i,n.dims.length),f=r.starts.map((S,I)=>S>n.dims[c[I]]-1?n.dims[c[I]]:m.ShapeUtil.normalizeAxis(S,n.dims[c[I]])),y=r.ends.map((S,I)=>S>n.dims[c[I]]-1?n.dims[c[I]]:m.ShapeUtil.normalizeAxis(S,n.dims[c[I]])),w=n.dims.slice(),x=[];for(let S=0;S<c.length;S++)w[c[S]]=y[S]-f[S],f[S]>0&&x.push(`outputIdx[${c[S]}] += ${f[S]};`);const _=`
      float process(int outputIdx[${w.length}]) {
        ${x.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},l),{output:{dims:w,type:n.type,textureType:s.TextureType.unpacked},shaderSource:_})},a=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(p.NUMBER_TYPES.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")};u.sliceV10=(e,n)=>{t(n);const r=o(e,n);return[e.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>d(e,n[0],r)}),[n[0]])]};const o=(e,n)=>{if(!e.session.isInitializer(n[1].dataId)||!e.session.isInitializer(n[2].dataId)||n.length>=4&&!e.session.isInitializer(n[3].dataId)||n.length>=5&&!e.session.isInitializer(n[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(n.length>=5&&n[4].integerData.some(f=>f!==1))throw new Error("currently non-1 steps is not supported for Slice");const r=Array.from(n[1].integerData),i=Array.from(n[2].integerData),c=n.length>=4?Array.from(n[3].integerData):[];return{starts:r,ends:i,axes:c,cacheKey:`${c};${r};${i}`}},t=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.softmaxV13=u.parseSoftmaxAttributesV13=u.parseSoftmaxAttributes=u.softmax=void 0;const g=b(4910),p=b(7273),m=b(6757),s=b(5639),l=b(5707),d={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[s.TextureType.unpacked]},a={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked]},o={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[s.TextureType.unpacked,s.TextureType.unpacked,s.TextureType.unpacked]};u.softmax=(c,f,y)=>{i(f);const w=f[0].dims.slice(),x=p.ShapeUtil.normalizeAxis(y.axis,w.length),_=p.ShapeUtil.sizeToDimension(w,x),S=p.ShapeUtil.sizeFromDimension(w,x);return t(c,f,y,_,S)},u.parseSoftmaxAttributes=c=>(0,g.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis",1)}),u.parseSoftmaxAttributesV13=c=>(0,g.createAttributeWithCacheKey)({axis:c.attributes.getInt("axis",-1)}),u.softmaxV13=(c,f,y)=>{i(f);const w=f[0].dims.slice(),x=p.ShapeUtil.normalizeAxis(y.axis,w.length),_=w.length,S=x!==_-1,I=[];let O,T=[],A=[];S&&(T=Array.from({length:_}).map(($,M)=>M),T[x]=_-1,T[_-1]=x,T.map($=>I.push(w[$])),O=(0,g.createAttributeWithCacheKey)({perm:T}),A=(0,l.transpose)(c,f,O));const P=S?p.ShapeUtil.sizeToDimension(I,_-1):p.ShapeUtil.sizeToDimension(w,_-1),R=S?p.ShapeUtil.sizeFromDimension(I,_-1):p.ShapeUtil.sizeFromDimension(w,_-1),D=t(c,S?A:f,y,P,R);return S?(0,l.transpose)(c,D,O):D};const t=(c,f,y,w,x)=>{const _=e(c,f[0],w,x,[w]),S=c.run(Object.assign(Object.assign({},d),{cacheHint:y.cacheKey,get:()=>_}),f),I=n(c,f[0],w,x,_.output.dims,[w]),O=c.run(Object.assign(Object.assign({},a),{cacheHint:y.cacheKey,get:()=>I}),[f[0],S]),T=r(c,f[0],w,x,_.output.dims,I.output.dims);return[c.run(Object.assign(Object.assign({},o),{cacheHint:y.cacheKey,get:()=>T}),[f[0],S,O])]},e=(c,f,y,w,x)=>{const[_,S]=c.calculateTextureWidthAndHeight(f.dims,s.TextureType.unpacked),I=x.length;if(y<1||w<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(x.length!==1)throw new Error("Dimensionality of the output should be 1");if(x[0]!==y)throw new Error("Shape of the output should be equal to logical row count");const O=(0,m.getGlsl)(c.session.backend.glContext.version),T=`
      float process(int[${I}] indices) {
        int logical_row_start_offset = indices[0] * ${w};

        float max = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset, ${_},
        ${S} )));
        for(int i=1; i<${w}; ++i)
        {
          float current = getColorAsFloat(${O.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${_}, ${S})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},d),{output:{dims:x,type:f.type,textureType:s.TextureType.unpacked},shaderSource:T})},n=(c,f,y,w,x,_)=>{const[S,I]=c.calculateTextureWidthAndHeight(f.dims,s.TextureType.unpacked),O=_.length;if(y<1||w<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(_.length!==1)throw new Error("Dimensionality of the output should be 1");if(_[0]!==y)throw new Error("Shape of the output should be equal to logical row count");if(x.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(x[0]!==y)throw new Error("Shape of the intermediate results should be equal to logical row count");const T=`
      float process(int[${O}] indices) {
        int logical_row_start_offset = indices[0] * ${w};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${w}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,m.getGlsl)(c.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${S}, ${I}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},a),{output:{dims:_,type:f.type,textureType:s.TextureType.unpacked},shaderSource:T})},r=(c,f,y,w,x,_)=>{const[S,I]=c.calculateTextureWidthAndHeight(f.dims,s.TextureType.unpacked),O=f.dims.length;if(y<1||w<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(x.length!==1||_.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(x[0]!==y||_[0]!==y)throw new Error("Shape of the intermediate results should be equal to logical row count");const T=`
      float process(int[${O}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${S}, ${I});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${w};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},o),{output:{dims:f.dims,type:f.type,textureType:s.TextureType.unpacked},shaderSource:T})},i=c=>{if(!c||c.length!==1)throw new Error("Softmax requires 1 input.");if(c[0].type!=="float32"&&c[0].type!=="float64")throw new Error("Invalid input type")}},564:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseSplitAttributes=u.split=void 0;const g=b(4910),p=b(7273),m=b(5639),s={name:"Split",inputNames:["A"],inputTypes:[m.TextureType.unpacked]};u.split=(o,t,e)=>{a(t);const n=p.ShapeUtil.normalizeAxis(e.axis,t[0].dims.length),r=l(o,t,n,e),i=[];for(let c=0;c<r;++c)i.push(o.run(Object.assign(Object.assign({},s),{cacheHint:`${e.cacheKey};${c}`,get:()=>d(o,t[0],e,n,c)}),t));return i},u.parseSplitAttributes=o=>{const t=o.attributes.getInt("axis",0),e=o.attributes.getInts("split",[]),n=o.outputs.length;return(0,g.createAttributeWithCacheKey)({axis:t,split:e,numOutputs:n})};const l=(o,t,e,n)=>{const[,r]=p.SplitUtil.splitShape(t[0].dims,e,n.split,n.numOutputs);return r.length},d=(o,t,e,n,r)=>{const[i,c]=p.SplitUtil.splitShape(t.dims,n,e.split,e.numOutputs),f=c[r],y=i[r],w=`
      float process(int indices[${y.length}]) {
        indices[${n}] += ${f};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},s),{cacheHint:`${e.cacheKey}:${r}`,output:{dims:y,type:t.type,textureType:m.TextureType.unpacked},shaderSource:w})},a=o=>{if(!o||o.length!==1)throw new Error("Split requires one input.");if(o[0].type!=="int8"&&o[0].type!=="uint8"&&o[0].type!=="int16"&&o[0].type!=="uint16"&&o[0].type!=="int32"&&o[0].type!=="uint32"&&o[0].type!=="float32"&&o[0].type!=="float64"&&o[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseSqueezeAttributes=u.squeezeV13=u.squeeze=void 0;const g=b(7273);u.squeeze=(s,l,d)=>{p(l);const a=g.ShapeUtil.squeezeShape(l[0].dims,d);return[s.reshapeUnpacked(l[0],a)]},u.squeezeV13=(s,l)=>(m(l),(0,u.squeeze)(s,[l[0]],Array.from(l[1].integerData))),u.parseSqueezeAttributes=s=>s.attributes.getInts("axes");const p=s=>{if(!s||s.length!==1)throw new Error("Squeeze requires 1 input.");if(s[0].type==="string")throw new Error("invalid input tensor types.")},m=s=>{if(!s||s.length!==2)throw new Error("Squeeze requires 2 inputs.");if(s[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sum=void 0;const g=b(6757),p=b(5639);u.sum=(l,d)=>{s(d);const a={name:"Sum",inputNames:d.map((o,t)=>`X${t}`),inputTypes:new Array(d.length).fill(p.TextureType.unpacked)};return[l.run(Object.assign(Object.assign({},a),{get:()=>m(l,d,a)}),d)]};const m=(l,d,a)=>{const o=(0,g.getGlsl)(l.session.backend.glContext.version),t=d[0].dims.slice(),e=`
      void main() {
        vec4 result = ${d.map((n,r)=>`${o.texture2D}(X${r},TexCoords)`).join(" + ")};
        ${o.output} = result;
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:t,type:d[0].type,textureType:p.TextureType.unpacked},hasMain:!0,shaderSource:e})},s=l=>{if(!l||l.length===0)throw new Error("Sum requires inputs.");const d=l[0].dims.length;for(let a=1;a<l.length;a++){if(d!==l[a].dims.length)throw new Error("Input shapes are mismatched.");for(let o=0;o<d;o++)if(l[0].dims[o]!==l[a].dims[o])throw new Error("Input shapes are not matched.")}if(l[0].type!=="float32"&&l[0].type!=="float64")throw new Error("Invalid input type.");for(let a=1;a<l.length;a++)if(l[0].type!==l[a].type)throw new Error("Input types are not matched.")}},5944:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.tile=void 0;const g=b(6145),p=b(5639);u.tile=(l,d)=>{s(d);const a={name:"Tile",inputNames:["A"],inputTypes:[p.TextureType.unpacked]};return[l.run(Object.assign(Object.assign({},a),{get:()=>m(l,d,a)}),d)]};const m=(l,d,a)=>{const o=d[0].dims.slice(),t=new Array(o.length),e=[];for(let i=0;i<o.length;i++)t[i]=o[i]*d[1].numberData[i],e.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${o[i]}.));`);const n=t.length,r=`
      float process(int outputIdx[${n}]) {
        int inputIdx[${n}];
        ${e.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},a),{output:{dims:t,type:d[0].type,textureType:p.TextureType.unpacked},shaderSource:r})},s=l=>{if(!l||l.length!==2)throw new Error("Tile requires 2 input.");if(l[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(l[1].dims[0]!==l[0].dims.length)throw new Error("Invalid input shape.");if(g.NUMBER_TYPES.indexOf(l[0].type)===-1)throw new Error("Invalid input type.");if(l[1].type!=="int32"&&l[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseTransposeAttributes=u.transpose=void 0;const g=b(4910),p=b(7273),m=b(5639),s={name:"Transpose",inputNames:["A"],inputTypes:[m.TextureType.unpacked]};u.transpose=(e,n,r)=>(t(n),[e.run(Object.assign(Object.assign({},s),{cacheHint:r.cacheKey,get:()=>l(e,n[0],r.perm)}),n)]),u.parseTransposeAttributes=e=>(0,g.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const l=(e,n,r)=>{const i=n.dims;r=d(i,r);const c=a(i,r),f=i.length,y=`
      ${o("perm",r,f)}
      float process(int indices[${f}]) {
        int a[${f}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},s),{output:{dims:c,type:n.type,textureType:m.TextureType.unpacked},shaderSource:y})},d=(e,n)=>(n&&n.length!==e.length&&(n=[...e.keys()].reverse()),n),a=(e,n)=>(n=d(e,n),p.ShapeUtil.sortBasedOnPerm(e,n)),o=(e,n,r)=>{const i=[];i.push(`void ${e}(out int a[${r}], int src[${r}]) {`);for(let c=0;c<r;++c)i.push(`	a[${n[c]}]=src[${c}];`);return i.push("	}"),i.join(`
`)},t=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.encodeAsUint8=void 0;const g=b(6757),p=b(5639);u.encodeAsUint8=(m,s)=>{const l=s.shape,d=(0,g.getGlsl)(m.session.backend.glContext.version),a=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${d.texture2D}(X,TexCoords).r;
      ${d.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[p.TextureType.unpacked],inputNames:["X"],output:{dims:l,type:s.tensor.type,textureType:p.TextureType.downloadUint8AsFloat},shaderSource:a,hasMain:!0};return m.executeProgram(o,[s.tensor])}},9087:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.tanh=u.tan=u.sqrt=u.sin=u.sigmoid=u.relu=u.not=u.neg=u.log=u.parseLeakyReluAttributes=u.leakyRelu=u.identity=u.floor=u.exp=u.parseEluAttributes=u.elu=u.cos=u.ceil=u.clipV11=u.parseClipAttributes=u.clip=u.atan=u.asin=u.acos=u.abs=u.glslTanh=u.glslTan=u.glslSqrt=u.glslSigmoid=u.glslRelu=u.glslSin=u.glslNot=u.glslNeg=u.glslLog=u.glslLeakyRelu=u.glslIdentity=u.glslClip=u.glslFloor=u.glslExp=u.glslElu=u.glslCos=u.glslCeil=u.glslAtan=u.glslAsin=u.glslAcos=u.glslAbs=void 0;const g=b(4910),p=b(7273),m=b(1997),s=b(6757),l=b(5639);function d(){return D("abs")}function a(){return D("acos")}function o(){return D("asin")}function t(){return D("atan")}function e(){return D("ceil")}function n(){return D("cos")}function r(C){const k="elu";return{body:`
  const float alpha = float(${C});

  float ${k}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${k}_(vec4 v) {
    return vec4(${k}_(v.x), ${k}_(v.y), ${k}_(v.z), ${k}_(v.w));
  }
  `,name:k,type:m.FunctionType.ValueBased}}function i(){return D("exp")}function c(){return D("floor")}function f(C,k){const z="clip";return{body:`
  const float min = float(${C});
  const float max = float(${k});

  float ${z}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${z}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:z,type:m.FunctionType.ValueBased}}function y(){const C="indentity";return{body:`
  float ${C}_(float a) {
    return a;
  }
  vec4 ${C}_(vec4 v) {
    return v;
  }
  `,name:C,type:m.FunctionType.ValueBased}}function w(C){const k="leakyRelu";return{body:`
  const float alpha = float(${C});

  float ${k}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${k}_(vec4 v) {
    return vec4(${k}_(v.x), ${k}_(v.y), ${k}_(v.z), ${k}_(v.w));
  }
  `,name:k,type:m.FunctionType.ValueBased}}function x(){return D("log")}function _(){const C="neg";return{body:`
  float ${C}_(float a) {
    return -a;
  }
  vec4 ${C}_(vec4 v) {
    return -v;
  }
  `,name:C,type:m.FunctionType.ValueBased}}function S(){const C="not";return{body:`
  float ${C}_(float a) {
    return float( ! bool(a) );
  }
  bool ${C}_(bool a) {
    return !a;
  }
  vec4 ${C}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${C}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:C,type:m.FunctionType.ValueBased}}function I(){return D("sin")}function O(){const C="relu";return{body:`
  float ${C}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${C}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:C,type:m.FunctionType.ValueBased}}function T(){const C="sigmoid";return{body:`
  float ${C}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${C}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:C,type:m.FunctionType.ValueBased}}function A(){return D("sqrt")}function P(){return D("tan")}function R(){const C="tanh";return{body:`
  float ${C}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${C}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:C,type:m.FunctionType.ValueBased}}function D(C){return{body:`
  float ${C}_(float a) {
    return ${C}(a);
  }
  vec4 ${C}_(vec4 v) {
    return ${C}(v);
  }
  `,name:C,type:m.FunctionType.ValueBased}}u.glslAbs=d,u.glslAcos=a,u.glslAsin=o,u.glslAtan=t,u.glslCeil=e,u.glslCos=n,u.glslElu=r,u.glslExp=i,u.glslFloor=c,u.glslClip=f,u.glslIdentity=y,u.glslLeakyRelu=w,u.glslLog=x,u.glslNeg=_,u.glslNot=S,u.glslSin=I,u.glslRelu=O,u.glslSigmoid=T,u.glslSqrt=A,u.glslTan=P,u.glslTanh=R;const $=(C,k,z,G)=>{const Y=C.session.pack?l.TextureType.packed:l.TextureType.unpacked,K={name:z.name,inputTypes:[Y],inputNames:["A"],cacheHint:G};return Object.assign(Object.assign({},K),{get:()=>((ee,oe,Q,ae)=>{const re=ee.session.pack?l.TextureType.packed:l.TextureType.unpacked,ne=(0,s.getGlsl)(ee.session.backend.glContext.version);return Object.assign(Object.assign({},oe),{output:{dims:Q.dims,type:Q.type,textureType:re},shaderSource:`
     ${ae.body}
     void main() {
       vec4 v = ${ne.texture2D}(A, TexCoords);
       v = ${ae.name}_(v);
       ${ne.output} = v;
     }
     `,hasMain:!0})})(C,K,k,z)})};u.abs=(C,k)=>[C.run($(C,k[0],d()),k)],u.acos=(C,k)=>[C.run($(C,k[0],a()),k)],u.asin=(C,k)=>[C.run($(C,k[0],o()),k)],u.atan=(C,k)=>[C.run($(C,k[0],t()),k)],u.clip=(C,k,z)=>[C.run($(C,k[0],f(z.min,z.max),z.cacheKey),k)],u.parseClipAttributes=C=>(0,g.createAttributeWithCacheKey)({min:C.attributes.getFloat("min",p.MIN_CLIP),max:C.attributes.getFloat("max",p.MAX_CLIP)}),u.clipV11=(C,k)=>{const z=M(C,k);return(0,u.clip)(C,[k[0]],z)};const M=(C,k)=>{if(k.length>=3&&(!C.session.isInitializer(k[1].dataId)||!C.session.isInitializer(k[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const z=k.length>=3?k[1].numberData[0]:p.MIN_CLIP,G=k.length>=3?k[2].numberData[0]:p.MAX_CLIP;return(0,g.createAttributeWithCacheKey)({min:z,max:G})};u.ceil=(C,k)=>[C.run($(C,k[0],e()),k)],u.cos=(C,k)=>[C.run($(C,k[0],n()),k)],u.elu=(C,k,z)=>[C.run($(C,k[0],r(z.alpha),z.cacheKey),k)],u.parseEluAttributes=C=>(0,g.createAttributeWithCacheKey)({alpha:C.attributes.getFloat("alpha",1)}),u.exp=(C,k)=>[C.run($(C,k[0],i()),k)],u.floor=(C,k)=>[C.run($(C,k[0],c()),k)],u.identity=(C,k)=>[C.run($(C,k[0],y()),k)],u.leakyRelu=(C,k,z)=>[C.run($(C,k[0],w(z.alpha),z.cacheKey),k)],u.parseLeakyReluAttributes=C=>(0,g.createAttributeWithCacheKey)({alpha:C.attributes.getFloat("alpha",.01)}),u.log=(C,k)=>[C.run($(C,k[0],x()),k)],u.neg=(C,k)=>[C.run($(C,k[0],_()),k)],u.not=(C,k)=>[C.run($(C,k[0],S()),k)],u.relu=(C,k)=>[C.run($(C,k[0],O()),k)],u.sigmoid=(C,k)=>[C.run($(C,k[0],T()),k)],u.sin=(C,k)=>[C.run($(C,k[0],I()),k)],u.sqrt=(C,k)=>[C.run($(C,k[0],A()),k)],u.tan=(C,k)=>[C.run($(C,k[0],P()),k)],u.tanh=(C,k)=>[C.run($(C,k[0],R()),k)]},540:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createUnpackProgramInfoLoader=u.createUnpackProgramInfo=void 0;const g=b(6757),p=b(5639),m=b(432),s=b(5614),l={name:"unpack",inputNames:["A"],inputTypes:[p.TextureType.packed]};u.createUnpackProgramInfo=(d,a)=>{const o=a.dims.length,t=(0,s.getChannels)("rc",o),e=t.slice(-2),n=(0,m.getCoordsDataType)(o),r=(0,s.unpackFromChannel)(),i=a.dims.length===0?"":function(y,w){if(y===1)return"rc";let x="";for(let _=0;_<y;_++)x+=w[_],_<y-1&&(x+=",");return x}(o,t),c=o<=1?"rc":`vec2(${e.join(",")})`,f=`
    ${r}
    void main() {
      ${n} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${i});

       ${(0,g.getGlsl)(d.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${c}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},l),{hasMain:!0,output:{dims:a.dims,type:a.type,textureType:p.TextureType.unpacked},shaderSource:f})},u.createUnpackProgramInfoLoader=(d,a)=>Object.assign(Object.assign({},l),{get:()=>(0,u.createUnpackProgramInfo)(d,a)})},7862:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseUnsqueezeAttributes=u.unsqueezeV13=u.unsqueeze=void 0;const g=b(7273);u.unsqueeze=(s,l,d)=>{p(l);const a=g.ShapeUtil.unsqueezeShape(l[0].dims,d);return[s.reshapeUnpacked(l[0],a)]},u.unsqueezeV13=(s,l)=>(m(l),(0,u.unsqueeze)(s,[l[0]],Array.from(l[1].integerData))),u.parseUnsqueezeAttributes=s=>s.attributes.getInts("axes");const p=s=>{if(!s||s.length!==1)throw new Error("Unsqueeze requires 1 input.");if(s[0].type==="string")throw new Error("invalid input tensor types.")},m=s=>{if(!s||s.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(s[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.scalesValidation=u.validateInputs=u.parseUpsampleAttributes=u.parseUpsampleAttributesV9=u.parseUpsampleAttributesV7=u.upsample=void 0;const g=b(4910),p=b(6757),m=b(5639),s={name:"Upsample",inputNames:["X"],inputTypes:[m.TextureType.unpacked]};u.upsample=(d,a,o)=>((0,u.validateInputs)(a,o),[d.run(Object.assign(Object.assign({},s),{cacheHint:o.cacheKey,get:()=>l(d,a,o)}),a)]),u.parseUpsampleAttributesV7=d=>(0,u.parseUpsampleAttributes)(d,7),u.parseUpsampleAttributesV9=d=>(0,u.parseUpsampleAttributes)(d,9),u.parseUpsampleAttributes=(d,a)=>{const o=a>=10,t=d.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(a<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let e=[];a<9&&(e=d.attributes.getFloats("scales"),(0,u.scalesValidation)(e,t,o));const n=d.attributes.getFloat("extrapolation_value",0),r=a>10?d.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(r)===-1)throw new Error(`coordinate_transform_mode '${r}' is not supported`);const i=r==="tf_crop_and_resize",c=i,f=t==="nearest"&&a>=11?d.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(f)===-1)throw new Error(`nearest_mode '${f}' is not supported`);const y=d.attributes.getFloat("cubic_coeff_a",-.75),w=d.attributes.getInt("exclude_outside",0)!==0;if(w&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const x=a<11||t==="nearest"&&r==="asymmetric"&&f==="floor";let _=0,S=0,I=0;return a>10?d.inputs.length>2?(_=1,S=2,I=3):(S=1,I=2):a===9&&(S=1),(0,g.createAttributeWithCacheKey)({opset:a,isResize:o,mode:t,scales:e,extrapolationValue:n,coordinateTransformMode:r,useExtrapolation:c,needRoiInput:i,nearestMode:f,cubicCoefficientA:y,excludeOutside:w,useNearest2xOptimization:x,roiInputIdx:_,scalesInputIdx:S,sizesInputIdx:I})};const l=(d,a,o)=>{const t=(0,p.getGlsl)(d.session.backend.glContext.version),[e,n]=d.calculateTextureWidthAndHeight(a[0].dims,m.TextureType.unpacked),r=a[0].dims.map((I,O)=>Math.floor(I*o.scales[O])),[i,c]=d.calculateTextureWidthAndHeight(r,m.TextureType.unpacked),f=r.length,y=new Array(f),w=new Array(f);let x=`
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;for(let I=f-1;I>=0;I--)y[I]=I===f-1?1:y[I+1]*r[I+1],w[I]=I===f-1?1:w[I+1]*a[0].dims[I+1],x+=`
        output_pitches[${I}] = ${y[I]};
        input_pitches[${I}] = ${w[I]};
        `;const _=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${e}, ${n});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,S=o.mode==="nearest"?`
    ${_}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${c});

      ${x}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:f===4?`
    ${_}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${c});

      ${x}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${a[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${_}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${i}, ${c});

      ${x}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${a[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},s),{output:{dims:r,type:a[0].type,textureType:m.TextureType.unpacked},shaderSource:S,variables:[{name:"scales",type:"int",arrayLength:o.scales.length,data:o.scales.map(I=>Math.ceil(I))}]})};u.validateInputs=(d,a)=>{if(!d||a.opset<9&&d.length!==1||a.opset>=9&&a.opset<11&&d.length!==2||a.opset>=11&&d.length<2)throw new Error("invalid inputs.");if(a.scales.length>0&&d[0].dims.length!==a.scales.length)throw new Error("Invalid input shape.");if(d[0].type==="string")throw new Error("Invalid input tensor types.")},u.scalesValidation=(d,a,o)=>{if(o){for(const t of d)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of d)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(a!=="linear"&&a!=="cubic"||d.length===2||d.length===4&&d[0]===1&&d[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${o?"Resize":"Upsample"} opeartor.`)}},2757:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ProgramManager=void 0;const g=b(8453),p=b(1315),m=b(8897),s=b(6757);u.ProgramManager=class{constructor(l,d,a){this.profiler=l,this.glContext=d,this.textureLayoutStrategy=a,this.repo=new Map,this.attributesBound=!1}getArtifact(l){return this.repo.get(l)}setArtifact(l,d){this.repo.set(l,d)}run(l,d,a){var o;this.profiler.event("op",`ProgramManager.run ${(o=l.programInfo.name)!==null&&o!==void 0?o:"unknown kernel"}`,()=>{var t;const e=this.glContext.gl,n=l.program;e.useProgram(n);try{this.bindOutput(a),this.attributesBound||this.bindAttributes(l.attribLocations),this.bindUniforms(l.uniformLocations,(t=l.programInfo.variables)!==null&&t!==void 0?t:[],d)}catch(r){throw p.Logger.error("ProgramManager",l.programInfo.shaderSource),r}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(l=>this.glContext.deleteProgram(l.program))}build(l,d,a){return this.profiler.event("backend","ProgramManager.build",()=>{const o=new m.GlslPreprocessor(this.glContext,l,d,a),t=o.preprocess(),e=this.compile(t);return{programInfo:l,program:e,uniformLocations:this.getUniformLocations(e,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(e)}})}compile(l){if(!this.vertexShader){p.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const o=(0,s.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}g.env.debug&&p.Logger.verbose("ProrgramManager",`FragShader:
${l}
`);const d=this.glContext.compileShader(l,this.glContext.gl.FRAGMENT_SHADER),a=this.glContext.createProgram(this.vertexShader,d);return this.glContext.deleteShader(d),a}bindOutput(l){const d=l.width,a=l.height;p.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${d}/${a}, shape=${l.shape}, type=${l.tensor.type}`),this.glContext.attachFramebuffer(l.texture,d,a)}bindAttributes(l){const d=l.position,a=l.textureCoord;this.glContext.setVertexAttributes(d,a),this.attributesBound=!0}bindUniforms(l,d,a){var o;const t=this.glContext.gl;let e=0;for(const{name:n,type:r,location:i,arrayLength:c}of l){const f=(o=d.find(y=>y.name===n))===null||o===void 0?void 0:o.data;if(r!=="sampler2D"&&!f)throw new Error(`variable '${n}' does not have data defined in program info`);switch(r){case"sampler2D":this.bindTexture(a[e],i,e),e++;break;case"float":c?t.uniform1fv(i,f):t.uniform1f(i,f);break;case"int":c?t.uniform1iv(i,f):t.uniform1i(i,f);break;default:throw new Error(`Uniform not implemented: ${r}`)}}}bindTexture(l,d,a){this.glContext.bindTextureToUniform(l.texture,a,d)}getAttribLocations(l){return{position:this.getAttribLocation(l,"position"),textureCoord:this.getAttribLocation(l,"textureCoord")}}getUniformLocations(l,d,a){const o=[];if(d)for(const t of d)o.push({name:t,type:"sampler2D",location:this.getUniformLocation(l,t)});if(a)for(const t of a)o.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(l,t.name)}));return o}getUniformLocation(l,d){const a=this.glContext.gl.getUniformLocation(l,d);if(a===null)throw new Error(`Uniform ${d} not found.`);return a}getAttribLocation(l,d){return this.glContext.gl.getAttribLocation(l,d)}}},2171:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLSessionHandler=void 0;const g=b(1315),p=b(5881),m=b(7860),s=b(4110),l=b(2757),d=b(7618),a=b(5243);u.WebGLSessionHandler=class{constructor(o,t){this.backend=o,this.context=t,this.layoutStrategy=new d.PreferLogicalStrategy(o.glContext.maxTextureSize),this.programManager=new l.ProgramManager(this.context.profiler,o.glContext,this.layoutStrategy),this.textureManager=new a.TextureManager(o.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:o.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=o.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new m.WebGLInferenceHandler(this)}onGraphInitialized(o){const t=o.getValues().filter(e=>e.from===-1&&e.tensor).map(e=>e.tensor.dataId);this.initializers=new Set(t)}isInitializer(o){return!!this.initializers&&this.initializers.has(o)}addInitializer(o){this.initializers.add(o)}getTextureData(o,t){return t?this.packedTextureDataCache.get(o):this.unpackedTextureDataCache.get(o)}setTextureData(o,t,e=!1){g.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),e?this.packedTextureDataCache.set(o,t):this.unpackedTextureDataCache.set(o,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(o=>this.textureManager.releaseTexture(o,!0)),this.unpackedTextureDataCache=new Map}resolve(o,t,e){const n=(0,p.resolveOperator)(o,t,s.WEBGL_OP_RESOLVE_RULES);return{impl:n.opImpl,context:n.opInit?n.opInit(o,e):o}}}},9622:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Uint8DataEncoder=u.RGBAFloatDataEncoder=u.RedFloat32DataEncoder=void 0;const g=b(1315);u.RedFloat32DataEncoder=class{constructor(p,m=1){if(m===1)this.internalFormat=p.R32F,this.format=p.RED,this.textureType=p.FLOAT,this.channelSize=m;else{if(m!==4)throw new Error(`Invalid number of channels: ${m}`);this.internalFormat=p.RGBA32F,this.format=p.RGBA,this.textureType=p.FLOAT,this.channelSize=m}}encode(p,m){let s,l;return p.constructor!==Float32Array&&(g.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),l=new Float32Array(p)),m*this.channelSize>p.length?(g.Logger.warning("Encoder","Source data too small. Allocating larger array"),l=p,s=this.allocate(m*this.channelSize),l.forEach((d,a)=>s[a]=d)):(l=p,s=l),s}allocate(p){return new Float32Array(4*p)}decode(p,m){return this.channelSize===1?p.filter((s,l)=>l%4==0).subarray(0,m):p.subarray(0,m)}},u.RGBAFloatDataEncoder=class{constructor(p,m=1,s){if(m!==1&&m!==4)throw new Error(`Invalid number of channels: ${m}`);this.internalFormat=p.RGBA,this.format=p.RGBA,this.channelSize=m,this.textureType=s||p.FLOAT}encode(p,m){let s=p;return this.channelSize===1&&(g.Logger.verbose("Encoder","Exploding into a larger array"),s=this.allocate(m),p.forEach((l,d)=>s[4*d]=l)),s}allocate(p){return new Float32Array(4*p)}decode(p,m){return this.channelSize===1?p.filter((s,l)=>l%4==0).subarray(0,m):p.subarray(0,m)}},u.Uint8DataEncoder=class{constructor(p,m=1){if(this.channelSize=4,m===1)this.internalFormat=p.ALPHA,this.format=p.ALPHA,this.textureType=p.UNSIGNED_BYTE,this.channelSize=m;else{if(m!==4)throw new Error(`Invalid number of channels: ${m}`);this.internalFormat=p.RGBA,this.format=p.RGBA,this.textureType=p.UNSIGNED_BYTE,this.channelSize=m}}encode(p,m){return new Uint8Array(p.buffer,p.byteOffset,p.byteLength)}allocate(p){return new Uint8Array(p*this.channelSize)}decode(p,m){if(p instanceof Uint8Array)return p.subarray(0,m);throw new Error(`Invalid array type: ${p.constructor}`)}}},7618:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getBatchDim=u.sizeToSquarishShape=u.getRowsCols=u.sizeFromShape=u.isInt=u.parseAxisParam=u.squeezeShape=u.PreferLogicalStrategy=u.AlwaysKeepOriginalSizeStrategy=void 0;const g=b(1315),p=b(7273);function m(o,t){const e=[],n=[],r=t!=null&&Array.isArray(t)&&t.length===0,i=t==null||r?null:s(t,o).sort();let c=0;for(let f=0;f<o.length;++f){if(i!=null){if(i[c]===f&&o[f]!==1)throw new Error(`Can't squeeze axis ${f} since its dim '${o[f]}' is not 1`);(i[c]==null||i[c]>f)&&o[f]===1&&(e.push(o[f]),n.push(f)),i[c]<=f&&c++}o[f]!==1&&(e.push(o[f]),n.push(f))}return{newShape:e,keptDims:n}}function s(o,t){const e=t.length;return o=o==null?t.map((n,r)=>r):[].concat(o),(0,p.assert)(o.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${o}`),(0,p.assert)(o.every(l),()=>`All values in axis param must be integers but got axis ${o}`),o.map(n=>n<0?e+n:n)}function l(o){return o%1==0}function d(o){if(o.length===0)return 1;let t=o[0];for(let e=1;e<o.length;e++)t*=o[e];return t}function a(o){const t=Math.ceil(Math.sqrt(o));return[t,Math.ceil(o/t)]}u.AlwaysKeepOriginalSizeStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,t){if(o.length===0)return[1,1];const e=this.maxTextureSize;if(t&&t.breakAxis!==void 0){const i=t.breakAxis>=o.length?1:o.slice(t.breakAxis).reduce((f,y)=>f*y),c=t.breakAxis<=0?1:o.slice(0,t.breakAxis).reduce((f,y)=>f*y);if(!(i>e||c>e))return[i,c];g.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${t.breakAxis}`)}const n=o.reduce((i,c)=>i*c);let r=Math.floor(Math.sqrt(n));for(;r<e&&r<n&&n%r!=0;r++);if(r>=e||n%r!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${o}`);return[r,n/r]}},u.PreferLogicalStrategy=class{constructor(o){this.maxTextureSize=o}computeTextureWH(o,t){const e=this.computeTexture(o,t);return t&&t.isPacked&&(e[0]/=2,e[1]/=2),t&&t.reverseWH?[e[1],e[0]]:e}computeTexture(o,t){const e=t&&t.isPacked;if(o.length===0)return e?[2,2]:[1,1];let n=this.maxTextureSize;if(t&&t.breakAxis!==void 0){const c=t.breakAxis>=o.length?1:o.slice(t.breakAxis).reduce((y,w)=>y*w),f=t.breakAxis<=0?1:o.slice(0,t.breakAxis).reduce((y,w)=>y*w);if(!(c>n||f>n))return[c,f];g.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${o}, breakAxis:${t.breakAxis}`)}let r=o.slice(0);e&&(n*=2,r=r.map((c,f)=>f>=r.length-2?r[f]%2==0?r[f]:r[f]+1:r[f]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=m(r).newShape);const i=d(r);return r.length<=1&&i<=n?[1,i]:r.length===2&&r[0]<=n&&r[1]<=n?r:r.length===3&&r[0]*r[1]<=n&&r[2]<=n?[r[0]*r[1],r[2]]:r.length===3&&r[0]<=n&&r[1]*r[2]<=n?[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=n&&r[3]<=n?[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=n&&r[1]*r[2]*r[3]<=n?[r[0],r[1]*r[2]*r[3]]:e?a(i/4).map(c=>2*c):a(i)}},u.squeezeShape=m,u.parseAxisParam=s,u.isInt=l,u.sizeFromShape=d,u.getRowsCols=function(o){if(o.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[o.length>1?o[o.length-2]:1,o[o.length-1]]},u.sizeToSquarishShape=a,u.getBatchDim=function(o,t=2){return d(o.slice(0,o.length-t))}},3314:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createTextureLayoutFromShape=u.calculateTextureWidthAndHeight=u.createTextureLayoutFromTextureType=void 0;const g=b(7273),p=b(5639);u.createTextureLayoutFromTextureType=(m,s,l)=>{const d=l===p.TextureType.unpacked||l===p.TextureType.unpackedReversed?1:4,a=l===p.TextureType.packed,o=l===p.TextureType.unpackedReversed||l===p.TextureType.packed,t=l===p.TextureType.packedLastDimension?s.length-1:void 0,e=l===p.TextureType.packedLastDimension?s.map((n,r)=>r===s.length-1?4*n:n):void 0;return(0,u.createTextureLayoutFromShape)(m,s,d,e,{isPacked:a,reverseWH:o,breakAxis:t})},u.calculateTextureWidthAndHeight=(m,s,l)=>{const d=(0,u.createTextureLayoutFromTextureType)(m,s,l);return[d.width,d.height]},u.createTextureLayoutFromShape=(m,s,l=1,d,a)=>{const o=!(!a||!a.isPacked),[t,e]=m.computeTextureWH(o&&d||s,a),n=s.length;let r=s.slice(0);if(n===0&&(r=[1]),l===1)d=s;else if(o){if(l!==4)throw new Error("a packed texture must be 4-channel");d=s,n>0&&(r[n-1]=Math.ceil(r[n-1]/2)),n>1&&(r[n-2]=Math.ceil(r[n-2]/2))}else if(!d)throw new Error("Unpacked shape is needed when using channels > 1");return{width:t,height:e,channels:l,isPacked:o,shape:r,strides:g.ShapeUtil.computeStrides(r),unpackedShape:d,reversedWH:a&&a.reverseWH}}},5243:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.TextureManager=void 0;const g=b(1315);u.TextureManager=class{constructor(p,m,s,l){this.glContext=p,this.layoutStrategy=m,this.profiler=s,this.config=l,this.pendingRead=new Map,l.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(p,m,s,l){const d=this.toEncoderType(p),a=this.glContext.getEncoder(d,m.channels||1,l);if(m.isPacked&&l===1)throw new Error("not implemented");const o=m.width,t=m.height;let e,n;if(this.config.reuseTextures){e=`${o}x${t}_${a.format}_${a.internalFormat}_${a.textureType}`,n=this.inUseTextures.get(e),n||(n=[],this.inUseTextures.set(e,n));const i=this.idleTextures.get(e);if(i&&i.length>0){const c=i.pop();return n.push(c),l===1&&this.glContext.updateTexture(c,o,t,a,this.toTextureData(p,s)),c}}g.Logger.verbose("TextureManager",`Creating new texture of size ${m.width}x${m.height}`);const r=this.glContext.allocateTexture(o,t,a,this.toTextureData(p,s));return this.config.reuseTextures&&(n.push(r),this.textureLookup.set(r,e)),r}readTexture(p,m,s){return s||(s=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const l=p.shape.reduce((a,o)=>a*o)*s,d=this.glContext.readTexture(p.texture,p.width,p.height,l,this.toEncoderType(m),s);return this.toTensorData(m,d)})}async readTextureAsync(p,m,s){const l=p.tensor.dataId;if(s||(s=1),this.pendingRead.has(l)){const d=this.pendingRead.get(l);return new Promise(a=>d==null?void 0:d.push(a))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(l,[]);const d=p.shape.reduce((e,n)=>e*n)*s;await this.glContext.createAndWaitForFence();const a=this.glContext.readTexture(p.texture,p.width,p.height,d,this.toEncoderType(m),s),o=this.toTensorData(m,a),t=this.pendingRead.get(l);return this.pendingRead.delete(l),t==null||t.forEach(e=>e(o)),o})}readUint8TextureAsFloat(p){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const m=p.shape.reduce((l,d)=>l*d),s=this.glContext.readTexture(p.texture,p.width,p.height,4*m,"byte",4);return new Float32Array(s.buffer,s.byteOffset,m)})}releaseTexture(p,m){let s;if(this.config.reuseTextures&&(s=this.textureLookup.get(p.texture),s)){m&&this.textureLookup.delete(s);const l=this.inUseTextures.get(s);if(l){const d=l.indexOf(p.texture);if(d!==-1){l.splice(d,1);let a=this.idleTextures.get(s);a||(a=[],this.idleTextures.set(s,a)),a.push(p.texture)}}}s&&!m||(g.Logger.verbose("TextureManager",`Deleting texture of size ${p.width}x${p.height}`),this.glContext.deleteTexture(p.texture))}toTensorData(p,m){switch(p){case"int16":return m instanceof Int16Array?m:Int16Array.from(m);case"int32":return m instanceof Int32Array?m:Int32Array.from(m);case"int8":return m instanceof Int8Array?m:Int8Array.from(m);case"uint16":return m instanceof Uint16Array?m:Uint16Array.from(m);case"uint32":return m instanceof Uint32Array?m:Uint32Array.from(m);case"uint8":case"bool":return m instanceof Uint8Array?m:Uint8Array.from(m);case"float32":return m instanceof Float32Array?m:Float32Array.from(m);case"float64":return m instanceof Float64Array?m:Float64Array.from(m);default:throw new Error(`TensorData type ${p} is not supported`)}}toTextureData(p,m){if(m)return m instanceof Float32Array?m:new Float32Array(m)}toEncoderType(p){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(v,u)=>{var b;Object.defineProperty(u,"__esModule",{value:!0}),u.TextureType=void 0,(b=u.TextureType||(u.TextureType={}))[b.unpacked=0]="unpacked",b[b.unpackedReversed=1]="unpackedReversed",b[b.packed=2]="packed",b[b.downloadUint8AsFloat=3]="downloadUint8AsFloat",b[b.packedLastDimension=4]="packedLastDimension"},432:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.getGlChannels=u.getCoordsDataType=u.getSqueezedParams=u.squeezeInputShape=u.generateShaderFuncNameFromInputSamplerNameAtOutCoords=u.generateShaderFuncNameFromInputSamplerName=u.repeatedTry=u.getPackedShape=void 0;const g=b(7273);u.getPackedShape=function(p){const m=p.length;return p.slice(0,m-1).concat(p[m-1]/4)},u.repeatedTry=async function(p,m=l=>0,s){return new Promise((l,d)=>{let a=0;const o=()=>{if(p())return void l();a++;const t=m(a);s!=null&&a>=s?d():setTimeout(o,t)};o()})},u.generateShaderFuncNameFromInputSamplerName=function(p){return(0,g.assert)(p!==void 0&&p.length!==0,()=>"empty string found for sampler name"),"get"+p.charAt(0).toUpperCase()+p.slice(1)},u.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(p){return(0,g.assert)(p!==void 0&&p.length!==0,()=>"empty string found for sampler name"),"get"+p.charAt(0).toUpperCase()+p.slice(1)+"AtOutCoords"},u.squeezeInputShape=function(p,m){let s=JSON.parse(JSON.stringify(p));return s=m,s},u.getSqueezedParams=function(p,m){return m.map(s=>p[s]).join(", ")},u.getCoordsDataType=function(p){if(p<=1)return"int";if(p===2)return"ivec2";if(p===3)return"ivec3";if(p===4)return"ivec4";if(p===5)return"ivec5";if(p===6)return"ivec6";throw Error(`GPU for rank ${p} is not yet supported`)},u.getGlChannels=function(p=6){return["x","y","z","w","u","v"].slice(0,p)}},3389:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createNewWebGLContext=u.createWebGLContext=void 0;const g=b(1315),p=b(3524),m={};function s(l){const d=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const t=document.createElement("canvas");return t.width=1,t.height=1,t}();let a;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!l||l==="webgl2")&&(a=d.getContext("webgl2",o),a))try{return new p.WebGLContext(a,2)}catch(t){g.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${t}`)}if((!l||l==="webgl")&&(a=d.getContext("webgl",o)||d.getContext("experimental-webgl",o),a))try{return new p.WebGLContext(a,1)}catch(t){g.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t}`)}throw new Error("WebGL is not supported")}u.createWebGLContext=function l(d){let a;d&&d!=="webgl2"||!("webgl2"in m)?d&&d!=="webgl"||!("webgl"in m)||(a=m.webgl):a=m.webgl2,a=a||s(d),d=d||a.version===1?"webgl":"webgl2";const o=a.gl;return m[d]=a,o.isContextLost()?(delete m[d],l(d)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),a)},u.createNewWebGLContext=s},3524:function(v,u,b){var g=this&&this.__createBinding||(Object.create?function(o,t,e,n){n===void 0&&(n=e);var r=Object.getOwnPropertyDescriptor(t,e);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[e]}}),Object.defineProperty(o,n,r)}:function(o,t,e,n){n===void 0&&(n=e),o[n]=t[e]}),p=this&&this.__setModuleDefault||(Object.create?function(o,t){Object.defineProperty(o,"default",{enumerable:!0,value:t})}:function(o,t){o.default=t}),m=this&&this.__importStar||function(o){if(o&&o.__esModule)return o;var t={};if(o!=null)for(var e in o)e!=="default"&&Object.prototype.hasOwnProperty.call(o,e)&&g(t,o,e);return p(t,o),t};Object.defineProperty(u,"__esModule",{value:!0}),u.WebGLContext=u.linearSearchLastTrue=void 0;const s=b(8453),l=m(b(9622)),d=b(432);function a(o){let t=0;for(;t<o.length&&o[t]();++t);return t-1}u.linearSearchLastTrue=a,u.WebGLContext=class{constructor(o,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=o,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(o,t,e,n){const r=this.gl,i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE);const c=n?e.encode(n,o*t):null;return r.texImage2D(r.TEXTURE_2D,0,e.internalFormat,o,t,0,e.format,e.textureType,c),this.checkError(),i}updateTexture(o,t,e,n,r){const i=this.gl;i.bindTexture(i.TEXTURE_2D,o);const c=n.encode(r,t*e);i.texSubImage2D(i.TEXTURE_2D,0,0,0,t,e,n.format,n.textureType,c),this.checkError()}attachFramebuffer(o,t,e){const n=this.gl;n.bindTexture(n.TEXTURE_2D,o),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,o,0),this.checkError(),n.viewport(0,0,t,e),n.scissor(0,0,t,e)}readTexture(o,t,e,n,r,i){const c=this.gl;i||(i=1),this.frameBufferBound||this.attachFramebuffer(o,t,e);const f=this.getEncoder(r,i),y=f.allocate(t*e);return c.bindTexture(c.TEXTURE_2D,o),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,o,0),c.readPixels(0,0,t,e,c.RGBA,f.textureType,y),this.checkError(),f.decode(y,n)}isFramebufferReady(){return!0}getActiveTexture(){const o=this.gl;return"TEXTURE"+(o.getParameter(this.gl.ACTIVE_TEXTURE)-o.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(o,t){const e=this.gl;e.vertexAttribPointer(o,3,e.FLOAT,!1,20,0),e.enableVertexAttribArray(o),t!==-1&&(e.vertexAttribPointer(t,2,e.FLOAT,!1,20,12),e.enableVertexAttribArray(t)),this.checkError()}createProgram(o,t){const e=this.gl,n=e.createProgram();return e.attachShader(n,o),e.attachShader(n,t),e.linkProgram(n),n}compileShader(o,t){const e=this.gl,n=e.createShader(t);if(!n)throw new Error(`createShader() returned null with type ${t}`);if(e.shaderSource(n,o),e.compileShader(n),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${e.getShaderInfoLog(n)}
Shader source:
${o}`);return n}deleteShader(o){this.gl.deleteShader(o)}bindTextureToUniform(o,t,e){const n=this.gl;n.activeTexture(n.TEXTURE0+t),this.checkError(),n.bindTexture(n.TEXTURE_2D,o),this.checkError(),n.uniform1i(e,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(s.env.debug){const o=this.gl,t=o.getError();let e="";switch(t){case o.NO_ERROR:return;case o.INVALID_ENUM:e="INVALID_ENUM";break;case o.INVALID_VALUE:e="INVALID_VALUE";break;case o.INVALID_OPERATION:e="INVALID_OPERATION";break;case o.INVALID_FRAMEBUFFER_OPERATION:e="INVALID_FRAMEBUFFER_OPERATION";break;case o.OUT_OF_MEMORY:e="OUT_OF_MEMORY";break;case o.CONTEXT_LOST_WEBGL:e="CONTEXT_LOST_WEBGL";break;default:e=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(e)}}deleteTexture(o){this.gl.deleteTexture(o)}deleteProgram(o){this.gl.deleteProgram(o)}getEncoder(o,t,e=0){if(this.version===2)return new l.RedFloat32DataEncoder(this.gl,t);switch(o){case"float":return e===1||this.isRenderFloat32Supported?new l.RGBAFloatDataEncoder(this.gl,t):new l.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new l.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${o}`)}}clearActiveTextures(){const o=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)o.activeTexture(o.TEXTURE0+t),o.bindTexture(o.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(this.framebuffer),o.bindBuffer(o.ARRAY_BUFFER,null),o.deleteBuffer(this.vertexbuffer),o.bindBuffer(o.ELEMENT_ARRAY_BUFFER,null),o.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const o=this.gl,t=o.createBuffer();if(!t)throw new Error("createBuffer() returned null");const e=this.createDefaultGeometry();return o.bindBuffer(o.ARRAY_BUFFER,t),o.bufferData(o.ARRAY_BUFFER,e,o.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const o=this.gl.createFramebuffer();if(!o)throw new Error("createFramebuffer returned null");return o}queryVitalParameters(){const o=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=o.getParameter(o.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=o.getParameter(o.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const o=this.gl,t=o.createTexture();o.bindTexture(o.TEXTURE_2D,t);const e=this.version===2?o.RGBA32F:o.RGBA;o.texImage2D(o.TEXTURE_2D,0,e,1,1,0,o.RGBA,o.FLOAT,null);const n=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,n),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,t,0);const r=o.checkFramebufferStatus(o.FRAMEBUFFER)===o.FRAMEBUFFER_COMPLETE;return o.bindTexture(o.TEXTURE_2D,null),o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteTexture(t),o.deleteFramebuffer(n),r}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const o=this.gl;let t,e,n,r,i;try{t=o.createTexture(),e=o.createFramebuffer(),o.bindTexture(o.TEXTURE_2D,t);const c=this.version===2?o.RGBA32F:o.RGBA;return o.texImage2D(o.TEXTURE_2D,0,c,1,1,0,o.RGBA,o.FLOAT,null),o.bindFramebuffer(o.FRAMEBUFFER,e),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,t,0),o.enable(o.BLEND),n=o.createShader(o.VERTEX_SHADER),!!n&&(o.shaderSource(n,"void main(){}"),o.compileShader(n),r=o.createShader(o.FRAGMENT_SHADER),!!r&&(o.shaderSource(r,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),o.compileShader(r),i=o.createProgram(),!!i&&(o.attachShader(i,n),o.attachShader(i,r),o.linkProgram(i),o.useProgram(i),o.drawArrays(o.POINTS,0,1),o.getError()===o.NO_ERROR)))}finally{o.disable(o.BLEND),i&&o.deleteProgram(i),n&&o.deleteShader(n),r&&o.deleteShader(r),e&&(o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(e)),t&&(o.bindTexture(o.TEXTURE_2D,null),o.deleteTexture(t))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const o=this.gl,t=this.disjointTimerQueryWebgl2Extension,e=o.createQuery();return o.beginQuery(t.TIME_ELAPSED_EXT,e),e}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const o=this.gl,t=this.disjointTimerQueryWebgl2Extension;o.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(o){let t=!1,e=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl,r=this.disjointTimerQueryWebgl2Extension;t=n.getQueryParameter(o,n.QUERY_RESULT_AVAILABLE),e=n.getParameter(r.GPU_DISJOINT_EXT)}return t&&!e}getTimerResult(o){let t=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl;t=e.getQueryParameter(o,e.QUERY_RESULT),e.deleteQuery(o)}return t/1e6}async waitForQueryAndGetTime(o){return await(0,d.repeatedTry)(()=>this.isTimerResultAvailable(o)),this.getTimerResult(o)}async createAndWaitForFence(){const o=this.createFence(this.gl);return this.pollFence(o)}createFence(o){let t;const e=o,n=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return o.flush(),t=n===null?()=>!0:()=>{const r=e.clientWaitSync(n,0,0);return r===e.ALREADY_SIGNALED||r===e.CONDITION_SATISFIED},{query:n,isFencePassed:t}}async pollFence(o){return new Promise(t=>{this.addItemToPoll(()=>o.isFencePassed(),()=>t())})}pollItems(){const o=a(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=o;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(o+1)}async addItemToPoll(o,t){this.itemsToPoll.push({isDoneFn:o,resolveFn:t}),this.itemsToPoll.length>1||await(0,d.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ExecutionPlan=void 0;const g=b(1315);class p{constructor(s,l){this.op=s,this.node=l}}u.ExecutionPlan=class{constructor(m,s,l){this.graph=m,this.profiler=l,this.initialize(s)}initialize(m){this.profiler.event("session","ExecutionPlan.initialize",()=>{const s=this.graph.getNodes();if(s.length!==m.length)throw new Error("The size of nodes and OPs do not match.");this._ops=m.map((l,d)=>new p(l,s[d])),this.reset(),this._starter=[],this._ops.forEach((l,d)=>{let a=!0;for(const o of l.node.inputs)if(!this._values[o]&&this.graph.getInputIndices().indexOf(o)===-1){a=!1;break}a&&this._starter.push(d)})})}reset(){this._values=this.graph.getValues().map(m=>m.tensor)}async execute(m,s){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const l=m.createInferenceHandler(),d=this.graph.getInputIndices();if(s.length!==d.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${s.length} expected: ${d.length}`);s.forEach((r,i)=>{const c=d[i];this._values[c]=r});const a=this._starter.slice(0),o=this.graph.getValues(),t=this.graph.getNodes();let e=0;for(;e<a.length;){const r=a[e++],i=this._ops[r],c=i.node.inputs.map(x=>this._values[x]);if(c.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${i.node}`);const f=c;g.Logger.verbose("ExecPlan",`Runing op:${i.node.name} (${f.map((x,_)=>`'${i.node.inputs[_]}': ${x.type}[${x.dims.join(",")}]`).join(", ")})`);const y=await this.profiler.event("node",i.node.name,async()=>i.op.impl(l,f,i.op.context));if(y.length!==i.node.outputs.length)throw new Error("the size of output does not match model definition.");y.forEach((x,_)=>{const S=i.node.outputs[_];if(this._values[S])throw new Error(`output [${S}] already has value: op:${i.node.name}`);this._values[S]=x});const w=new Set;y.forEach((x,_)=>{const S=i.node.outputs[_];for(const I of o[S].to){const O=t[I];let T=!0;for(const A of O.inputs)if(!this._values[A]){T=!1;break}T&&w.add(I)}}),a.push(...w)}const n=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){const i=this.graph.getOutputIndices()[r],c=this._values[i];if(c===void 0)throw new Error(`required output [${i}] does not have value`);i===0?await c.getData():c.data,n.push(c)}return g.Logger.verbose("ExecPlan","disposing of inferenceHandler"),l.dispose(),n})}}},4662:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Graph=void 0;const g=b(1446),p=b(6874),m=b(1287),s=b(9240),l=b(7273);var d=m.onnxruntime.experimental.fbs;u.Graph={from:(e,n)=>new t(e,n)};class a{constructor(n){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,n&&(this.type=l.ProtoUtil.tensorValueTypeFromProto(n.type.tensorType))}get from(){return this._from}get to(){return this._to}}class o{constructor(n,r){n instanceof g.onnx.NodeProto?(this.name=n.name,this.opType=n.opType,this.attributes=new p.Attribute(n.attribute)):n instanceof d.Node&&(this.name=r??n.name(),this.opType=n.opType(),this.attributes=new p.Attribute(l.ProtoUtil.tensorAttributesFromORTFormat(n))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class t{constructor(n,r){if(!n)throw new TypeError("graph is empty");this.buildGraph(n),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(n){if(n instanceof g.onnx.GraphProto)this.buildGraphFromOnnxFormat(n);else{if(!(n instanceof d.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(n)}}buildGraphFromOnnxFormat(n){const r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const i=new Map;if(!n.input)throw new Error("missing information in graph: input");const c=[];for(const f of n.input){if(r.has(f.name))throw new Error(`duplicated input name: ${f.name}`);const y=this._allData.push(new a(f))-1;r.set(f.name,y),c.push(f.name)}if(!n.initializer)throw new Error("missing information in graph: initializer");for(const f of n.initializer){let y=r.get(f.name);if(y===void 0){const w=new a;w.type={shape:{dims:l.ProtoUtil.tensorDimsFromProto(f.dims)},tensorType:l.ProtoUtil.tensorDataTypeFromProto(f.dataType)},y=this._allData.push(w)-1,r.set(f.name,y)}this._allData[y]._from=-1,this._allData[y].tensor=s.Tensor.fromProto(f)}for(let f=0;f<this._allData.length;f++)this._allData[f].tensor||(this._allInputIndices.push(f),this._allInputNames.push(c[f]));if(!n.output)throw new Error("missing information in graph: output");for(const f of n.output){if(r.has(f.name))throw new Error(`duplicated output name: ${f.name}`);const y=this._allData.push(new a(f))-1;r.set(f.name,y),this._allOutputIndices.push(y),this._allOutputNames.push(f.name)}if(!n.node)throw new Error("missing information in graph: node");for(const f of n.node){if(!f.name)for(let w=0;;w++){const x=`unnamed_${f.opType}_${w}`;if(!i.has(x)){f.name=x;break}}if(i.has(f.name))throw new Error(`duplicated node name: ${f.name}`);const y=this._nodes.push(new o(f))-1;i.set(f.name,y)}for(let f=0;f<this._nodes.length;f++){const y=this._nodes[f],w=n.node[f];if(!w.output)throw new Error(`missing output for node: ${w.name}`);for(const x of w.output){let _=r.get(x);if(_===void 0&&(_=this._allData.push(new a)-1,r.set(x,_)),y.outputs.push(_),this._allData[_]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${_}`);if(this._allData[_]._from=f,w.opType==="Constant"){if(!w.attribute||w.attribute.length!==1||!w.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!w.output||w.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");y.outputs.pop(),y.executeNode=!1,this._allData[_]._from=-1,this._allData[_].tensor=s.Tensor.fromProto(w.attribute[0].t)}}}for(let f=0;f<this._nodes.length;f++){const y=this._nodes[f],w=n.node[f];if(!w.input)throw new Error(`missing input for node: ${w.name}`);for(const x of w.input){const _=r.get(x);if(_===void 0){if(x===""&&w.input.length===3&&w.opType==="Resize")continue;throw new Error(`unrecognized input '${x}' for node: ${w.name}`)}y.inputs.push(_),this._allData[_]._to.push(f)}}return!0}buildGraphFromOrtFormat(n){var r,i,c;const f=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const y=new Map,w=[];for(let x=0;x<n.inputsLength();x++){const _=n.inputs(x);if(f.has(_))throw new Error(`duplicated input name: ${_}`);for(let S=0;S<n.nodeArgsLength();S++)if(((r=n.nodeArgs(S))===null||r===void 0?void 0:r.name())===_){const I=new a;if(((c=(i=n.nodeArgs(S))===null||i===void 0?void 0:i.type())===null||c===void 0?void 0:c.valueType())!==d.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const O=n.nodeArgs(S).type().value(new d.TensorTypeAndShape),T=l.ProtoUtil.tensorDataTypeFromProto(O.elemType()),A=O.shape(),P=[];for(let D=0;D<A.dimLength();D++)P.push(l.LongUtil.longToNumber(A.dim(D).value().dimValue()));I.type={shape:{dims:P},tensorType:T};const R=this._allData.push(I)-1;f.set(_,R),w.push(_)}}for(let x=0;x<n.initializersLength();x++){const _=n.initializers(x);let S=f.get(_.name());if(S===void 0){const I=new a,O=l.ProtoUtil.tensorDimsFromORTFormat(_),T=l.ProtoUtil.tensorDataTypeFromProto(_.dataType());I.type={shape:{dims:O},tensorType:T},S=this._allData.push(I)-1,f.set(_.name(),S)}this._allData[S]._from=-1,this._allData[S].tensor=s.Tensor.fromOrtTensor(_)}for(let x=0;x<this._allData.length;x++)this._allData[x].tensor||(this._allInputIndices.push(x),this._allInputNames.push(w[x]));for(let x=0;x<n.outputsLength();x++){const _=n.outputs(x);if(f.has(_))throw new Error(`duplicated output name: ${_}`);const S=this._allData.push(new a)-1;f.set(_,S),this._allOutputIndices.push(S),this._allOutputNames.push(_)}if(!n.nodes)throw new Error("missing information in graph: node");for(let x=0;x<n.nodesLength();x++){const _=n.nodes(x);let S=_.name();if(!S)for(let O=0;S=`unnamed_${_.opType()}_${O}`,y.has(S);O++);if(y.has(S))throw new Error(`duplicated node name: ${S}`);const I=this._nodes.push(new o(_,S))-1;y.set(S,I)}for(let x=0;x<this._nodes.length;x++){const _=this._nodes[x],S=n.nodes(x);if(S==null)throw new Error(`No node exists at index ${x}`);if((S==null?void 0:S.outputsLength())===0)throw new Error(`missing output for node: ${S.name}`);for(let I=0;I<(S==null?void 0:S.outputsLength());I++){const O=S==null?void 0:S.outputs(I);let T=f.get(O);if(T===void 0&&(T=this._allData.push(new a)-1,f.set(O,T)),_.outputs.push(T),this._allData[T]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${T}`);if(this._allData[T]._from=x,S.opType()==="Constant"){if(S.attributesLength()!==1||!S.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(S.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");_.outputs.pop(),_.executeNode=!1,this._allData[T]._from=-1,this._allData[T].tensor=s.Tensor.fromOrtTensor(S.attributes(0).t())}}}for(let x=0;x<this._nodes.length;x++){const _=this._nodes[x],S=n.nodes(x);if(S.inputsLength()===0)throw new Error(`missing input for node: ${S.name}`);for(let I=0;I<S.inputsLength();I++){const O=S.inputs(I),T=f.get(O);if(T===void 0)throw new Error(`unrecognized input '${O}' for node: ${S.name()}`);_.inputs.push(T),this._allData[T]._to.push(x)}}}checkIsAcyclic(){const n=new Set;this._allInputIndices.forEach(c=>{this._allData[c]._to.forEach(f=>{n.add(f)})});const r=Array.from(n),i=new Array(this._nodes.length).fill("white");for(;r.length>0;){const c=r.pop();i[c]==="gray"?i[c]="black":(r.push(c),i[c]="gray",this._nodes[c].outputs.forEach(f=>{const y=this._allData[f];if(y.tensor!==void 0)throw new Error("node outputs should not be initialized");if(y._from!==c)throw new Error("from property of the Value object doesn't match index of Node being processed");y._to.forEach(w=>{if(i[w]==="gray")throw new Error("model graph is cyclic");i[w]==="white"&&r.push(w)})}))}}transformGraph(n){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),n&&n.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let n=0;const r=new Array(this._nodes.length,0);let i=0;for(let c=0;c<this._nodes.length;c++)r[c]=i,this._nodes[c].executeNode?(i!==c&&(this._nodes[i]=this._nodes[c]),i++):this._nodes[c].outputs.forEach(f=>{this._allData[f]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let c=0;c<this._allData.length;c++){const f=this._allData[c];f._from!==void 0&&f._from!==-1&&f._from!==-2&&(f._from=r[f._from]);for(let y=0;y<f._to.length;y++){if(!(f._to[y]>=0))throw new Error("Trying to update a removed node");f._to[y]=r[f._to[y]]}}n=0;for(let c=0;c<this._allData.length;c++)if(this._allData[c].from!==-2||this._allOutputIndices.indexOf(c+n)!==-1){if(n>0){let f=-1;this._allData[c].from!==void 0&&this._allData[c].from!==-1?(f=this._nodes[this._allData[c].from].outputs.indexOf(c+n),f!==-1&&(this._nodes[this._allData[c].from].outputs[f]=c)):(f=this._allInputIndices.indexOf(c+n),f!==-1&&(this._allInputIndices[f]=c)),this._allData[c].to.forEach(y=>{f=this._nodes[y].inputs.indexOf(c+n),f!==-1&&(this._nodes[y].inputs[f]=c)}),this._allData[c].to.length===0&&(f=this._allOutputIndices.indexOf(c+n),f!==-1&&(this._allOutputIndices[f]=c))}}else n++,this._allData.splice(c,1),c--}deleteNode(n){const r=this._nodes[n];if(r.outputs.length>1){for(let w=1;w<r.outputs.length;w++)if(this._allData[r.outputs[w]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;const i=r.inputs[0],c=r.outputs[0],f=this._allData[c].to;for(let w=0;w<r.inputs.length;w++){const x=this._allData[r.inputs[w]].to.indexOf(n);if(x===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[w]].to.splice(x,1)}this._allData[c]._to=[];const y=this._allOutputIndices.indexOf(c);if(y!==-1&&(this._allOutputIndices[y]=i),f&&f.length>0)for(const w of f){const x=this._nodes[w].inputs.indexOf(c);if(x===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[w].inputs[x]=i,this._allData[i].to.push(w)}}removeAllDropoutNodes(){let n=0;for(const r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(n)}n++}}removeAllIdentityNodes(){let n=0;for(const r of this._nodes)r.opType==="Identity"&&this.deleteNode(n),n++}isActivation(n){switch(n.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const n of this._nodes)if(n.opType==="Conv"){const r=this._allData[n.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){const i=this._nodes[r[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{n.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{n.attributes.set("activation_params","floats",[l.MIN_CLIP,l.MAX_CLIP])}else{if(!(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0))continue;n.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]])}n.attributes.set("activation","string",i.opType),this.deleteNode(r[0])}}}}},1315:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.now=u.Profiler=u.Logger=void 0;const b={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},g={none:new class{log(o,t,e){}},console:new class{log(o,t,e){console.log(`${this.color(o)} ${e?"\x1B[35m"+e+"\x1B[0m ":""}${t}`)}color(o){switch(o){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${o}`)}}}},p={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let m={"":p};function s(o,t,e,n){if(t===void 0)return r=o,{verbose:s.verbose.bind(null,r),info:s.info.bind(null,r),warning:s.warning.bind(null,r),error:s.error.bind(null,r),fatal:s.fatal.bind(null,r)};if(e===void 0)l(o,t);else if(typeof e=="number"&&n===void 0)l(o,t);else if(typeof e=="string"&&n===void 0)l(o,e,0,t);else{if(typeof e!="string"||typeof n!="number")throw new TypeError("input is valid");l(o,e,0,t)}var r}function l(o,t,e,n){const r=m[n||""]||m[""];b[o]<b[r.minimalSeverity]||(r.logDateTime&&(t=`${new Date().toISOString()}|${t}`),r.logSourceLocation,g[r.provider].log(o,t,n))}(function(o){function t(n){m={},e("",n||{})}function e(n,r){if(n==="*")t(r);else{const i=m[n]||p;m[n]={provider:r.provider||i.provider,minimalSeverity:r.minimalSeverity||i.minimalSeverity,logDateTime:r.logDateTime===void 0?i.logDateTime:r.logDateTime,logSourceLocation:r.logSourceLocation===void 0?i.logSourceLocation:r.logSourceLocation}}}o.verbose=function(n,r){o("verbose",n,r)},o.info=function(n,r){o("info",n,r)},o.warning=function(n,r){o("warning",n,r)},o.error=function(n,r){o("error",n,r)},o.fatal=function(n,r){o("fatal",n,r)},o.reset=t,o.set=e,o.setWithEnv=function(n){const r={};n.logLevel&&(r.minimalSeverity=n.logLevel),e("",r)}})(s||(s={})),u.Logger=s;class d{constructor(t,e,n,r,i,c){this.category=t,this.name=e,this.startTime=n,this.endCallback=r,this.timer=i,this.ctx=c}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class a{constructor(t,e,n,r){this.category=t,this.name=e,this.startTime=n,this.endTime=r}}u.Profiler=class{static create(o){return o===void 0?new this:new this(o.maxNumberEvents,o.flushBatchSize,o.flushIntervalInMilliseconds)}constructor(o,t,e){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=o===void 0?1e4:o,this._flushBatchSize=t===void 0?10:t,this._flushIntervalInMilliseconds=e===void 0?5e3:e}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,u.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(o,t,e,n){const r=this._started?this.begin(o,t,n):void 0;let i=!1;const c=e();if(c&&typeof c.then=="function")return i=!0,new Promise((f,y)=>{c.then(async w=>{r&&await r.end(),f(w)},async w=>{r&&await r.end(),y(w)})});if(!i&&r){const f=r.end();if(f&&typeof f.then=="function")return new Promise((y,w)=>{f.then(()=>{y(c)},x=>{w(x)})})}return c}begin(o,t,e){if(!this._started)throw new Error("profiler is not started yet");if(e===void 0){const n=(0,u.now)();return this.flush(n),new d(o,t,n,r=>this.endSync(r))}{const n=e.beginTimer();return new d(o,t,0,async r=>this.end(r),n,e)}}async end(o){const t=await o.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,t)),this.flush(t))}endSync(o){const t=(0,u.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new a(o.category,o.name,o.startTime,t)),this.flush(t))}logOneEvent(o){u.Logger.verbose(`Profiler.${o.category}`,`${(o.endTime-o.startTime).toFixed(2)}ms on event '${o.name}' at ${o.endTime.toFixed(2)}`)}flush(o){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||o-this._flushTime>=this._flushIntervalInMilliseconds){for(const t=this._flushPointer;this._flushPointer<t+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,u.now)()}}get started(){return this._started}},u.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Model=void 0;const g=b(5686),p=b(1446),m=b(4662),s=b(1287),l=b(7273);var d=s.onnxruntime.experimental.fbs;u.Model=class{constructor(){}load(a,o,t){if(!t)try{return void this.loadFromOnnxFormat(a,o)}catch(e){if(t!==void 0)throw e}this.loadFromOrtFormat(a,o)}loadFromOnnxFormat(a,o){const t=p.onnx.ModelProto.decode(a);if(l.LongUtil.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(e=>({domain:e.domain,version:l.LongUtil.longToNumber(e.version)})),this._graph=m.Graph.from(t.graph,o)}loadFromOrtFormat(a,o){const t=new g.flatbuffers.ByteBuffer(a),e=d.InferenceSession.getRootAsInferenceSession(t).model();if(l.LongUtil.longToNumber(e.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let n=0;n<e.opsetImportLength();n++){const r=e.opsetImport(n);this._opsets.push({domain:r==null?void 0:r.domain(),version:l.LongUtil.longToNumber(r.version())})}this._graph=m.Graph.from(e.graph(),o)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.FLOAT_TYPES=u.INT_TYPES=u.NUMBER_TYPES=void 0,u.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],u.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],u.FLOAT_TYPES=["float32","float64"]},5881:(v,u)=>{function b(g,p){if(p.endsWith("+")){const m=Number.parseInt(p.substring(0,p.length-1),10);return!isNaN(m)&&m<=g}if(p.split("-").length===2){const m=p.split("-"),s=Number.parseInt(m[0],10),l=Number.parseInt(m[1],10);return!isNaN(s)&&!isNaN(l)&&s<=g&&g<=l}return Number.parseInt(p,10)===g}Object.defineProperty(u,"__esModule",{value:!0}),u.resolveOperator=void 0,u.resolveOperator=function(g,p,m){for(const s of m){const l=s[0],d=s[1],a=s[2],o=s[3],t=s[4];if(g.opType===l){for(const e of p)if((e.domain===d||e.domain==="ai.onnx"&&d==="")&&b(e.version,a))return{opImpl:o,opInit:t}}}throw new TypeError(`cannot resolve operator '${g.opType}' with opsets: ${p.map(s=>`${s.domain||"ai.onnx"} v${s.version}`).join(", ")}`)}},1287:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.onnxruntime=void 0;const g=b(5686);var p,m;p=u.onnxruntime||(u.onnxruntime={}),function(s){(function(l){l[l.UNDEFINED=0]="UNDEFINED",l[l.FLOAT=1]="FLOAT",l[l.INT=2]="INT",l[l.STRING=3]="STRING",l[l.TENSOR=4]="TENSOR",l[l.GRAPH=5]="GRAPH",l[l.FLOATS=6]="FLOATS",l[l.INTS=7]="INTS",l[l.STRINGS=8]="STRINGS",l[l.TENSORS=9]="TENSORS",l[l.GRAPHS=10]="GRAPHS",l[l.SPARSE_TENSOR=11]="SPARSE_TENSOR",l[l.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(s.AttributeType||(s.AttributeType={}))}((m=p.experimental||(p.experimental={})).fbs||(m.fbs={})),function(s){(function(l){(function(d){(function(a){a[a.UNKNOWN=0]="UNKNOWN",a[a.VALUE=1]="VALUE",a[a.PARAM=2]="PARAM"})(d.DimensionValueType||(d.DimensionValueType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){(function(a){a[a.UNDEFINED=0]="UNDEFINED",a[a.FLOAT=1]="FLOAT",a[a.UINT8=2]="UINT8",a[a.INT8=3]="INT8",a[a.UINT16=4]="UINT16",a[a.INT16=5]="INT16",a[a.INT32=6]="INT32",a[a.INT64=7]="INT64",a[a.STRING=8]="STRING",a[a.BOOL=9]="BOOL",a[a.FLOAT16=10]="FLOAT16",a[a.DOUBLE=11]="DOUBLE",a[a.UINT32=12]="UINT32",a[a.UINT64=13]="UINT64",a[a.COMPLEX64=14]="COMPLEX64",a[a.COMPLEX128=15]="COMPLEX128",a[a.BFLOAT16=16]="BFLOAT16"})(d.TensorDataType||(d.TensorDataType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){(function(a){a[a.Primitive=0]="Primitive",a[a.Fused=1]="Fused"})(d.NodeType||(d.NodeType={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){(function(a){a[a.NONE=0]="NONE",a[a.tensor_type=1]="tensor_type",a[a.sequence_type=2]="sequence_type",a[a.map_type=3]="map_type"})(d.TypeInfoValue||(d.TypeInfoValue={}))})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsShape(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsShape(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}dim(t,e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new s.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}dimLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startShape(t){t.startObject(1)}static addDim(t,e){t.addFieldOffset(0,e,0)}static createDimVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startDimVector(t,e){t.startVector(4,e,4)}static endShape(t){return t.endObject()}static createShape(t,e){return a.startShape(t),a.addDim(t,e),a.endShape(t)}}d.Shape=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimension(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimension(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}value(t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new s.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}denotation(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimension(t){t.startObject(2)}static addValue(t,e){t.addFieldOffset(0,e,0)}static addDenotation(t,e){t.addFieldOffset(1,e,0)}static endDimension(t){return t.endObject()}static createDimension(t,e,n){return a.startDimension(t),a.addValue(t,e),a.addDenotation(t,n),a.endDimension(t)}}d.Dimension=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsDimensionValue(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsDimensionValue(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):s.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}dimParam(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}static startDimensionValue(t){t.startObject(3)}static addDimType(t,e){t.addFieldInt8(0,e,s.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static addDimParam(t,e){t.addFieldOffset(2,e,0)}static endDimensionValue(t){return t.endObject()}static createDimensionValue(t,e,n,r){return a.startDimensionValue(t),a.addDimType(t,e),a.addDimValue(t,n),a.addDimParam(t,r),a.endDimensionValue(t)}}d.DimensionValue=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensorTypeAndShape(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensorTypeAndShape(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):s.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new s.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startTensorTypeAndShape(t){t.startObject(2)}static addElemType(t,e){t.addFieldInt32(0,e,s.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(t,e){t.addFieldOffset(1,e,0)}static endTensorTypeAndShape(t){return t.endObject()}static createTensorTypeAndShape(t,e,n){return a.startTensorTypeAndShape(t),a.addElemType(t,e),a.addShape(t,n),a.endTensorTypeAndShape(t)}}d.TensorTypeAndShape=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsMapType(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsMapType(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):s.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startMapType(t){t.startObject(2)}static addKeyType(t,e){t.addFieldInt32(0,e,s.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(t,e){t.addFieldOffset(1,e,0)}static endMapType(t){return t.endObject()}static createMapType(t,e,n){return a.startMapType(t),a.addKeyType(t,e),a.addValueType(t,n),a.endMapType(t)}}d.MapType=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSequenceType(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSequenceType(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}elemType(t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSequenceType(t){t.startObject(1)}static addElemType(t,e){t.addFieldOffset(0,e,0)}static endSequenceType(t){return t.endObject()}static createSequenceType(t,e){return a.startSequenceType(t),a.addElemType(t,e),a.endSequenceType(t)}}d.SequenceType=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(l.fbs||(l.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(d,a){return this.bb_pos=d,this.bb=a,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(d,a,o,t){return d.prep(4,12),d.writeInt32(t),d.writeInt32(o),d.writeInt32(a),d.offset()}}})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNodeEdge(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNodeEdge(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}nodeIndex(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}inputEdges(t,e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new s.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*t,this.bb):null}inputEdgesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}outputEdges(t,e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new s.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*t,this.bb):null}outputEdgesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNodeEdge(t){t.startObject(3)}static addNodeIndex(t,e){t.addFieldInt32(0,e,0)}static addInputEdges(t,e){t.addFieldOffset(1,e,0)}static startInputEdgesVector(t,e){t.startVector(12,e,4)}static addOutputEdges(t,e){t.addFieldOffset(2,e,0)}static startOutputEdgesVector(t,e){t.startVector(12,e,4)}static endNodeEdge(t){return t.endObject()}static createNodeEdge(t,e,n,r){return a.startNodeEdge(t),a.addNodeIndex(t,e),a.addInputEdges(t,n),a.addOutputEdges(t,r),a.endNodeEdge(t)}}d.NodeEdge=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsNode(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsNode(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}sinceVersion(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):0}index(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint32(this.bb_pos+t):0}opType(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):s.experimental.fbs.NodeType.Primitive}executionProviderType(t){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__string(this.bb_pos+e,t):null}inputs(t,e){let n=this.bb.__offset(this.bb_pos,20);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,22);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}attributes(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?(e||new s.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}attributesLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCounts(t){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}inputArgCountsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}inputArgCountsArray(){let t=this.bb.__offset(this.bb_pos,26);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}implicitInputs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}implicitInputsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startNode(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDomain(t,e){t.addFieldOffset(2,e,0)}static addSinceVersion(t,e){t.addFieldInt32(3,e,0)}static addIndex(t,e){t.addFieldInt32(4,e,0)}static addOpType(t,e){t.addFieldOffset(5,e,0)}static addType(t,e){t.addFieldInt32(6,e,s.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(t,e){t.addFieldOffset(7,e,0)}static addInputs(t,e){t.addFieldOffset(8,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(9,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addAttributes(t,e){t.addFieldOffset(10,e,0)}static createAttributesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startAttributesVector(t,e){t.startVector(4,e,4)}static addInputArgCounts(t,e){t.addFieldOffset(11,e,0)}static createInputArgCountsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startInputArgCountsVector(t,e){t.startVector(4,e,4)}static addImplicitInputs(t,e){t.addFieldOffset(12,e,0)}static createImplicitInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startImplicitInputsVector(t,e){t.startVector(4,e,4)}static endNode(t){return t.endObject()}static createNode(t,e,n,r,i,c,f,y,w,x,_,S,I,O){return a.startNode(t),a.addName(t,e),a.addDocString(t,n),a.addDomain(t,r),a.addSinceVersion(t,i),a.addIndex(t,c),a.addOpType(t,f),a.addType(t,y),a.addExecutionProviderType(t,w),a.addInputs(t,x),a.addOutputs(t,_),a.addAttributes(t,S),a.addInputArgCounts(t,I),a.addImplicitInputs(t,O),a.endNode(t)}}d.Node=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsValueInfo(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsValueInfo(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(t){let e=this.bb.__offset(this.bb_pos,8);return e?(t||new s.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startValueInfo(t){t.startObject(3)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldOffset(2,e,0)}static endValueInfo(t){return t.endObject()}static createValueInfo(t,e,n,r){return a.startValueInfo(t),a.addName(t,e),a.addDocString(t,n),a.addType(t,r),a.endValueInfo(t)}}d.ValueInfo=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTypeInfo(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTypeInfo(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}denotation(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):s.experimental.fbs.TypeInfoValue.NONE}value(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__union(t,this.bb_pos+e):null}static startTypeInfo(t){t.startObject(3)}static addDenotation(t,e){t.addFieldOffset(0,e,0)}static addValueType(t,e){t.addFieldInt8(1,e,s.experimental.fbs.TypeInfoValue.NONE)}static addValue(t,e){t.addFieldOffset(2,e,0)}static endTypeInfo(t){return t.endObject()}static createTypeInfo(t,e,n,r){return a.startTypeInfo(t),a.addDenotation(t,e),a.addValueType(t,n),a.addValue(t,r),a.endTypeInfo(t)}}d.TypeInfo=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsOperatorSetId(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsOperatorSetId(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}domain(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}version(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}static startOperatorSetId(t){t.startObject(2)}static addDomain(t,e){t.addFieldOffset(0,e,0)}static addVersion(t,e){t.addFieldInt64(1,e,t.createLong(0,0))}static endOperatorSetId(t){return t.endObject()}static createOperatorSetId(t,e,n){return a.startOperatorSetId(t),a.addDomain(t,e),a.addVersion(t,n),a.endOperatorSetId(t)}}d.OperatorSetId=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsTensor(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsTensor(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):s.experimental.fbs.TensorDataType.UNDEFINED}rawData(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint8(this.bb.__vector(this.bb_pos+e)+t):0}rawDataLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}rawDataArray(){let t=this.bb.__offset(this.bb_pos,12);return t?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}stringData(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringDataLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}static startTensor(t){t.startObject(6)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static addDataType(t,e){t.addFieldInt32(3,e,s.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(t,e){t.addFieldOffset(4,e,0)}static createRawDataVector(t,e){t.startVector(1,e.length,1);for(let n=e.length-1;n>=0;n--)t.addInt8(e[n]);return t.endVector()}static startRawDataVector(t,e){t.startVector(1,e,1)}static addStringData(t,e){t.addFieldOffset(5,e,0)}static createStringDataVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringDataVector(t,e){t.startVector(4,e,4)}static endTensor(t){return t.endObject()}static createTensor(t,e,n,r,i,c,f){return a.startTensor(t),a.addName(t,e),a.addDocString(t,n),a.addDims(t,r),a.addDataType(t,i),a.addRawData(t,c),a.addStringData(t,f),a.endTensor(t)}}d.Tensor=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSparseTensor(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSparseTensor(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}values(t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}indices(t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}dims(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}dimsLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSparseTensor(t){t.startObject(3)}static addValues(t,e){t.addFieldOffset(0,e,0)}static addIndices(t,e){t.addFieldOffset(1,e,0)}static addDims(t,e){t.addFieldOffset(2,e,0)}static createDimsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startDimsVector(t,e){t.startVector(8,e,8)}static endSparseTensor(t){return t.endObject()}static createSparseTensor(t,e,n,r){return a.startSparseTensor(t),a.addValues(t,e),a.addIndices(t,n),a.addDims(t,r),a.endSparseTensor(t)}}d.SparseTensor=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAttribute(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsAttribute(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}name(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}docString(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):s.experimental.fbs.AttributeType.UNDEFINED}f(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}i(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}s(t){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__string(this.bb_pos+e,t):null}t(t){let e=this.bb.__offset(this.bb_pos,16);return e?(t||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}g(t){let e=this.bb.__offset(this.bb_pos,18);return e?(t||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}floats(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}floatsLength(){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}floatsArray(){let t=this.bb.__offset(this.bb_pos,20);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ints(t){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.readInt64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}intsLength(){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.__vector_len(this.bb_pos+t):0}strings(t,e){let n=this.bb.__offset(this.bb_pos,24);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}stringsLength(){let t=this.bb.__offset(this.bb_pos,24);return t?this.bb.__vector_len(this.bb_pos+t):0}tensors(t,e){let n=this.bb.__offset(this.bb_pos,26);return n?(e||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}tensorsLength(){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.__vector_len(this.bb_pos+t):0}graphs(t,e){let n=this.bb.__offset(this.bb_pos,28);return n?(e||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}graphsLength(){let t=this.bb.__offset(this.bb_pos,28);return t?this.bb.__vector_len(this.bb_pos+t):0}static startAttribute(t){t.startObject(13)}static addName(t,e){t.addFieldOffset(0,e,0)}static addDocString(t,e){t.addFieldOffset(1,e,0)}static addType(t,e){t.addFieldInt32(2,e,s.experimental.fbs.AttributeType.UNDEFINED)}static addF(t,e){t.addFieldFloat32(3,e,0)}static addI(t,e){t.addFieldInt64(4,e,t.createLong(0,0))}static addS(t,e){t.addFieldOffset(5,e,0)}static addT(t,e){t.addFieldOffset(6,e,0)}static addG(t,e){t.addFieldOffset(7,e,0)}static addFloats(t,e){t.addFieldOffset(8,e,0)}static createFloatsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addFloat32(e[n]);return t.endVector()}static startFloatsVector(t,e){t.startVector(4,e,4)}static addInts(t,e){t.addFieldOffset(9,e,0)}static createIntsVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startIntsVector(t,e){t.startVector(8,e,8)}static addStrings(t,e){t.addFieldOffset(10,e,0)}static createStringsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startStringsVector(t,e){t.startVector(4,e,4)}static addTensors(t,e){t.addFieldOffset(11,e,0)}static createTensorsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startTensorsVector(t,e){t.startVector(4,e,4)}static addGraphs(t,e){t.addFieldOffset(12,e,0)}static createGraphsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startGraphsVector(t,e){t.startVector(4,e,4)}static endAttribute(t){return t.endObject()}static createAttribute(t,e,n,r,i,c,f,y,w,x,_,S,I,O){return a.startAttribute(t),a.addName(t,e),a.addDocString(t,n),a.addType(t,r),a.addF(t,i),a.addI(t,c),a.addS(t,f),a.addT(t,y),a.addG(t,w),a.addFloats(t,x),a.addInts(t,_),a.addStrings(t,S),a.addTensors(t,I),a.addGraphs(t,O),a.endAttribute(t)}}d.Attribute=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsGraph(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsGraph(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}initializers(t,e){let n=this.bb.__offset(this.bb_pos,4);return n?(e||new s.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}initializersLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeArgs(t,e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new s.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodeArgsLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}nodes(t,e){let n=this.bb.__offset(this.bb_pos,8);return n?(e||new s.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodesLength(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}maxNodeIndex(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readUint32(this.bb_pos+t):0}nodeEdges(t,e){let n=this.bb.__offset(this.bb_pos,12);return n?(e||new s.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodeEdgesLength(){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}inputs(t,e){let n=this.bb.__offset(this.bb_pos,14);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}inputsLength(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}outputs(t,e){let n=this.bb.__offset(this.bb_pos,16);return n?this.bb.__string(this.bb.__vector(this.bb_pos+n)+4*t,e):null}outputsLength(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}sparseInitializers(t,e){let n=this.bb.__offset(this.bb_pos,18);return n?(e||new s.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}sparseInitializersLength(){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}static startGraph(t){t.startObject(8)}static addInitializers(t,e){t.addFieldOffset(0,e,0)}static createInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInitializersVector(t,e){t.startVector(4,e,4)}static addNodeArgs(t,e){t.addFieldOffset(1,e,0)}static createNodeArgsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeArgsVector(t,e){t.startVector(4,e,4)}static addNodes(t,e){t.addFieldOffset(2,e,0)}static createNodesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodesVector(t,e){t.startVector(4,e,4)}static addMaxNodeIndex(t,e){t.addFieldInt32(3,e,0)}static addNodeEdges(t,e){t.addFieldOffset(4,e,0)}static createNodeEdgesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startNodeEdgesVector(t,e){t.startVector(4,e,4)}static addInputs(t,e){t.addFieldOffset(5,e,0)}static createInputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startInputsVector(t,e){t.startVector(4,e,4)}static addOutputs(t,e){t.addFieldOffset(6,e,0)}static createOutputsVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOutputsVector(t,e){t.startVector(4,e,4)}static addSparseInitializers(t,e){t.addFieldOffset(7,e,0)}static createSparseInitializersVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSparseInitializersVector(t,e){t.startVector(4,e,4)}static endGraph(t){return t.endObject()}static createGraph(t,e,n,r,i,c,f,y,w){return a.startGraph(t),a.addInitializers(t,e),a.addNodeArgs(t,n),a.addNodes(t,r),a.addMaxNodeIndex(t,i),a.addNodeEdges(t,c),a.addInputs(t,f),a.addOutputs(t,y),a.addSparseInitializers(t,w),a.endGraph(t)}}d.Graph=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsModel(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsModel(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}irVersion(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}opsetImport(t,e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new s.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}opsetImportLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}producerName(t){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__string(this.bb_pos+e,t):null}producerVersion(t){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.__string(this.bb_pos+e,t):null}domain(t){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__string(this.bb_pos+e,t):null}modelVersion(){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.readInt64(this.bb_pos+t):this.bb.createLong(0,0)}docString(t){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__string(this.bb_pos+e,t):null}graph(t){let e=this.bb.__offset(this.bb_pos,18);return e?(t||new s.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}graphDocString(t){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}static startModel(t){t.startObject(9)}static addIrVersion(t,e){t.addFieldInt64(0,e,t.createLong(0,0))}static addOpsetImport(t,e){t.addFieldOffset(1,e,0)}static createOpsetImportVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startOpsetImportVector(t,e){t.startVector(4,e,4)}static addProducerName(t,e){t.addFieldOffset(2,e,0)}static addProducerVersion(t,e){t.addFieldOffset(3,e,0)}static addDomain(t,e){t.addFieldOffset(4,e,0)}static addModelVersion(t,e){t.addFieldInt64(5,e,t.createLong(0,0))}static addDocString(t,e){t.addFieldOffset(6,e,0)}static addGraph(t,e){t.addFieldOffset(7,e,0)}static addGraphDocString(t,e){t.addFieldOffset(8,e,0)}static endModel(t){return t.endObject()}static createModel(t,e,n,r,i,c,f,y,w,x){return a.startModel(t),a.addIrVersion(t,e),a.addOpsetImport(t,n),a.addProducerName(t,r),a.addProducerVersion(t,i),a.addDomain(t,c),a.addModelVersion(t,f),a.addDocString(t,y),a.addGraph(t,w),a.addGraphDocString(t,x),a.endModel(t)}}d.Model=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsKernelCreateInfos(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsKernelCreateInfos(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}nodeIndices(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}nodeIndicesLength(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}nodeIndicesArray(){let t=this.bb.__offset(this.bb_pos,4);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}kernelDefHashes(t){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readUint64(this.bb.__vector(this.bb_pos+e)+8*t):this.bb.createLong(0,0)}kernelDefHashesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startKernelCreateInfos(t){t.startObject(2)}static addNodeIndices(t,e){t.addFieldOffset(0,e,0)}static createNodeIndicesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addInt32(e[n]);return t.endVector()}static startNodeIndicesVector(t,e){t.startVector(4,e,4)}static addKernelDefHashes(t,e){t.addFieldOffset(1,e,0)}static createKernelDefHashesVector(t,e){t.startVector(8,e.length,8);for(let n=e.length-1;n>=0;n--)t.addInt64(e[n]);return t.endVector()}static startKernelDefHashesVector(t,e){t.startVector(8,e,8)}static endKernelCreateInfos(t){return t.endObject()}static createKernelCreateInfos(t,e,n){return a.startKernelCreateInfos(t),a.addNodeIndices(t,e),a.addKernelDefHashes(t,n),a.endKernelCreateInfos(t)}}d.KernelCreateInfos=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSubGraphSessionState(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSubGraphSessionState(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}graphId(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}sessionState(t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new s.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startSubGraphSessionState(t){t.startObject(2)}static addGraphId(t,e){t.addFieldOffset(0,e,0)}static addSessionState(t,e){t.addFieldOffset(1,e,0)}static endSubGraphSessionState(t){let e=t.endObject();return t.requiredField(e,4),e}static createSubGraphSessionState(t,e,n){return a.startSubGraphSessionState(t),a.addGraphId(t,e),a.addSessionState(t,n),a.endSubGraphSessionState(t)}}d.SubGraphSessionState=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsSessionState(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsSessionState(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}kernels(t){let e=this.bb.__offset(this.bb_pos,4);return e?(t||new s.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}subGraphSessionStates(t,e){let n=this.bb.__offset(this.bb_pos,6);return n?(e||new s.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}subGraphSessionStatesLength(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}static startSessionState(t){t.startObject(2)}static addKernels(t,e){t.addFieldOffset(0,e,0)}static addSubGraphSessionStates(t,e){t.addFieldOffset(1,e,0)}static createSubGraphSessionStatesVector(t,e){t.startVector(4,e.length,4);for(let n=e.length-1;n>=0;n--)t.addOffset(e[n]);return t.endVector()}static startSubGraphSessionStatesVector(t,e){t.startVector(4,e,4)}static endSessionState(t){return t.endObject()}static createSessionState(t,e,n){return a.startSessionState(t),a.addKernels(t,e),a.addSubGraphSessionStates(t,n),a.endSessionState(t)}}d.SessionState=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={})),function(s){(function(l){(function(d){class a{constructor(){this.bb=null,this.bb_pos=0}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsInferenceSession(t,e){return(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsInferenceSession(t,e){return t.setPosition(t.position()+g.flatbuffers.SIZE_PREFIX_LENGTH),(e||new a).__init(t.readInt32(t.position())+t.position(),t)}static bufferHasIdentifier(t){return t.__has_identifier("ORTM")}ortVersion(t){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__string(this.bb_pos+e,t):null}model(t){let e=this.bb.__offset(this.bb_pos,6);return e?(t||new s.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}sessionState(t){let e=this.bb.__offset(this.bb_pos,8);return e?(t||new s.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}static startInferenceSession(t){t.startObject(3)}static addOrtVersion(t,e){t.addFieldOffset(0,e,0)}static addModel(t,e){t.addFieldOffset(1,e,0)}static addSessionState(t,e){t.addFieldOffset(2,e,0)}static endInferenceSession(t){return t.endObject()}static finishInferenceSessionBuffer(t,e){t.finish(e,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(t,e){t.finish(e,"ORTM",!0)}static createInferenceSession(t,e,n,r){return a.startInferenceSession(t),a.addOrtVersion(t,e),a.addModel(t,n),a.addSessionState(t,r),a.endInferenceSession(t)}}d.InferenceSession=a})(l.fbs||(l.fbs={}))})(s.experimental||(s.experimental={}))}(u.onnxruntime||(u.onnxruntime={}))},1723:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.OnnxjsSessionHandler=void 0;const g=b(8453),p=b(9240);u.OnnxjsSessionHandler=class{constructor(m){this.session=m,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(m,s,l){const d=new Map;for(const t in m)if(Object.hasOwnProperty.call(m,t)){const e=m[t];d.set(t,new p.Tensor(e.dims,e.type,void 0,void 0,e.data))}const a=await this.session.run(d),o={};return a.forEach((t,e)=>{o[e]=new g.Tensor(t.type,t.data,t.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.Session=void 0;const g=b(7067),p=b(1296),m=b(1975),s=b(6496),l=b(1315),d=b(1745);u.Session=class{constructor(a={}){this._initialized=!1,this.backendHint=a.backendHint,this.profiler=l.Profiler.create(a.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(a,o,t){await this.profiler.event("session","Session.loadModel",async()=>{const e=await(0,m.resolveBackend)(this.backendHint);if(this.sessionHandler=e.createSessionHandler(this.context),this._model=new d.Model,typeof a=="string"){const n=a.endsWith(".ort");if(typeof fetch>"u"){const r=await(0,p.promisify)(g.readFile)(a);this.initialize(r,n)}else{const r=await fetch(a),i=await r.arrayBuffer();this.initialize(new Uint8Array(i),n)}}else if(ArrayBuffer.isView(a))this.initialize(a);else{const n=new Uint8Array(a,o||0,t||a.byteLength);this.initialize(n)}})}initialize(a,o){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(a,t,o),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new s.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(a){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const o=this.normalizeAndValidateInputs(a),t=await this._executionPlan.execute(this.sessionHandler,o);return this.createOutput(t)})}normalizeAndValidateInputs(a){const o=this._model.graph.getInputNames();if(Array.isArray(a)){if(a.length!==o.length)throw new Error(`incorrect input array length: expected ${o.length} but got ${a.length}`)}else{if(a.size!==o.length)throw new Error(`incorrect input map size: expected ${o.length} but got ${a.size}`);const t=new Array(a.size);let e=0;for(let n=0;n<o.length;++n){const r=a.get(o[n]);if(!r)throw new Error(`missing input tensor for: '${name}'`);t[e++]=r}a=t}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,a,!1);else{const t=this._model.graph.getInputIndices(),e=this._model.graph.getValues(),n=new Array(t.length);for(let r=0;r<t.length;++r){const i=e[t[r]];n[r]=i.type.shape.dims,this.context.graphInputTypes.push(i.type.tensorType),this.context.graphInputDims.push(a[r].dims)}this.validateInputTensorDims(n,a,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,a),a}validateInputTensorTypes(a,o){for(let t=0;t<o.length;t++){const e=a[t],n=o[t].type;if(e!==n)throw new Error(`input tensor[${t}] check failed: expected type '${e}' but got ${n}`)}}validateInputTensorDims(a,o,t){for(let e=0;e<o.length;e++){const n=a[e],r=o[e].dims;if(!this.compareTensorDims(n,r,t))throw new Error(`input tensor[${e}] check failed: expected shape '[${n.join(",")}]' but got [${r.join(",")}]`)}}compareTensorDims(a,o,t){if(a.length!==o.length)return!1;for(let e=0;e<a.length;++e)if(a[e]!==o[e]&&(!t||a[e]!==0))return!1;return!0}createOutput(a){const o=this._model.graph.getOutputNames();if(a.length!==o.length)throw new Error("expected number of outputs do not match number of generated outputs");const t=new Map;for(let e=0;e<o.length;++e)t.set(o[e],a[e]);return t}initializeOps(a){const o=a.getNodes();this._ops=new Array(o.length);for(let t=0;t<o.length;t++)this._ops[t]=this.sessionHandler.resolve(o[t],this._model.opsets,a)}}},9240:function(v,u,b){var g=this&&this.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(u,"__esModule",{value:!0}),u.Tensor=void 0;const p=b(3442),m=g(b(3720)),s=b(1446),l=b(1287),d=b(7273);var a=l.onnxruntime.experimental.fbs;class o{get data(){if(this.cache===void 0){const c=this.dataProvider(this.dataId);if(c.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=c}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(c){return this.data[d.ShapeUtil.indicesToOffset(c,this.strides)]}set(c,f){this.data[d.ShapeUtil.indicesToOffset(c,this.strides)]=f}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=d.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(c,f,y,w,x,_=p.Guid.create()){this.dims=c,this.type=f,this.dataProvider=y,this.asyncDataProvider=w,this.cache=x,this.dataId=_,this.size=d.ShapeUtil.validateDimsAndCalcSize(c);const S=this.size,I=y===void 0&&w===void 0&&x===void 0;if(x!==void 0&&x.length!==S)throw new RangeError("Input dims doesn't match data length.");if(f==="string"){if(!(x===void 0||Array.isArray(x)&&x.every(O=>typeof O=="string")))throw new TypeError("cache should be a string array");I&&(this.cache=new Array(S))}else{if(x!==void 0){const O=e(f);if(!(x instanceof O))throw new TypeError(`cache should be type ${O.name}`)}if(I){const O=new ArrayBuffer(S*function(T){switch(T){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${T}`)}}(f));this.cache=function(T,A){return new(e(A))(T)}(O,f)}}}static fromProto(c){if(!c)throw new Error("cannot construct Value from an empty tensor");const f=d.ProtoUtil.tensorDataTypeFromProto(c.dataType),y=d.ProtoUtil.tensorDimsFromProto(c.dims),w=new o(y,f);if(f==="string")c.stringData.forEach((x,_)=>{w.data[_]=(0,d.decodeUtf8String)(x)});else if(c.rawData&&typeof c.rawData.byteLength=="number"&&c.rawData.byteLength>0){const x=w.data,_=new DataView(c.rawData.buffer,c.rawData.byteOffset,c.rawData.byteLength),S=t(c.dataType),I=c.rawData.byteLength/S;if(c.rawData.byteLength%S!=0)throw new Error("invalid buffer length");if(x.length!==I)throw new Error("buffer length mismatch");for(let O=0;O<I;O++){const T=r(_,c.dataType,O*S);x[O]=T}}else{let x;switch(c.dataType){case s.onnx.TensorProto.DataType.FLOAT:x=c.floatData;break;case s.onnx.TensorProto.DataType.INT32:case s.onnx.TensorProto.DataType.INT16:case s.onnx.TensorProto.DataType.UINT16:case s.onnx.TensorProto.DataType.INT8:case s.onnx.TensorProto.DataType.UINT8:case s.onnx.TensorProto.DataType.BOOL:x=c.int32Data;break;case s.onnx.TensorProto.DataType.INT64:x=c.int64Data;break;case s.onnx.TensorProto.DataType.DOUBLE:x=c.doubleData;break;case s.onnx.TensorProto.DataType.UINT32:case s.onnx.TensorProto.DataType.UINT64:x=c.uint64Data;break;default:throw new Error("unspecific error")}if(x==null)throw new Error("failed to populate data from a tensorproto value");const _=w.data;if(_.length!==x.length)throw new Error("array length mismatch");for(let S=0;S<x.length;S++){const I=x[S];m.default.isLong(I)?_[S]=n(I,c.dataType):_[S]=I}}return w}static fromData(c,f,y){return new o(f,y,void 0,void 0,c)}static fromOrtTensor(c){if(!c)throw new Error("cannot construct Value from an empty tensor");const f=d.ProtoUtil.tensorDimsFromORTFormat(c),y=d.ProtoUtil.tensorDataTypeFromProto(c.dataType()),w=new o(f,y);if(y==="string")for(let x=0;x<c.stringDataLength();x++)w.data[x]=c.stringData(x);else if(c.rawDataArray()&&typeof c.rawDataLength()=="number"&&c.rawDataLength()>0){const x=w.data,_=new DataView(c.rawDataArray().buffer,c.rawDataArray().byteOffset,c.rawDataLength()),S=t(c.dataType()),I=c.rawDataLength()/S;if(c.rawDataLength()%S!=0)throw new Error("invalid buffer length");if(x.length!==I)throw new Error("buffer length mismatch");for(let O=0;O<I;O++){const T=r(_,c.dataType(),O*S);x[O]=T}}return w}}function t(i){switch(i){case s.onnx.TensorProto.DataType.UINT8:case s.onnx.TensorProto.DataType.INT8:case s.onnx.TensorProto.DataType.BOOL:return 1;case s.onnx.TensorProto.DataType.UINT16:case s.onnx.TensorProto.DataType.INT16:return 2;case s.onnx.TensorProto.DataType.FLOAT:case s.onnx.TensorProto.DataType.INT32:case s.onnx.TensorProto.DataType.UINT32:return 4;case s.onnx.TensorProto.DataType.INT64:case s.onnx.TensorProto.DataType.DOUBLE:case s.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${s.onnx.TensorProto.DataType[i]}`)}}function e(i){switch(i){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function n(i,c){if(c===s.onnx.TensorProto.DataType.INT64||c===a.TensorDataType.INT64){if(i.greaterThanOrEqual(2147483648)||i.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(c!==s.onnx.TensorProto.DataType.UINT32&&c!==a.TensorDataType.UINT32&&c!==s.onnx.TensorProto.DataType.UINT64&&c!==a.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${s.onnx.TensorProto.DataType[c]}`);if(i.greaterThanOrEqual(4294967296)||i.lessThan(0))throw new TypeError("uint64 is not supported")}return i.toNumber()}function r(i,c,f){switch(c){case s.onnx.TensorProto.DataType.BOOL:case s.onnx.TensorProto.DataType.UINT8:return i.getUint8(f);case s.onnx.TensorProto.DataType.INT8:return i.getInt8(f);case s.onnx.TensorProto.DataType.UINT16:return i.getUint16(f,!0);case s.onnx.TensorProto.DataType.INT16:return i.getInt16(f,!0);case s.onnx.TensorProto.DataType.FLOAT:return i.getFloat32(f,!0);case s.onnx.TensorProto.DataType.INT32:return i.getInt32(f,!0);case s.onnx.TensorProto.DataType.UINT32:return i.getUint32(f,!0);case s.onnx.TensorProto.DataType.INT64:return n(m.default.fromBits(i.getUint32(f,!0),i.getUint32(f+4,!0),!1),c);case s.onnx.TensorProto.DataType.DOUBLE:return i.getFloat64(f,!0);case s.onnx.TensorProto.DataType.UINT64:return n(m.default.fromBits(i.getUint32(f,!0),i.getUint32(f+4,!0),!0),c);default:throw new Error(`cannot read from DataView for type ${s.onnx.TensorProto.DataType[c]}`)}}u.Tensor=o},7273:function(v,u,b){var g=this&&this.__importDefault||function(c){return c&&c.__esModule?c:{default:c}};Object.defineProperty(u,"__esModule",{value:!0}),u.decodeUtf8String=u.MAX_CLIP=u.MIN_CLIP=u.PoolConvUtil=u.ReduceUtil=u.SplitUtil=u.MathUtil=u.ShapeUtil=u.LongUtil=u.ProtoUtil=u.GemmUtil=u.arrayCopyHelper=u.BroadcastUtil=u.MatMulUtil=u.ArrayUtil=u.assert=u.checkInputsShape=void 0;const p=b(5686),m=g(b(3720)),s=b(1446),l=b(9240);u.checkInputsShape=function(c,...f){if(!c||c.length!==f.length)return!1;for(let y=0;y<c.length;y++)if(!c[y].dims||c[y].dims.length!==f[y])return!1;return!0},u.assert=function(c,f){if(!c)throw new Error(typeof f=="string"?f:f())},u.ArrayUtil=class{static arraysEqual(c,f){if(c.length!==f.length)return!1;for(let y=0;y<c.length;y++)if(c[y]!==f[y])return!1;return!0}};class d{static preprocessInputShapes(f,y){return[f.length===1?[1,f[0]]:f,y.length===1?[y[0],1]:y]}static postprocessOutputShape(f,y,w){y===1&&f.splice(f.length-2,1),w===1&&f.pop()}static calcMatMulShape(f,y){return f[1]!==y[0]?void 0:[f[0],y[1]]}}u.MatMulUtil=d;class a{static calcShape(f,y,w=!1){const x=f.length,_=y.length;if(x===0)return y;if(_===0)return f;const S=Math.max(f.length,y.length),I=new Array(S);if(w){if(x<2||_<2)return;const O=d.calcMatMulShape([f[x-2],f[x-1]],[y[_-2],y[_-1]]);if(O===void 0)return;[I[S-2],I[S-1]]=O}for(let O=w?3:1;O<=S;O++){const T=x-O<0?1:f[x-O],A=_-O<0?1:y[_-O];if(T!==A&&T>1&&A>1)return;I[S-O]=Math.max(T,A)}return I}static index(f,y){const w=new Array(y.length);return a.fillIndex(f,y,w),w}static fillIndex(f,y,w){const x=f.length-y.length;for(let _=0;_<y.length;_++)w[_]=f[x+_]%y[_]}static calc(f,y,w,x,_){const S=a.calcShape(f.dims,y.dims);if(S){if(x&&!e.areEqual(S,f.dims))return;const I=e.size(S),O=x?f:new l.Tensor(S,_||f.type);if(S.length===0)O.set([],w(f.get([]),y.get([])));else{const T=new Array(S.length),A=new Array(f.dims.length),P=new Array(y.dims.length);let R,D=0,$=0,M=!1,C=!1;f.dims.length===0&&(D=f.get([]),M=!0),y.dims.length===0&&($=y.get([]),C=!0);for(let k=0;k<I;k++){R=k;for(let z=S.length-1;z>=0;z--)T[z]=R%S[z],R=Math.floor(R/S[z]);M||(a.fillIndex(T,f.dims,A),D=f.get(A)),C||(a.fillIndex(T,y.dims,P),$=y.get(P)),O.set(T,w(D,$))}}return O}}static isValidBroadcast(f,y){const w=f.length,x=y.length;if(w>x)return!1;for(let _=1;_<=w;_++)if(f[w-_]!==1&&f[w-_]!==y[x-_])return!1;return!0}static getBroadcastDims(f,y){const w=f.length,x=[];for(let _=0;_<w;_++){const S=w-1-_,I=f[S]||1;(y[y.length-1-_]||1)>1&&I===1&&x.unshift(S)}return x}}u.BroadcastUtil=a,u.arrayCopyHelper=function(c,f,y,w,x){if(w<0||w>=f.length)throw new Error("sourceIndex out of bounds");if(y<0||y>=c.length)throw new Error("targetIndex out of bounds");if(w+x>f.length)throw new Error("source indices to be copied are outside bounds");if(y+x>c.length)throw new Error("target array is too small to hold result");for(let _=0;_<x;_++)c[y+_]=f[w+_]},u.GemmUtil=class{static getShapeOfGemmResult(c,f,y,w,x){if(c.length!==2||y.length!==2)throw new Error("shape need to be of size 2");let _,S,I;f?(_=c[1],S=c[0]):(_=c[0],S=c[1]);let O=-1;if(w?(I=y[0],O=1):(I=y[1],O=0),y[O]!==S)throw new Error("dimension mismatch");if(_<=0||I<=0||S<=0)throw new Error("invalid shape specified");if(x&&!a.isValidBroadcast(x,[_,I]))throw new Error("gemm: invalid bias shape for broadcast");return[_,I,S]}};class o{static tensorDataTypeFromProto(f){switch(f){case s.onnx.TensorProto.DataType.INT8:return"int8";case s.onnx.TensorProto.DataType.UINT8:return"uint8";case s.onnx.TensorProto.DataType.BOOL:return"bool";case s.onnx.TensorProto.DataType.INT16:return"int16";case s.onnx.TensorProto.DataType.UINT16:return"uint16";case s.onnx.TensorProto.DataType.INT32:return"int32";case s.onnx.TensorProto.DataType.UINT32:return"uint32";case s.onnx.TensorProto.DataType.FLOAT:return"float32";case s.onnx.TensorProto.DataType.DOUBLE:return"float64";case s.onnx.TensorProto.DataType.STRING:return"string";case s.onnx.TensorProto.DataType.INT64:return"int32";case s.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${s.onnx.TensorProto.DataType[f]}`)}}static tensorDataTypeStringToEnum(f){switch(f){case"int8":return s.onnx.TensorProto.DataType.INT8;case"uint8":return s.onnx.TensorProto.DataType.UINT8;case"bool":return s.onnx.TensorProto.DataType.BOOL;case"int16":return s.onnx.TensorProto.DataType.INT16;case"uint16":return s.onnx.TensorProto.DataType.UINT16;case"int32":return s.onnx.TensorProto.DataType.INT32;case"uint32":return s.onnx.TensorProto.DataType.UINT32;case"float32":return s.onnx.TensorProto.DataType.FLOAT;case"float64":return s.onnx.TensorProto.DataType.DOUBLE;case"string":return s.onnx.TensorProto.DataType.STRING;case"int64":return s.onnx.TensorProto.DataType.INT64;case"uint64":return s.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${f}`)}}static tensorDimsFromProto(f){return f.map(y=>m.default.isLong(y)?y.toNumber():y)}static tensorValueTypeFromProto(f){return{tensorType:o.tensorDataTypeFromProto(f.elemType),shape:{dims:o.tensorDimsFromProto(f.shape.dim.map(y=>y.dimValue))}}}static tensorDimsFromORTFormat(f){const y=[];for(let w=0;w<f.dimsLength();w++)y.push(t.longToNumber(f.dims(w)));return y}static tensorAttributesFromORTFormat(f){const y=[];for(let w=0;w<f.attributesLength();w++)y.push(f.attributes(w));return y}}u.ProtoUtil=o;class t{static longToNumber(f,y){return m.default.isLong(f)?f.toNumber():f instanceof p.flatbuffers.Long?m.default.fromValue({low:f.low,high:f.high,unsigned:y!=null&&y}).toNumber():f}static isLong(f){return m.default.isLong(f)||f instanceof p.flatbuffers.Long}}u.LongUtil=t;class e{static size(f){return e.getSizeFromDimensionRange(f,0,f.length)}static sizeFromDimension(f,y){if(y<0||y>f.length)throw new Error(`invalid dimension of ${y} for sizeFromDimension as Tensor has ${f.length} dimensions.`);return e.getSizeFromDimensionRange(f,y,f.length)}static sizeToDimension(f,y){if(y<0||y>f.length)throw new Error(`invalid dimension of ${y} for sizeToDimension as Tensor has ${f.length} dimensions.`);return e.getSizeFromDimensionRange(f,0,y)}static getSizeFromDimensionRange(f,y,w){let x=1;for(let _=y;_<w;_++){if(f[_]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");x*=f[_]}return x}static computeStrides(f){const y=f.length;if(y===0)return[];if(y===1)return[1];const w=new Array(y);w[y-1]=1,w[y-2]=f[y-1];for(let x=y-3;x>=0;--x)w[x]=w[x+1]*f[x+1];return w}static transpose(f){return f.slice().reverse()}static indicesToOffset(f,y,w){w===void 0&&(w=f.length);let x=0;for(let _=0;_<w;++_)x+=y[_]*f[_];return x}static offsetToIndices(f,y){const w=y.length;if(w===0)return[];if(w===1)return[f*y[0]];const x=new Array(y.length);for(let _=0;_<x.length-1;++_)x[_]=Math.floor(f/y[_]),f-=x[_]*y[_];return x[x.length-1]=f,x}static normalizeAxis(f,y){if(f<-y&&f>=y)throw new Error("unsupported axis for this operation.");return f<0?f+y:f}static normalizeAxes(f,y){return f.map(w=>this.normalizeAxis(w,y))}static incrementIndex(f,y,w){if(y.length===0||f.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(w===void 0)w=y.length;else if(w<=0||w>y.length)throw new Error("Incorrect axis to increment on");for(let x=w-1;x>=0&&(f[x]++,!(f[x]<y[x]));--x)f[x]=0}static calculateReshapedDims(f,y){if(y.length===0){if(f.length===0||e.size(f)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const w=y.length,x=new Array(w);let _=-1,S=1;for(let O=0;O<w;O++){if(y[O]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(y[O]===-1){if(_!==-1)throw new Error("at most one dimension in shape hints can be -1");_=O}else{if(y[O]===0){if(O>=f.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");x[O]=f[O]}else x[O]=y[O];S*=x[O]}}const I=e.size(f);if(_!==-1){if(I%S!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${f}] Output shape: [${y}]`);x[_]=I/S}else if(S!==I)throw new Error("reshapedDims and originalDims don't have matching sizes");return x}static sortBasedOnPerm(f,y){return y?y.map(w=>f[w]):f.slice().reverse()}static padShape(f,y){const w=f.length;return f.map((x,_)=>x+y[_]+y[_+w])}static areEqual(f,y){return f.length===y.length&&f.every((w,x)=>w===y[x])}static validateDimsAndCalcSize(f){if(f.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let y=1;for(const w of f){if(!Number.isInteger(w))throw new TypeError(`Invalid shape: ${w} is not an integer`);if(w<0||w>2147483647)throw new TypeError(`Invalid shape: length ${w} is not allowed`);y*=w}return y}static flattenShape(f,y){y<0&&(y+=f.length);const w=f.reduce((_,S)=>_*S,1),x=f.slice(y).reduce((_,S)=>_*S,1);return[w/x,x]}static squeezeShape(f,y){const w=new Array;y=e.normalizeAxes(y,f.length);for(let x=0;x<f.length;x++){const _=y.indexOf(x)>=0;if(_&&f[x]!==1)throw new Error("squeeze an axis of size different than 1");(y.length===0&&f[x]>1||y.length>0&&!_)&&w.push(f[x])}return w}static unsqueezeShape(f,y){const w=new Array(f.length+y.length);w.fill(0);for(let _=0;_<y.length;_++){const S=e.normalizeAxis(y[_],w.length);if(S>=w.length)throw new Error("'axes' has an out of range axis");if(w[S]!==0)throw new Error("'axes' has a duplicate axis");w[S]=1}let x=0;for(let _=0;_<w.length;_++)w[_]===0&&(w[_]=f[x++]);if(x!==f.length)throw new Error("the unsqueezed dimension could not be established");return w}}u.ShapeUtil=e,u.MathUtil=class{static sqr(c,f,y,w,x){if(w<0||w>=f.length)throw new Error("sourceIndex out of bounds");if(y<0||y>=c.length)throw new Error("targetIndex out of bounds");if(w+x>f.length)throw new Error("source indices to be copied are outside bounds");if(y+x>c.length)throw new Error("target array is too small to hold result");for(let _=0;_<x;_++)c[y+_]+=Math.pow(f[w+_],2)}static axpy(c,f,y,w,x,_){if(w<0||w>=f.length)throw new Error("sourceIndex out of bounds");if(y<0||y>=c.length)throw new Error("targetIndex out of bounds");if(w+x>f.length)throw new Error("source indices to be copied are outside bounds");if(y+x>c.length)throw new Error("target array is too small to hold result");for(let S=0;S<x;S++)c[y+S]+=_*f[w+S]}static powx(c,f,y,w,x,_){if(w<0||w>=f.length)throw new Error("sourceIndex out of bounds");if(y<0||y>=c.length)throw new Error("targetIndex out of bounds");if(w+x>f.length)throw new Error("source indices to be copied are outside bounds");if(y+x>c.length)throw new Error("target array is too small to hold result");for(let S=0;S<x;S++)c[y+S]=Math.pow(f[w+S],_)}static mul(c,f,y,w,x){if(w<0||w>=f.length)throw new Error("sourceIndex out of bounds");if(y<0||y>=c.length)throw new Error("targetIndex out of bounds");if(w+x>f.length)throw new Error("source indices to be copied are outside bounds");if(y+x>c.length)throw new Error("target array is too small to hold result");for(let _=0;_<x;_++)c[y+_]=f[w+_]*c[y+_]}};class n{static splitShape(f,y,w,x){if(w.length===0){if(!x)throw new Error("need to know number of outputs when the 'split' attribute is not specified");n.determineSplit(f[y],x,w)}const _=[],S=[0];for(let I=0;I<w.length;++I){I!==0&&S.push(S[I-1]+w[I-1]);const O=f.slice();O[y]=w[I],_.push(O)}return[_,S]}static determineSplit(f,y,w){if(f%y!=0)throw new Error("cannot split tensor to equal sized parts");for(let x=0;x<y;++x)w.push(f/y)}}u.SplitUtil=n;class r{static calcReduce(f,y,w,x,_){const S=f.dims.slice(0);y.length===0&&S.forEach((D,$)=>y.push($));const I=r.calcReduceShape(S,y,!0),O=e.size(I),T=new l.Tensor(I,f.type),A=e.computeStrides(I),P=e.computeStrides(S),R=new Array(S.length);for(let D=0;D<O;D++){const $=e.offsetToIndices(D,A);a.fillIndex($,S,R),T.set($,r.calcReduceByAxis(f.numberData,y,S,0,e.indicesToOffset(R,P),x,_))}return w?T:new l.Tensor(r.calcReduceShape(S,y,w),T.type,void 0,void 0,T.data,T.dataId)}static calcReduceByAxis(f,y,w,x,_,S,I){let O=0;if(x>=y.length)return S(f[_]);const T=y[x],A=T>=w.length?1:e.size(w.slice(T+1));for(let P=0;P<w[T];P++)O=P===0?r.calcReduceByAxis(f,y,w,x+1,_,S,I):I(O,r.calcReduceByAxis(f,y,w,x+1,_,S,I)),_+=A;return O}static calcReduceShape(f,y,w){const x=f.slice();for(let _=0;_<y.length;_++)x[y[_]]=w?1:0;return x.filter(_=>_!==0)}}u.ReduceUtil=r;class i{static adjustPoolAttributes(f,y,w,x,_,S){if(!f&&w.length!==y.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(f)for(let I=0;I<y.length-2;I++)I>=w.length?w.push(y[I+2]):w[I]=y[I+2];for(let I=0;I<w.length;I++)if(I<x.length){if(x[I]<0)throw new Error("strides should be greater than or equal to 1")}else x.push(1);for(let I=0;I<w.length;I++)if(I<_.length){if(_[I]<0)throw new Error("dilations should be greater than or equal to 1")}else _.push(1);for(let I=0;I<2*w.length;I++)if(I<S.length){if(S[I]<0)throw new Error("pad should be greater than or equal to 1")}else S.push(0);for(let I=0;I<w.length;I++){if(w[I]<=0)throw new Error("kernel shapes need to be greater than 0");if(S[I]>=w[I]||S[I+w.length]>=w[I])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(f,y,w,x,_,S){if(S){if(_.length!==2*(f.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(y.length!==f.length-2)throw new Error("length of strides should be the length of data dimensions");if(x.length!==f.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let I=0;I<f.length-2;I++)i.adjustPadAndReturnShape(f[I+2],y[I],w[I],x[I],_,I,I+f.length-2,S)}}static computePoolOutputShape(f,y,w,x,_,S,I){if(y.length<=0)throw new Error("input shape must be of size greater than 0");const O=[y[0],y[1]];return i.computeShapeHelper(f,y,O,w,x,_,S,I),O}static computeConvOutputShape(f,y,w,x,_,S,I){if(f.length<=0||y.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const O=[f[0],y[0]];return i.computeShapeHelper(!1,f,O,w,x,_,S,I),O}static computeShapeHelper(f,y,w,x,_,S,I,O){if(f)for(let T=0;T<y.length-2;T++)w.push(1);else for(let T=0;T<y.length-2;T++)w.push(i.adjustPadAndReturnShape(y[T+2],x[T],_[T],S[T],I,T,T+y.length-2,O))}static adjustPadAndReturnShape(f,y,w,x,_,S,I,O){const T=w*(x-1)+1;if(!O||O==="NOTSET")return Math.floor((f+_[S]+_[I]-T)/y+1);switch(O){case"VALID":return _[S]=0,_[I]=0,Math.floor((f-T)/y+1);case"SAME_LOWER":case"SAME_UPPER":if(w!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const A=((f+y-1)/y-1)*y+x-f;return _[S]=Math.floor(O==="SAME_LOWER"?(A+1)/2:A/2),_[I]=A-_[S],Math.floor((f+A-x)/y+1)}default:throw new Error("Unsupported AutoPad type")}}}u.PoolConvUtil=i,u.MIN_CLIP=-34028234663852886e22,u.MAX_CLIP=34028234663852886e22,u.decodeUtf8String=function(c){return new TextDecoder().decode(c)}},3838:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.WebGpuBackend=void 0;const g=b(8453),p=b(4955),m=b(7771),s=b(8510),l=b(8305);u.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let d=this.kernelCustomData.get(this.currentKernelId);return d||(d={},this.kernelCustomData.set(this.currentKernelId,d)),d}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const d=await navigator.gpu.requestAdapter();if(!d)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const a={requiredLimits:{maxComputeWorkgroupStorageSize:d.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:d.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:d.limits.maxStorageBufferBindingSize}};d.features.has("timestamp-query-inside-passes")&&g.env.webgpu.profilingMode==="default"&&(this.profilingEnabled=!0,a.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await d.requestDevice(a),this.gpuDataManager=(0,m.createGpuDataManager)(this),this.programManager=new l.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(d,a,o,t,e){if(a.length!==d.inputTypes.length)throw new Error(`Input size must be equal to ${d.inputTypes.length}.`);const n=[];for(let _=0;_<a.length;++_){const S=this.gpuDataManager.get(a[_].data);if(!S)throw new Error(`no GPU data for input: ${a[_].data}`);n[_]=S}const r=((_,S,I)=>{const O=S.map(P=>`${P.join(",")}`).join("_"),T=I.join("_");let A=_.name;return _.cacheHint&&(A+="["+_.cacheHint+"]"),A+=":"+O+";"+T,A})(d,a.map(_=>_.dims),n.map(_=>_.type));let i=this.programManager.getArtifact(r);const c=i?i.programInfo:typeof d.get=="function"?d.get():d,f=o.length===0?c.outputs.map((_,S)=>S):o;if(f.length!==c.outputs.length)throw new Error(`Output size ${f.length} must be equal to ${c.outputs.length}.`);const y=[],w=[];for(let _=0;_<c.outputs.length;++_){if(!Number.isInteger(f[_])||f[_]<-2||f[_]>=c.outputs.length)throw new Error(`Invalid output index: ${f[_]}`);const S=f[_]===-1,I=f[_]===-2,O=S||I?e(c.outputs[_].dataType,c.outputs[_].dims):t(f[_],c.outputs[_].dataType,c.outputs[_].dims),T=this.gpuDataManager.get(O.data);if(!T)throw new Error(`no GPU data for output: ${O.data}`);if(S&&this.temporaryData.push(T),I){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(T)}y.push(O),w.push(T)}const x=this.programManager.normalizeDispatchGroupSize(c.dispatchGroup(a));return i||(i=this.programManager.build(c,x),this.programManager.setArtifact(r,i)),(0,p.LOG_DEBUG)("info",()=>`[ProgramManager] run "${c.name}" (key=${r}) with ${x[0]}x${x[1]}x${x[2]}`),this.programManager.run(i,n,w,x),y}upload(d,a){this.gpuDataManager.upload(d,a)}memcpy(d,a){this.gpuDataManager.memcpy(d,a)}async download(d,a){const o=await this.gpuDataManager.download(d);a().set(new Uint8Array(o))}alloc(d){return this.gpuDataManager.create(d).id}free(d){return this.gpuDataManager.release(d)}createKernel(d,a,o){const t=s.WEBGPU_OP_RESOLVE_RULES.get(d);if(!t)throw new Error(`kernel not implemented: ${d}`);this.kernels.set(a,[d,t[0],[t[1],o]])}releaseKernel(d){const a=this.kernelPersistentData.get(d);if(a){for(const o of a)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(d)}this.kernelCustomData.delete(d),this.kernels.delete(d)}computeKernel(d,a){const o=this.kernels.get(d);if(!o)throw new Error(`kernel not created: ${d}`);const[t,e,n]=o;if(this.currentKernelId!==null)throw new Error(`kernel "${t}" is not allowed to be called recursively`);this.currentKernelId=d,n[0]&&(n[1]=n[0](n[1]),n[0]=void 0),(0,p.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${t}"...`),this.temporaryData=[];try{return e(a,n[1]),0}catch(r){return(0,p.LOG_DEBUG)("warning",`[WebGPU] Kernel "${t}" failed. Error: ${r}`),1}finally{for(const r of this.temporaryData)this.gpuDataManager.release(r.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.init=void 0;const g=b(7917),p=b(3838),m=b(4955),s=b(6952);class l{constructor(o,t,e,n){this.module=o,this.dataType=t,this.data=e,this.dims=n}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,s.ShapeUtil.size(this.dims))}reshape(o){if(s.ShapeUtil.size(o)!==s.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new l(this.module,this.dataType,this.data,o)}}class d{get customData(){return this.backend.currentKernelCustomData}constructor(o,t,e){this.module=o,this.backend=t;const n=o.HEAPU32;let r=e>>2;this.opKernelContext=n[r++];const i=n[r++],c=[];for(let f=0;f<i;f++){const y=n[r++],w=n[r++],x=n[r++],_=[];for(let S=0;S<x;S++)_.push(n[r++]);c.push(new l(o,y,w,_))}this.inputs=c}compute(o,t){var e,n,r;const i=(n=(e=t==null?void 0:t.inputs)===null||e===void 0?void 0:e.map(f=>typeof f=="number"?this.inputs[f]:f))!==null&&n!==void 0?n:this.inputs,c=(r=t==null?void 0:t.outputs)!==null&&r!==void 0?r:[];return this.backend.run(o,i,c,(f,y,w)=>new l(this.module,y,this.output(f,w),w),(f,y)=>{const w=(0,g.getTensorElementSize)(f);if(!w)throw new Error(`Unsupported data type: ${f}`);const x=w*s.ShapeUtil.size(y);return new l(this.module,f,this.backend.gpuDataManager.create(x).id,y)})}output(o,t){const e=this.module.stackSave();try{const n=this.module.stackAlloc(4*(1+t.length));let r=n>>2;this.module.HEAPU32[r++]=t.length;for(let i=0;i<t.length;i++)this.module.HEAPU32[r++]=t[i];return this.module._JsepOutput(this.opKernelContext,o,n)}finally{this.module.stackRestore(e)}}}u.init=async a=>{const o=a.jsepInit;if(o&&navigator.gpu){const t=new p.WebGpuBackend;await t.initialize(),o({backend:t},e=>t.alloc(e),e=>t.free(e),(e,n,r,i=!1)=>{if(i)(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${e}, dst=${n}, size=${r}`),t.memcpy(e,n);else{(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${e}, gpuDataId=${n}, size=${r}`);const c=a.HEAPU8.subarray(e,e+r);t.upload(n,c)}},async(e,n,r)=>{(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${e}, dataOffset=${n}, size=${r}`),await t.download(e,()=>a.HEAPU8.subarray(n,n+r))},(e,n,r)=>t.createKernel(e,n,r),e=>t.releaseKernel(e),(e,n)=>{(0,m.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${e}, contextDataOffset=${n}`);const r=new d(a,t,n);return t.computeKernel(e,r)})}}},4955:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.LOG_DEBUG=u.LOG=void 0;const g=b(8453),p=b(7917),m=["V","I","W","E","F"];u.LOG=(s,l)=>{const d=(0,p.logLevelStringToEnum)(s);var a,o;d>=(0,p.logLevelStringToEnum)(g.env.logLevel)&&(a=d,o=typeof l=="function"?l():l,console.log(`[${m[a]},${new Date().toISOString()}]${o}`))},u.LOG_DEBUG=(...s)=>{g.env.debug&&(0,u.LOG)(...s)}},6952:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.MAX_CLIP=u.MIN_CLIP=u.GemmUtil=u.PoolConvUtil=u.ShapeUtil=u.BroadcastUtil=u.MatMulUtil=void 0;class b{static calcMatMulShape(l,d){return l[1]!==d[0]?void 0:[l[0],d[1]]}}u.MatMulUtil=b;class g{static calcShape(l,d,a=!1){const o=l.length,t=d.length;if(o===0)return d;if(t===0)return l;const e=Math.max(l.length,d.length),n=new Array(e);if(a){if(o<2||t<2)return;const r=b.calcMatMulShape([l[o-2],l[o-1]],[d[t-2],d[t-1]]);if(r===void 0)return;[n[e-2],n[e-1]]=r}for(let r=a?3:1;r<=e;r++){const i=o-r<0?1:l[o-r],c=t-r<0?1:d[t-r];if(i!==c&&i>1&&c>1)return;n[e-r]=Math.max(i,c)}return n}static isValidBroadcast(l,d){const a=l.length,o=d.length;if(a>o)return!1;for(let t=1;t<=a;t++)if(l[a-t]!==1&&l[a-t]!==d[o-t])return!1;return!0}}u.BroadcastUtil=g;class p{static size(l){return p.getSizeFromDimensionRange(l,0,l.length)}static sizeFromDimension(l,d){if(d<0||d>l.length)throw new Error(`invalid dimension of ${d} for sizeFromDimension as Tensor has ${l.length} dimensions.`);return p.getSizeFromDimensionRange(l,d,l.length)}static sizeToDimension(l,d){if(d<0||d>l.length)throw new Error(`invalid dimension of ${d} for sizeToDimension as Tensor has ${l.length} dimensions.`);return p.getSizeFromDimensionRange(l,0,d)}static getSizeFromDimensionRange(l,d,a){let o=1;for(let t=d;t<a;t++){if(l[t]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");o*=l[t]}return o}static computeStrides(l){const d=l.length;if(d===0)return[];if(d===1)return[1];const a=new Array(d);a[d-1]=1,a[d-2]=l[d-1];for(let o=d-3;o>=0;--o)a[o]=a[o+1]*l[o+1];return a}static normalizeAxis(l,d){if(l<-d&&l>=d)throw new Error("unsupported axis for this operation.");return l<0?l+d:l}static normalizeAxes(l,d){return l.map(a=>this.normalizeAxis(a,d??l.length))}static sortBasedOnPerm(l,d){return d?d.map(a=>l[a]):l.slice().reverse()}static padShape(l,d){const a=l.length;return l.map((o,t)=>o+d[t]+d[t+a])}static areEqual(l,d){return l.length===d.length&&l.every((a,o)=>a===d[o])}}u.ShapeUtil=p;class m{static adjustPoolAttributes(l,d,a,o,t,e){if(!l&&a.length!==d.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(l)for(let n=0;n<d.length-2;n++)n>=a.length?a.push(d[n+2]):a[n]=d[n+2];for(let n=0;n<a.length;n++)if(n<o.length){if(o[n]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let n=0;n<a.length;n++)if(n<t.length){if(t[n]<0)throw new Error("dilations should be greater than or equal to 1")}else t.push(1);for(let n=0;n<2*a.length;n++)if(n<e.length){if(e[n]<0)throw new Error("pad should be greater than or equal to 1")}else e.push(0);for(let n=0;n<a.length;n++){if(a[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(e[n]>=a[n]||e[n+a.length]>=a[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(l,d,a,o,t,e,n){if(n){if(t.length!==2*(l.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(d.length!==l.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==l.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let r=0;r<l.length-2;r++)m.adjustPadAndReturnShape(l[r+(e?1:2)],d[r],a[r],o[r],t,r,r+l.length-2,n)}}static computePoolOutputShape(l,d,a,o,t,e,n){if(d.length<=0)throw new Error("input shape must be of size greater than 0");const r=[d[0],d[1]];return m.computeShapeHelper(l,d,r,a,o,t,e,n),r}static computeConvOutputShape(l,d,a,o,t,e,n){if(l.length<=0||d.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const r=[l[0],d[0]];return m.computeShapeHelper(!1,l,r,a,o,t,e,n),r}static computeShapeHelper(l,d,a,o,t,e,n,r){if(l)for(let i=0;i<d.length-2;i++)a.push(1);else for(let i=0;i<d.length-2;i++)a.push(m.adjustPadAndReturnShape(d[i+2],o[i],t[i],e[i],n,i,i+d.length-2,r))}static adjustPadAndReturnShape(l,d,a,o,t,e,n,r){const i=a*(o-1)+1;if(!r||r==="NOTSET")return Math.floor((l+t[e]+t[n]-i)/d+1);switch(r){case"VALID":return t[e]=0,t[n]=0,Math.floor((l-i)/d+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const c=((l+d-1)/d-1)*d+o-l;return t[e]=Math.floor(r==="SAME_LOWER"?(c+1)/2:c/2),t[n]=c-t[e],Math.floor((l+c-o)/d+1)}default:throw new Error("Unsupported AutoPad type")}}}u.PoolConvUtil=m,u.GemmUtil=class{static getShapeOfGemmResult(s,l,d,a,o){if(s.length!==2||d.length!==2)throw new Error("shape need to be of size 2");let t,e,n;l?(t=s[1],e=s[0]):(t=s[0],e=s[1]);let r=-1;if(a?(n=d[0],r=1):(n=d[1],r=0),d[r]!==e)throw new Error("dimension mismatch");if(t<=0||n<=0||e<=0)throw new Error("invalid shape specified");if(o&&!g.isValidBroadcast(o,[t,n]))throw new Error("gemm: invalid bias shape for broadcast");return[t,n,e]}},u.MIN_CLIP=-34028234663852886e22,u.MAX_CLIP=34028234663852886e22},387:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createAttributeWithCacheKey=void 0;class b{constructor(p){Object.assign(this,p)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(p=>`${this[p]}`).join(";")),this._cacheKey}}u.createAttributeWithCacheKey=g=>new b(g)},7771:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createGpuDataManager=void 0;const g=b(4955),p=b(1163),m=d=>16*Math.ceil(d/16);let s=0;class l{constructor(a){this.backend=a,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(a,o){const t=o.buffer,e=o.byteOffset,n=o.byteLength,r=m(n),i=this.storageCache.get(a);if(!i)throw new Error("gpu data for uploading does not exist");if(i.originalSize!==n)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${n}`);const c=this.backend.device.createBuffer({mappedAtCreation:!0,size:r,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),f=c.getMappedRange();new Uint8Array(f).set(new Uint8Array(t,e,n)),c.unmap();const y=this.backend.getCommandEncoder();this.backend.endComputePass(),y.copyBufferToBuffer(c,0,i.gpuData.buffer,0,r),(0,g.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${a})`),this.buffersForUploadingPending.push(c)}memcpy(a,o){const t=this.storageCache.get(a);if(!t)throw new Error("source gpu data for memcpy does not exist");const e=this.storageCache.get(o);if(!e)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==e.originalSize)throw new Error("inconsistent source and destination gpu data size");const n=m(t.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(t.gpuData.buffer,0,e.gpuData.buffer,0,n)}create(a,o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const t=m(a),e=this.backend.device.createBuffer({size:t,usage:o}),n={id:s++,type:p.GpuDataType.default,buffer:e};return this.storageCache.set(n.id,{gpuData:n,originalSize:a}),(0,g.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${a}) => id=${n.id}`),n}get(a){var o;return(o=this.storageCache.get(a))===null||o===void 0?void 0:o.gpuData}release(a){const o=this.storageCache.get(a);if(!o)throw new Error("releasing data does not exist");return(0,g.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${a}), gpuDataId=${o.gpuData.id}`),this.storageCache.delete(a),this.buffersPending.push(o.gpuData.buffer),this.downloadCache.get(a)&&this.downloadCache.delete(a),o.originalSize}async download(a){const o=this.downloadCache.get(a);if(o)return o.data;const t=this.storageCache.get(a);if(!t)throw new Error("data does not exist");const e=this.backend.getCommandEncoder();this.backend.endComputePass();const n=this.backend.device.createBuffer({size:t.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});e.copyBufferToBuffer(t.gpuData.buffer,0,n,0,t.originalSize),this.backend.flush();const r=new Promise(i=>{n.mapAsync(GPUMapMode.READ).then(()=>{const c=n.getMappedRange().slice(0);n.destroy(),i(c)})});return this.downloadCache.set(a,{data:r}),r}refreshPendingBuffers(){for(const a of this.buffersForUploadingPending)a.destroy();for(const a of this.buffersPending)a.destroy()}}u.createGpuDataManager=(...d)=>new l(...d)},8510:function(v,u,b){var g=this&&this.__createBinding||(Object.create?function(n,r,i,c){c===void 0&&(c=i);var f=Object.getOwnPropertyDescriptor(r,i);f&&!("get"in f?!r.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,c,f)}:function(n,r,i,c){c===void 0&&(c=i),n[c]=r[i]}),p=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),m=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(n!=null)for(var i in n)i!=="default"&&Object.prototype.hasOwnProperty.call(n,i)&&g(r,n,i);return p(r,n),r};Object.defineProperty(u,"__esModule",{value:!0}),u.WEBGPU_OP_RESOLVE_RULES=void 0;const s=m(b(504)),l=b(9770),d=b(4271),a=b(1522),o=m(b(5262)),t=b(2625),e=m(b(9302));u.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[e.abs]],["Acos",[e.acos]],["Acosh",[e.acosh]],["Add",[s.add]],["Asin",[e.asin]],["Asinh",[e.asinh]],["Atan",[e.atan]],["Atanh",[e.atanh]],["AveragePool",[o.averagePool,o.parseAveragePoolAttributes]],["Ceil",[e.ceil]],["ClipV10",[e.clipV10]],["Clip",[e.clip]],["Conv",[l.conv,l.parseConvAttributes]],["Cos",[e.cos]],["Cosh",[e.cosh]],["Div",[s.div]],["Elu",[e.elu,e.parseAlphaAttributes]],["Erf",[e.erf]],["Exp",[e.exp]],["Floor",[e.floor]],["Gemm",[d.gemm,d.parseGemmAttributes]],["GlobalAveragePool",[o.globalAveragePool,o.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[o.globalMaxPool,o.parseGlobalMaxPoolAttributes]],["LeakyRelu",[e.leakyRelu,e.parseAlphaAttributes]],["MatMul",[a.matMul]],["MaxPool",[o.maxPool,o.parseMaxPoolAttributes]],["Mul",[s.mul]],["Neg",[e.neg]],["Pow",[s.pow]],["Reciprocal",[e.reciprocal]],["Relu",[e.relu]],["Sigmoid",[e.sigmoid]],["Sin",[e.sin]],["Sinh",[e.sinh]],["Sqrt",[e.sqrt]],["Sub",[s.sub]],["Tan",[e.tan]],["Tanh",[e.tanh]],["ThresholdedRelu",[e.thresholdedRelu,e.parseAlphaAttributes]],["Transpose",[t.transpose,t.parseTransposeAttributes]]])},1427:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.biasActivationSnippet=u.activationFnSnippet=u.typeSnippet=void 0,u.typeSnippet=b=>{switch(b){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${b}-component is not supported.`)}},u.activationFnSnippet=(b,g=!1,p=!1,m=3)=>"",u.biasActivationSnippet=(b,g)=>`
      ${b?"value = value + getBiasByOutputCoords(coords);":""}
      ${g?"value = activation(value, coords);":""}
      `},9456:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createConv2DMatMulProgramInfo=void 0;const g=b(4955),p=b(6952),m=b(1163),s=b(1427),l=b(4085),d=b(158);u.createConv2DMatMulProgramInfo=(a,o,t,e,n,r,i,c,f)=>{const y=t.format==="NHWC",w=y?a[0].dims[3]:a[0].dims[1],x=e[0],_=y?e[2]:e[3],S=y?e[1]:e[2],I=y?e[3]:e[1],O=((w%4==0||w%3==0)&&y||_%4==0&&!y)&&I%4==0,T=y?I:_*S,A=y?_*S:I,P=O?[8,8,1]:[T<=4?4:16,T>4&&A<=4?4:16,1],R=O?[4,4,1]:[T<=4?1:2,T>4&&A<=4?1:2,1],D=[Math.ceil(T/P[0]/R[0]),Math.ceil(A/P[1]/R[1]),Math.ceil(x/P[2]/R[1])];(0,g.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${D}`);const $=O?y&&w%4!=0?3:4:R[0],M=P[1]*R[1],C=P[0]*R[0],k=Math.max(P[0]*$,P[1]),z=n%M==0,G=r%C==0,Y=i%k==0,K=O?[$,4,4]:[1,1,1],ee=[`@group(0) @binding(0) var<storage, read> x: array<${O&&$===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${O?"vec4<f32>":"f32"}>;`];let oe=`
      fn setOutputAtIndex(flatIndex : i32, value : ${O?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${O?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${O?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${O?"/ 4":""}, value);
      }`;return c&&(ee.push(`@group(0) @binding(2) var<storage, read> bias: array<${O?"vec4<f32>":"f32"}>;`),oe+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${O?"vec4<f32>":"f32"} {
          return bias[coords.${y?"w":"y"}${O?"/ 4":""}];
        }`),Object.assign(Object.assign({},o),{outputs:[{dims:e,dataType:a[0].dataType,gpuDataType:m.GpuDataType.default}],dispatchGroup:()=>({x:D[0],y:D[1],z:D[2]}),getShaderSource:()=>`
        ${l.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${ee.join("")}
        @group(0) @binding(${ee.length}) var<storage, read_write> result: array<${O?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${ee.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${a[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${a[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${e.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${p.ShapeUtil.computeStrides(e).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${n};
        const dimBOuter : i32 = ${r};
        const dimInner : i32 = ${i};
        ${oe}
        ${((Q,ae,re,ne,fe=!1,ie,me=!1,de=4,be=4,le=4)=>{const we=Q?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,Ee=Q?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Ce=Q?"xShape[1]":"xShape[2]",ke=Q?"xShape[2]":"xShape[3]",Re=Q?"row":"col",Ne=Q?"col":"row",ye=`
    let inChannels = wShape[2];
    let outWidth = ${Q?"outShape[2]":"outShape[3]"};
    let outRow = ${Re} / outWidth;
    let outCol = ${Re} % outWidth;

    let WRow = ${Ne} / (filterDims[1] * inChannels);
    let WCol = ${Ne} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${Ne} % inChannels;
    var resData = ${(0,s.typeSnippet)(de)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${Ce} && xCol >= 0 && xCol < ${ke}) {
      ${we}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(Fe=>{switch(Fe){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Fe} is not supported.`)}})(de)}
    }
    return resData;`,Pe=Q?ae&&ne?`
    let col = colIn * ${de};
    ${ye}`:`
    let col = colIn * ${de};
    if (row < dimAOuter && col < dimInner) {
      ${ye}
    }
    return ${(0,s.typeSnippet)(de)}(0.0);`:ne&&re?`
    let col = colIn * ${de};
    ${ye}`:`
    let col = colIn * ${de};
    if (row < dimInner && col < dimBOuter) {
      ${ye}
    }
    return ${(0,s.typeSnippet)(de)}(0.0);`,xe=`${(Fe=>{switch(Fe){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Fe} is not supported.`)}})(be)}`,Te=(0,s.typeSnippet)(le),Ue=Q?(0,s.typeSnippet)(de):(0,s.typeSnippet)(be),ze=Q?(0,s.typeSnippet)(be):(0,s.typeSnippet)(de);return`
    ${(0,s.activationFnSnippet)(ie,me,le===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ue} {
      ${Q?Pe:xe}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${ze} {
      ${Q?xe:Pe}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${Te}) {
      let col = colIn * ${le};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${Q?"outShape[2]":"outShape[3]"};
      ${Ee}
      ${(0,s.biasActivationSnippet)(fe,ie)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(y,z,G,Y,c,void 0,!1,K[0],K[1],K[2])}
            ${O?(0,d.makeMatMulPackedVec4Source)(R,P,!y,k):(0,d.makeMatMulPackedSource)(R,P,!y,k,!1,void 0,f)}`})}},4085:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.utilFunctions=void 0,u.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.makeMatMulPackedSource=u.makeMatMulPackedVec4Source=void 0,u.makeMatMulPackedVec4Source=(g,p,m=!1,s=32,l=!1,d=32,a=!1)=>{const o=p[1]*g[1],t=p[0]*g[0],e=m?o:s,n=m?s:o,r=e/p[0],i=s/p[1];if((!m||r!==4||g[1]!==4)&&(m||r!==3&&r!==4)||e%p[0]!=0||s%p[1]!=0||g[0]!==4)throw new Error(`If transposeA ${m} is true, innerElementSize ${r} and workPerThread[1] ${g[1]} must be 4.
      Otherwise, innerElementSize ${r} must be 3 or 4.
  tileAWidth ${e} must be divisible by workgroupSize[0]${p[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${p[1]}. colPerThread ${g[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${r}<f32>, ${e/r}>, ${n}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${t/g[0]}>, ${s}>;

const rowPerThread = ${g[1]};
const colPerThread = ${g[0]};
const innerElementSize = ${r};
const tileInner = ${s};

@compute @workgroup_size(${p[0]}, ${p[1]}, ${p[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${a?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${l?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${o};

  let numTiles = ${l?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${l?`i32(globalId.z) * ${d}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${i};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${c=m,c?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${i}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${r===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((f,y)=>f?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${y===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${y===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${y===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(m,r)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var c};const b=g=>g?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;u.makeMatMulPackedSource=(g,p,m=!1,s=32,l=!1,d=32,a=!1)=>{const o=g[1]*p[1],t=g[0]*p[0],e=m?o:s,n=m?s:o;if(n%p[1]!=0||e%p[0]!=0||s%p[1]!=0)throw new Error(`tileAHight ${n} must be divisible by workgroupSize[1]${p[1]}, tileAWidth ${e} must be divisible by workgroupSize[0]${p[0]}, tileInner ${s} must be divisible by workgroupSize[1]${p[1]}`);const r=n/p[1],i=e/p[0],c=s/p[1],f=a?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${o};
    let globalColStart = i32(workgroupId.x) * ${t};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${p[1]}) {
        for (var inputCol = localCol; inputCol < ${e}; inputCol = inputCol + ${p[0]}) {
          ${b(m)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${p[1]}) {
            for (var inputCol = localCol; inputCol < ${t}; inputCol = inputCol + ${p[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${p[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${m?`mm_Asub[k][localRow + innerRow * ${p[1]}];`:`mm_Asub[localRow + innerRow * ${p[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${p[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${p[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${o};

let tileRowA = i32(localId.y) * ${r};
let tileColA = i32(localId.x) * ${i};
let tileRowB = i32(localId.y) * ${c};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${r}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${i}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${b(m)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(y=>y?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(m)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${e}>, ${n}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${s}>;
  const rowPerThread = ${g[1]};
  const colPerThread = ${g[0]};
  const tileInner = ${s};

@compute @workgroup_size(${p[0]}, ${p[1]}, ${p[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${l?"0":"i32(globalId.z)"};
    let numTiles = ${l?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${l?`i32(globalId.z) * ${d}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${f}
  }
`}},504:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.sub=u.pow=u.mul=u.div=u.add=void 0;const g=b(6952),p=b(1163),m=b(2075),s=(l,d,a,o,t)=>{const e={name:d,inputTypes:[p.GpuDataType.default,p.GpuDataType.default],cacheHint:t};return Object.assign(Object.assign({},e),{get:()=>((n,r,i,c,f,y=r.dataType)=>{var w,x;const _=!g.ShapeUtil.areEqual(r.dims,i.dims);let S=r.dims,I=g.ShapeUtil.size(r.dims),O=!1;if(_){const T=g.BroadcastUtil.calcShape(r.dims,i.dims,!1);if(!T)throw new Error("Can't perform binary op on the given tensors");S=T,I=g.ShapeUtil.size(S);let A=1;for(let P=0;P<S.length;P++){const R=(w=r.dims[r.dims.length-P])!==null&&w!==void 0?w:1;if(R!==((x=i.dims[i.dims.length-P])!==null&&x!==void 0?x:1))break;A*=R}A%4==0&&(O=!0)}else O=!0;return Object.assign(Object.assign({},n),{getShaderSource:T=>((A,P,R,D,$,M,C,k,z="f32",G="f32",Y="f32")=>{const K=g.ShapeUtil.size(D),ee=Math.ceil(K/4);let oe,Q;typeof C=="string"?oe=Q=(fe,ie)=>`${C}((${fe}),(${ie}))`:typeof C=="function"?oe=Q=C:(oe=C.scalar,Q=C.vector);let ae="";const re=(0,m.createIndicesHelper)("output",D);if(M){const fe=ie=>{const me=g.ShapeUtil.computeStrides(ie),de=[];for(let be=ie.length-1;be>=0;be--){const le=D.length===0?"0u":D.length===1?"(*outputIndices)":`(*outputIndices)[${be+D.length-ie.length}]`;de.push(`${me[be]}u * (${le} % ${ie[be]}u)`)}return de.length>0?de.join("+"):"0u"};ae=`
  ${re.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${re.iType}>) -> u32 {
    return ${fe(P)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${re.iType}>) -> u32 {
    return ${fe(R)};
  }
  `}let ne;if($)ne=M?`
      ${re.indicesVariableDeclaration("outputIndices")}
      ${re.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${Q("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${Q("aData[global_idx]","bData[global_idx]")};`;else{if(!M)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const fe=ie=>{const me=`aData[indexA${ie}][componentA${ie}]`,de=`bData[indexB${ie}][componentB${ie}]`;return`
      ${re.o2iCall(`global_idx * 4u + ${ie}u`,"outputIndices")}
      let offsetA${ie} = calcOffsetA(&outputIndices);
      let offsetB${ie} = calcOffsetB(&outputIndices);
      let indexA${ie} = offsetA${ie} / 4u;
      let indexB${ie} = offsetB${ie} / 4u;
      let componentA${ie} = offsetA${ie} % 4u;
      let componentB${ie} = offsetB${ie} % 4u;
      outputData[global_idx][${ie}] = ${oe(me,de)};`};ne=`
      ${re.indicesVariableDeclaration("outputIndices")}
      ${fe(0)}
      ${fe(1)}
      ${fe(2)}
      ${fe(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${z}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${G}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${Y}>>;

  ${k??""}
  ${ae}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(ee)}
    ${ne}
  }`})(T,r.dims,i.dims,S,O,_,c,f),outputs:[{dims:S,dataType:y,gpuDataType:p.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(I/64/(O?4:1))})})})(e,l[0],l[1],a,o)})};u.add=l=>{l.compute(s(l.inputs,"Add",(d,a)=>`${d}+${a}`))},u.div=l=>{l.compute(s(l.inputs,"Div",(d,a)=>`${d}/${a}`))},u.mul=l=>{l.compute(s(l.inputs,"Mul",(d,a)=>`${d}*${a}`))},u.pow=l=>{l.compute(s(l.inputs,"Pow",{scalar:(d,a)=>`pow_f32(${d},${a})`,vector:(d,a)=>`pow_vf32(${d},${a})`},`
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))},u.sub=l=>{l.compute(s(l.inputs,"Sub",(d,a)=>`${d}-${a}`))}},2075:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createShaderHelper=u.createIndicesHelper=u.WORKGROUP_SIZE=void 0;const g=b(6952);u.WORKGROUP_SIZE=64,u.createIndicesHelper=(m,s)=>{const l=s.length<2?"u32":`array<u32, ${s.length}>`,d=g.ShapeUtil.computeStrides(s);let a="";for(let e=0;e<s.length-1;e++)a+=`
    let dim${e} = current / ${d[e]}u;
    let rest${e} = current % ${d[e]}u;
    (*indices)[${e}] = dim${e};
    current = rest${e};
    `;a+=`(*indices)[${s.length-1}] = current;`;const o=s.length<2?"":`
  fn ih_o2i_${m}(offset: u32, indices: ptr<function, ${l}>) {
    var current = offset;
    ${a}
  }`,t=[];if(s.length===0)t.push("0u");else if(s.length<2)t.push("(*indices)");else for(let e=s.length-1;e>=0;e--)t.push(`${d[e]}u * ((*indices)[${e}])`);return{o2iImpl:o,o2iCall:(e,n)=>s.length<2?`${n}=${e};`:`ih_o2i_${m}(${e}, &${n});`,i2oImpl:s.length<2?"":`
  fn ih_i2o_${m}(indices: ptr<function, ${l}>) -> u32 {
    return ${t.join("+")};
  }`,i2oExpression:(e,n)=>s.length<2?`(${n?"*":""}${e})`:`ih_i2o_${m}(${n?"":"&"}${e})`,indicesVariableDeclaration:(e,n)=>`var ${e}:${l}${n?`=${l}(${n.join(",")})`:""};`,iType:l}};class p{constructor(s){this.normalizedDispatchGroup=s}guardAgainstOutOfBoundsWorkgroupSizes(s){return`if (global_idx >= ${typeof s=="number"?`${s}u`:s}) { return; }`}mainStart(s=u.WORKGROUP_SIZE){const l=typeof s=="number"?s:s[0],d=typeof s=="number"?1:s[1],a=typeof s=="number"?1:s[2],o=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${l}, ${d}, ${a})
  fn main(${o?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${o?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${l*d*a}u + local_index;`}
  `}}u.createShaderHelper=m=>new p(m)},9192:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createGroupedConvProgramInfoLoader=void 0;const g=b(6952),p=b(1163),m=b(2075),s=b(9770),l=b(3997);u.createGroupedConvProgramInfoLoader=(d,a,o)=>{const t=(e=d.length>2,n=a.cacheKey,{name:"GroupedConv",inputTypes:e?[p.GpuDataType.default,p.GpuDataType.default,p.GpuDataType.default]:[p.GpuDataType.default,p.GpuDataType.default],cacheHint:n});var e,n;return Object.assign(Object.assign({},t),{get:()=>((r,i,c,f)=>{const y=r.length>2,w=y?"value += b[output_channel];":"",x=r[0].dims,_=r[1].dims,S=_[0]/c.group,I="f32",{activationFunction:O,applyActivation:T}=(0,l.getActicationSnippet)(c),A=[`@group(0) @binding(0) var<storage, read> x : array<${I}>;`,`@group(0) @binding(1) var<storage, read> w : array<${I}>;`];y&&A.push(`@group(0) @binding(2) var<storage, read> b : array<${I}>;`);const P=c.format==="NHWC",R=(0,s.calculateOutputShape)(x,_,c.dilations,c.pads,c.strides,P),D=g.ShapeUtil.size(R),$=(0,m.createIndicesHelper)("output",R),M=(0,m.createIndicesHelper)("x",x),C=(0,m.createIndicesHelper)("w",_);return Object.assign(Object.assign({},i),{outputs:[{dims:f?f(R):R,dataType:r[0].dataType,gpuDataType:p.GpuDataType.default}],getShaderSource:k=>`
  const strides: vec2<u32> = vec2(${c.strides[0]}u, ${c.strides[1]}u);
  const pads: vec2<u32> = vec2(${c.pads[0]}u, ${c.pads[1]}u);

  ${A.join(`
`)}
  @group(0) @binding(${A.length}) var<storage, read_write> output : array<${I}>;

  ${O}
  ${$.o2iImpl}
  ${M.i2oImpl}
  ${C.i2oImpl}

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes(D)}

    ${$.indicesVariableDeclaration("outputIndices")}
    ${$.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${P?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${P?1:2}], outputIndices[${P?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${S}u;

    var value: ${I} = ${I}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${_[1]}u; wInChannel++) {
      let input_channel = group_id * ${_[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${_[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${c.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${x[P?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${_[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${c.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${x[P?2:3]}u) {
            continue;
          }

          ${M.indicesVariableDeclaration("xIndices",P?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${M.i2oExpression("xIndices")}];
          ${C.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${C.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${w}
    ${T}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(D/64)})})})(d,t,a,o)})}},9770:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.conv=u.parseConvAttributes=u.calculateOutputShape=void 0;const g=b(6952),p=b(387),m=b(9192),s=b(3822),l=b(3997),d=b(2625);u.calculateOutputShape=(t,e,n,r,i,c)=>{const f=t[0],y=t.slice(c?1:2,c?3:4),w=y.length,x=e[0],_=e.slice(2).map((I,O)=>I+(I-1)*(n[O]-1)),S=y.map((I,O)=>I+r[O]+r[O+w]).map((I,O)=>Math.floor((I-_[O]+i[O])/i[O]));return S.splice(0,0,f),S.splice(c?3:1,0,x),S};const a=(0,p.createAttributeWithCacheKey)({perm:[2,3,1,0]}),o=(t,e)=>{const n=t.kernelShape.slice();for(let c=2;c<e[1].dims.length;++c)n[c-2]===0&&(n[c-2]=e[1].dims[c]);const r=t.pads.slice();g.PoolConvUtil.adjustPadsBasedOnAutoPad(e[0].dims,t.strides,t.dilations,n,r,t.format==="NHWC",t.autoPad);const i=Object.assign({},t);return Object.assign(i,{kernelShape:n,pads:r,cacheKey:t.cacheKey}),i};u.parseConvAttributes=t=>{const e=(0,l.parseInternalActivationAttributes)(t),n=t.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],i=t.dilations,c=t.group,f=t.kernel_shape,y=t.pads,w=t.strides,x=t.w_is_const();return(0,p.createAttributeWithCacheKey)(Object.assign({autoPad:r,format:n,dilations:i,group:c,kernelShape:f,pads:y,strides:w,wIsConst:x},e))},u.conv=(t,e)=>{((n,r)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");if(n[0].dims[r.format==="NHWC"?n[0].dims.length-1:1]!==n[1].dims[1]*r.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");const i=n[0].dims.length-2;if(r.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(r.strides.length!==i)throw new Error(`strides should be ${i}D`);if(r.pads.length!==2*i)throw new Error(`pads should be ${2*i}D`);if(r.kernelShape.length!==0&&r.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(n[0].dataType!==1||n[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(n.length===3&&n[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(t.inputs,e),t.inputs[0].dims.length===3?((n,r)=>{const i=r.format==="NHWC",c=[n.inputs[0].reshape(i?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&c.push(n.inputs[2]);const f=[0,r.pads[0],0,r.pads[1]],y=[1].concat(r.strides),w=[1].concat(r.dilations),x=[1].concat(r.kernelShape),_=o(Object.assign(Object.assign({},r),{pads:f,strides:y,dilations:w,kernelShape:x}),c);n.compute((0,m.createGroupedConvProgramInfoLoader)(c,_,S=>i?[S[0],S[2],S[3]]:[]))})(t,e):((n,r,i)=>{var c;const f=o(i,r),y=r.length===3,w=i.format==="NHWC",x=r[0].dims[w?1:2],_=r[0].dims[w?2:3],S=r[0].dims[w?3:1],I=r[1].dims[2],O=r[1].dims[3],T=(0,u.calculateOutputShape)(r[0].dims,r[1].dims,i.dilations,f.pads,i.strides,w),A=T[w?1:2],P=T[w?2:3],R=T[w?3:1];if(w&&I===x&&O===_&&i.autoPad==="VALID"||I===1&&O===1&&i.dilations[0]===1&&i.dilations[1]===1&&i.strides[0]===1&&i.strides[1]===1&&(i.autoPad==="SAME_UPPER"||i.autoPad==="SAME_LOWER"||i.autoPad==="VALID")||!w||i.group!==1)return void n.compute((0,m.createGroupedConvProgramInfoLoader)(r,f));const D=w?A*P:R,$=w?R:A*P,M=I*O*S,C=(c=n.customData.wT)!==null&&c!==void 0?c:n.compute(Object.assign(Object.assign({},d.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,d.createTransposeProgramInfo)(r[1],a.perm)}),{inputs:[1],outputs:[i.wIsConst?-2:-1]})[0];i.wIsConst&&!n.customData.wT&&(n.customData.wT=C);const k=[r[0],C];y&&(w||r[2].dims.length!==1?k.push(r[2]):k.push(r[2].reshape([r[2].dims[0],1,1]))),n.compute((0,s.createConv2DMatMulProgramInfoLoader)(k,f,T,D,$,M,y,!0),{inputs:k})})(t,t.inputs,e)}},3822:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.createConv2DMatMulProgramInfoLoader=void 0;const g=b(1163),p=b(9456);u.createConv2DMatMulProgramInfoLoader=(m,s,l,d,a,o,t,e)=>{const n=((r,i)=>({name:"Conv2DMatMul",inputTypes:r?[g.GpuDataType.default,g.GpuDataType.default,g.GpuDataType.default]:[g.GpuDataType.default,g.GpuDataType.default],cacheHint:i}))(t,s.cacheKey);return Object.assign(Object.assign({},n),{get:()=>(0,p.createConv2DMatMulProgramInfo)(m,n,s,l,d,a,o,t,e)})}},3997:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseInternalActivationAttributes=u.getActicationSnippet=void 0;const g=b(6952);u.getActicationSnippet=p=>{switch(p.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${p.clipMin});const clip_max_=f32(${p.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},u.parseInternalActivationAttributes=p=>{const m=(p==null?void 0:p.activation)||"";if(m==="Clip"){const[s,l]=(p==null?void 0:p.activation_params)||[g.MIN_CLIP,g.MAX_CLIP];return{activation:m,clipMax:l,clipMin:s,activationCacheKey:`${m}:${s},${l}`}}return{activation:m,activationCacheKey:m}}},4271:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseGemmAttributes=u.gemm=void 0;const g=b(6952),p=b(387),m=b(1163);u.gemm=(s,l)=>{(d=>{if(!d)throw new Error("Input is missing");if(d.length<2||d.length>3)throw new Error("Invaid input number.");if(d.length===3&&d[2].dims.length>2)throw new Error("Invalid input shape of C");if(d[0].dataType!==1||d[1].dataType!==1||d.length===3&&d[2].dataType!==1)throw new Error("Invalid input type.");if(d[0].dataType!==d[1].dataType||d.length===3&&d[0].dataType!==d[2].dataType)throw new Error("Input types are mismatched")})(s.inputs),s.compute(((d,a)=>{const o={name:"Gemm",inputTypes:d.length===3?[m.GpuDataType.default,m.GpuDataType.default,m.GpuDataType.default]:[m.GpuDataType.default,m.GpuDataType.default],cacheHint:a.cacheKey};return Object.assign(Object.assign({},o),{get:()=>((t,e,n)=>{const r=e[0].dims.slice(),i=e[1].dims.slice(),[c,f,y]=g.GemmUtil.getShapeOfGemmResult(r,n.transA,i,n.transB,e.length===3?e[2].dims:void 0),w=[c,f];if(!w)throw new Error("Can't use gemm on the given tensors");const x=g.ShapeUtil.size(w);let _="";n.transA&&n.transB?_="value += a[k * M + m] * b[n * K + k];":n.transA&&!n.transB?_="value += a[k * M + m] * b[k * N + n];":!n.transA&&n.transB?_="value += a[m * K + k] * b[n * K + k];":n.transA||n.transB||(_="value += a[m * K + k] * b[k * N + n];");const S="f32",I=n.alpha===1?"":"value *= alpha;",O=e.length===3?`value += beta * c[${((A,P,R)=>{if(R.length===0)return"0u";const D=R.length===1&&A!==1||R.length===2&&R[0]!==A,$=R[R.length-1]!==P;let M="0u";return D||(M+=`+ m * ${R[R.length-1]}u`),$||(M+="+n"),M})(c,f,e[2].dims)}];`:"",T=[`@group(0) @binding(0) var<storage, read> a : array<${S}>;`,`@group(0) @binding(1) var<storage, read> b : array<${S}>;`];return e.length===3&&T.push(`@group(0) @binding(2) var<storage, read> c : array<${S}>;`),Object.assign(Object.assign({},t),{outputs:[{dims:w,dataType:e[0].dataType,gpuDataType:m.GpuDataType.default}],getShaderSource:A=>`
  const M: u32 = ${c}u;
  const N: u32 = ${f}u;
  const K: u32 = ${y}u;
  const alpha = ${S}(${n.alpha});
  const beta = ${S}(${n.beta});

  ${T.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${S}>;

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(x)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${S}(0);
    for (var k: u32 = 0u; k<${y}u; k++) {
      ${_}
    }

    ${I}
    ${O}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(x/64)})})})(o,d,a)})})(s.inputs,l))},u.parseGemmAttributes=s=>(0,p.createAttributeWithCacheKey)(s)},1522:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.matMul=u.createMatmulProgramInfoLoader=void 0;const g=b(6952),p=b(1163),m=b(3997);u.createMatmulProgramInfoLoader=(s,l)=>{const d=(a=s.length>2,o=l.activationCacheKey,{name:"MatMul",inputTypes:a?[p.GpuDataType.default,p.GpuDataType.default,p.GpuDataType.default]:[p.GpuDataType.default,p.GpuDataType.default],cacheHint:o});var a,o;return Object.assign(Object.assign({},d),{get:()=>((t,e,n)=>{const r=e[0].dims,i=e[1].dims,c=g.BroadcastUtil.calcShape(r,i,!0);if(!c)throw new Error("Can't use matmul on the given tensors");const f=g.ShapeUtil.size(c),y="f32",{activationFunction:w,applyActivation:x}=(0,m.getActicationSnippet)(n),_=c[c.length-2],S=r[r.length-1],I=c[c.length-1];return Object.assign(Object.assign({},t),{outputs:[{dims:c,dataType:e[0].dataType,gpuDataType:p.GpuDataType.default}],getShaderSource:O=>`
  const M: u32 = ${_}u;
  const N: u32 = ${I}u;
  const K: u32 = ${S}u;

  @group(0) @binding(0) var<storage, read> a : array<${y}>;
  @group(0) @binding(1) var<storage, read> b : array<${y}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${y}>;

  ${w}

  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes(f)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${y}(0);
    for (var k: u32 = 0u; k<${S}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${x}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(f/64)})})})(d,s,l)})},u.matMul=s=>{(l=>{if(!l||l.length!==2)throw new Error("MatMul requires 2 inputs.");if(l[0].dims[l[0].dims.length-1]!==l[1].dims[l[1].dims.length-2])throw new Error("shared dimension does not match.");if(l[0].dataType!==1||l[1].dataType!==1)throw new Error("inputs should be float type")})(s.inputs),s.compute((0,u.createMatmulProgramInfoLoader)(s.inputs,{activation:"",activationCacheKey:""}))}},5262:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.globalMaxPool=u.parseGlobalMaxPoolAttributes=u.parseMaxPoolAttributes=u.maxPool=u.globalAveragePool=u.parseGlobalAveragePoolAttributes=u.averagePool=u.parseAveragePoolAttributes=void 0;const g=b(6952),p=b(387),m=b(1163),s=b(2075),l=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},d=(r,i,c)=>{const f=i.format==="NHWC",y=f?[r[0].dims[0],r[0].dims[3],r[0].dims[1],r[0].dims[2]]:r[0].dims.slice(),w=Object.hasOwnProperty.call(i,"dilations"),x=i.kernelShape.slice(),_=i.strides.slice(),S=w?i.dilations.slice():[],I=i.pads.slice();g.PoolConvUtil.adjustPoolAttributes(c,y,x,_,S,I);const O=g.PoolConvUtil.computePoolOutputShape(c,y,_,S,x,I,i.autoPad),T=Object.assign({},i);return w?Object.assign(T,{kernelShape:x,strides:_,pads:I,dilations:S,cacheKey:i.cacheKey}):Object.assign(T,{kernelShape:x,strides:_,pads:I,cacheKey:i.cacheKey}),[T,f?[O[0],O[2],O[3],O[1]]:O]},a=(r,i,c,f,y,w,x,_)=>{const S=f.format==="NHWC",I=i.length,O=g.ShapeUtil.size(c),T=(0,s.createIndicesHelper)("output",c),A=(0,s.createIndicesHelper)("x",i);if(f.kernelShape.length<=2){const P=f.kernelShape[f.kernelShape.length-1],R=f.strides[f.strides.length-1],D=f.pads[f.pads.length/2-1],$=I-(S?2:1);let M="",C="",k="";if(M=D+f.pads[f.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${P}u; i++) {
                xIndices[${$}] = indices[${$}] * ${R} - ${D} + i;
                if (xIndices[${$}] < 0 || xIndices[${$}] >= ${i[$]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${y}
              }`:`
              for (var i: u32 = 0u; i < ${P}u; i++) {
                xIndices[${$}] = indices[${$}] * ${R} - ${D} + i;
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${y}
              }`,f.kernelShape.length===2){const z=f.kernelShape[f.kernelShape.length-2],G=f.strides[f.strides.length-2],Y=f.pads[f.pads.length/2-2],K=f.pads[f.pads.length-2],ee=I-(S?3:2),oe=i[ee];C=Y+K!==0?`
                for (var j: u32 = 0u; j < ${z}u; j++) {
                  xIndices[${ee}] = indices[${ee}] * ${G} - ${Y} + j;
                  if (xIndices[${ee}] < 0 || xIndices[${ee}] >= ${oe}) {
                    pad+= ${P};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${z}u; j++) {
                  xIndices[${ee}] = indices[${ee}] * ${G} - ${Y} + j;
                `,k=`
              }
            `}return`
            @group(0) @binding(0) var<storage, read> x : array<${x}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${x}>;

            ${T.o2iImpl}
            ${A.i2oImpl}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(O)}

              ${T.indicesVariableDeclaration("indices")}
              ${T.o2iCall("global_idx","indices")}
              ${T.indicesVariableDeclaration("xIndices")}
              ${T.o2iCall("global_idx","xIndices")}

              var value: ${x} = ${x}(${_});
              var pad = 0;
              ${C}
              ${M}
              ${k}
              ${w}

              output[global_idx] = value;
            }`}{if(S)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const P=g.ShapeUtil.size(f.kernelShape),R=g.ShapeUtil.computeStrides(f.kernelShape),D=R.length,$=f.pads.length;let M="";return M=f.pads.reduce((C,k)=>C+k)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${A.i2oExpression("xIndices")}];
                ${y}
              }`:`
              }
              let x_val = x[${A.i2oExpression("xIndices")}];
              ${y}
            `,`
            @group(0) @binding(0) var<storage, read> x : array<${x}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${x}>;

            ${T.o2iImpl}
            ${A.i2oImpl}

            const pads = array<u32, ${$}>(${f.pads.map(C=>`${C}u`).join(",")});
            const inputDims = array<u32, ${I}>(${i.map(C=>`${C}u`).join(",")});
            const kernelStrides = array<u32, ${D}>(${R.map(C=>`${C}u`).join(",")});
            const strides = array<u32, ${D}>(${f.strides.map(C=>`${C}u`).join(",")});

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(O)}

              ${T.indicesVariableDeclaration("indices")}
              ${T.o2iCall("global_idx","indices")}
              ${T.indicesVariableDeclaration("xIndices")}
              ${T.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${D}>;

              var value = ${x}(${_});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${P}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${D-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${D-1}] = offset;

                isPad = false;
                for (var j = ${I-D}u; j < ${I}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${I-D}u]
                    + offsets[j - ${I-D}u] - pads[j - 2u];
                  ${M}
              }
              ${w}

              output[global_idx] = value;
            }`}},o=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),t=(r,i,c,f)=>{const[y,w]=d(r,f,c),x=g.ShapeUtil.size(y.kernelShape),_="f32";let S="";return y.countIncludePad?S+=`value /= ${_}(${x});`:S+=`value /= ${_}(${x} - pad);`,Object.assign(Object.assign({},i),{outputs:[{dims:w,dataType:r[0].dataType,gpuDataType:m.GpuDataType.default}],getShaderSource:I=>a(I,r[0].dims,w,y,"value += x_val;",S,_,"0.0"),dispatchGroup:()=>({x:Math.ceil(g.ShapeUtil.size(w)/64)})})};u.parseAveragePoolAttributes=r=>{const i=r.count_include_pad!==0,c=o(r);if(c.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,p.createAttributeWithCacheKey)(Object.assign({countIncludePad:i},c))},u.averagePool=(r,i)=>{l(r.inputs);const c={name:"AveragePool",inputTypes:[m.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>t(r.inputs,c,!1,i)}))};const e={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};u.parseGlobalAveragePoolAttributes=r=>{const i=r.format;return Object.assign(Object.assign({format:i},e),{cacheKey:i})},u.globalAveragePool=(r,i)=>{l(r.inputs);const c={name:"GlobalAveragePool",inputTypes:[m.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>t(r.inputs,c,!0,i)}))};const n=(r,i,c,f)=>{const[y,w]=d(r,f,c);return Object.assign(Object.assign({},i),{outputs:[{dims:w,dataType:r[0].dataType,gpuDataType:m.GpuDataType.default}],getShaderSource:x=>a(x,r[0].dims,w,y,`
      value = max(x_val, value);
    `,"","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(g.ShapeUtil.size(w)/64)})})};u.maxPool=(r,i)=>{l(r.inputs);const c={name:"MaxPool",inputTypes:[m.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>n(r.inputs,c,!1,i)}))},u.parseMaxPoolAttributes=r=>{const i=r.storage_order,c=r.dilations,f=o(r);if(i!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(f.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,p.createAttributeWithCacheKey)(Object.assign({storageOrder:i,dilations:c},f))},u.parseGlobalMaxPoolAttributes=r=>{const i=r.format;return Object.assign(Object.assign({format:i},e),{cacheKey:i})},u.globalMaxPool=(r,i)=>{l(r.inputs);const c={name:"GlobalMaxPool",inputTypes:[m.GpuDataType.default],cacheHint:i.cacheKey};r.compute(Object.assign(Object.assign({},c),{get:()=>n(r.inputs,c,!0,i)}))}},2625:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.parseTransposeAttributes=u.transpose=u.createTransposeProgramInfo=u.transposeProgramMetadata=void 0;const g=b(6952),p=b(387),m=b(1163),s=b(2075);u.transposeProgramMetadata={name:"Transpose",inputTypes:[m.GpuDataType.default]};const l=(d,a)=>a&&a.length!==d.length?[...d.keys()].reverse():a;u.createTransposeProgramInfo=(d,a)=>{const o=d.dims,t=l(o,a),e=((f,y)=>g.ShapeUtil.sortBasedOnPerm(f,l(f,y)))(o,t),n=o.length,r=g.ShapeUtil.size(e),i=(0,s.createIndicesHelper)("output",e),c=(0,s.createIndicesHelper)("a",o);return Object.assign(Object.assign({},u.transposeProgramMetadata),{outputs:[{dims:e,dataType:d.dataType,gpuDataType:m.GpuDataType.default}],getShaderSource:f=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((y,w)=>{const x=[];x.push(`fn perm(a: ptr<function, array<u32, ${w}>>, i: ptr<function, array<u32, ${w}>>) {`);for(let _=0;_<w;++_)x.push(`	(*a)[${y[_]}]=(*i)[${_}];`);return x.push("	}"),x.join(`
`)})(t,n)}
  ${i.o2iImpl}
  ${c.i2oImpl}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(r)}

    ${i.indicesVariableDeclaration("indices")}
    ${i.o2iCall("global_idx","indices")}
    ${c.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${c.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(r/64)})})},u.transpose=(d,a)=>{(o=>{if(!o||o.length!==1)throw new Error("Transpose requires 1 input.");if(o[0].dataType!==1)throw new Error("input should be float tensor")})(d.inputs),d.compute(Object.assign(Object.assign({},u.transposeProgramMetadata),{cacheHint:a.cacheKey,get:()=>(0,u.createTransposeProgramInfo)(d.inputs[0],a.perm)}))},u.parseTransposeAttributes=d=>(0,p.createAttributeWithCacheKey)({perm:d.perm})},9302:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.thresholdedRelu=u.tanh=u.tan=u.sqrt=u.sinh=u.sin=u.sigmoid=u.relu=u.reciprocal=u.neg=u.leakyRelu=u.floor=u.exp=u.erf=u.elu=u.parseAlphaAttributes=u.cosh=u.cos=u.ceil=u.clip=u.clipV10=u.atanh=u.atan=u.asinh=u.asin=u.acosh=u.acos=u.abs=void 0;const g=b(6952),p=b(387),m=b(1163),s=(l,d,a,o,t)=>{const e={name:d,inputTypes:[m.GpuDataType.default],cacheHint:t};return Object.assign(Object.assign({},e),{get:()=>((n,r,i,c)=>Object.assign(Object.assign({},n),{getShaderSource:f=>((y,w,x,_)=>{const S=Math.ceil(w/4);let I="";return I=typeof x=="string"?`${x}(a)`:x("a"),`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${_??""}

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(S)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${I};
  }`})(f,g.ShapeUtil.size(r.dims),i,c),outputs:[{dims:r.dims,dataType:r.dataType,gpuDataType:m.GpuDataType.default}],dispatchGroup:f=>({x:Math.ceil(g.ShapeUtil.size(f[0].dims)/64/4)})}))(e,l,a,o)})};u.abs=l=>{l.compute(s(l.inputs[0],"Abs","abs"))},u.acos=l=>{l.compute(s(l.inputs[0],"Acos","acos"))},u.acosh=l=>{l.compute(s(l.inputs[0],"Acosh","acosh"))},u.asin=l=>{l.compute(s(l.inputs[0],"Asin","asin"))},u.asinh=l=>{l.compute(s(l.inputs[0],"Asinh","asinh"))},u.atan=l=>{l.compute(s(l.inputs[0],"Atan","atan"))},u.atanh=l=>{l.compute(s(l.inputs[0],"Atanh","atanh"))},u.clipV10=(l,d)=>{l.compute(s(l.inputs[0],"Clip",a=>`clamp(${a}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${d.min}));
    const clip_max_: vec4<f32> = vec4(f32(${d.max}));
`,d.cacheKey),{inputs:[0]})},u.clip=l=>{const d=(a=>{const o=a.length>=2?a[1].getFloat32Array()[0]:g.MIN_CLIP,t=a.length>=3?a[2].getFloat32Array()[0]:g.MAX_CLIP;return(0,p.createAttributeWithCacheKey)({min:o,max:t})})(l.inputs);(0,u.clipV10)(l,d)},u.ceil=l=>{l.compute(s(l.inputs[0],"Ceil","ceil"))},u.cos=l=>{l.compute(s(l.inputs[0],"Cos","cos"))},u.cosh=l=>{l.compute(s(l.inputs[0],"Cosh","cosh"))},u.parseAlphaAttributes=l=>(0,p.createAttributeWithCacheKey)(l),u.elu=(l,d)=>{l.compute(s(l.inputs[0],"Elu",a=>`elu_vf32(${a})`,`
  const elu_alpha_: f32 = f32(${d.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,d.cacheKey))},u.erf=l=>{l.compute(s(l.inputs[0],"Erf",d=>`erf_vf32(${d})`,`
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))},u.exp=l=>{l.compute(s(l.inputs[0],"Exp","exp"))},u.floor=l=>{l.compute(s(l.inputs[0],"Floor","floor"))},u.leakyRelu=(l,d)=>{l.compute(s(l.inputs[0],"LeakyRelu",a=>`select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${d.alpha});`,d.cacheKey))},u.neg=l=>{l.compute(s(l.inputs[0],"Neg",d=>`-${d}`))},u.reciprocal=l=>{l.compute(s(l.inputs[0],"Reciprocal",d=>`1.0/${d}`))},u.relu=l=>{l.compute(s(l.inputs[0],"Relu",d=>`select(vec4<f32>(0.0), ${d}, ${d} > vec4<f32>(0.0))`))},u.sigmoid=l=>{l.compute(s(l.inputs[0],"Sigmoid",d=>`(1.0 / (1.0 + exp(-${d})))`))},u.sin=l=>{l.compute(s(l.inputs[0],"Sin","sin"))},u.sinh=l=>{l.compute(s(l.inputs[0],"Sinh","sinh"))},u.sqrt=l=>{l.compute(s(l.inputs[0],"Sqrt","sqrt"))},u.tan=l=>{l.compute(s(l.inputs[0],"Tan","tan"))},u.tanh=l=>{l.compute(s(l.inputs[0],"Tanh","tanh"))},u.thresholdedRelu=(l,d)=>(l.compute(s(l.inputs[0],"ThresholdedRelu",a=>`select(vec4<f32>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${d.alpha});`,d.cacheKey)),0)},8305:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.ProgramManager=void 0;const g=b(4955),p=b(2075);u.ProgramManager=class{constructor(m){this.backend=m,this.repo=new Map,this.attributesBound=!1}getArtifact(m){return this.repo.get(m)}setArtifact(m,s){this.repo.set(m,s)}run(m,s,l,d){const a=this.backend.device,o=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&o.writeTimestamp(this.backend.profilingQuerySet,0),o.setPipeline(m.computePipeline);const t=[];for(const n of s)t.push({binding:t.length,resource:{buffer:n.buffer}});for(const n of l)t.push({binding:t.length,resource:{buffer:n.buffer}});const e=a.createBindGroup({layout:m.computePipeline.getBindGroupLayout(0),entries:t});if(o.setBindGroup(0,e),o.dispatchWorkgroups(...d),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){o.writeTimestamp(this.backend.profilingQuerySet,1);const n=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),r=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,n.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(n.buffer,0,r.buffer,0,16),this.backend.flush();const i=this.backend.currentKernelId,c=this.backend.kernels.get(i)[0];r.buffer.mapAsync(GPUMapMode.READ).then(()=>{const f=new BigUint64Array(r.buffer.getMappedRange()),y=f[0],w=f[1];r.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=y);const x=Number(y-this.backend.profilingTimeBase),_=Number(w-this.backend.profilingTimeBase);if(!Number.isSafeInteger(x)||!Number.isSafeInteger(_))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(n.id),this.backend.gpuDataManager.release(r.id),console.log(`[profiling] kernel "${i}|${c}" execution time: ${_-x} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(m,s){const l=this.backend.device,d=m.getShaderSource((0,p.createShaderHelper)(s)),a=l.createShaderModule({code:d});return(0,g.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${d}`),{programInfo:m,computePipeline:l.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(m){const s=typeof m=="number"?m:m.x,l=typeof m=="number"?1:m.y||1,d=typeof m=="number"?1:m.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(s<=a&&l<=a&&d<=a)return[s,l,d];const o=s*l*d;let t=Math.ceil(Math.sqrt(o));if(t>a){if(t=Math.ceil(Math.cbrt(o)),t>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[t,t,t]}return[t,t,1]}}},1163:(v,u)=>{var b;Object.defineProperty(u,"__esModule",{value:!0}),u.GpuDataType=void 0,(b=u.GpuDataType||(u.GpuDataType={}))[b.default=0]="default",b[b.upload=1]="upload",b[b.profile=2]="profile"},3899:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.iterateExtraOptions=void 0,u.iterateExtraOptions=(b,g,p,m)=>{if(typeof b=="object"&&b!==null){if(p.has(b))throw new Error("Circular reference in options");p.add(b)}Object.entries(b).forEach(([s,l])=>{const d=g?g+s:s;if(typeof l=="object")(0,u.iterateExtraOptions)(l,d+".",p,m);else if(typeof l=="string"||typeof l=="number")m(d,l.toString());else{if(typeof l!="boolean")throw new Error("Can't handle extra config type: "+typeof l);m(d,l?"1":"0")}})}},9544:function(v,u,b){var g,p=this&&this.__createBinding||(Object.create?function(P,R,D,$){$===void 0&&($=D);var M=Object.getOwnPropertyDescriptor(R,D);M&&!("get"in M?!R.__esModule:M.writable||M.configurable)||(M={enumerable:!0,get:function(){return R[D]}}),Object.defineProperty(P,$,M)}:function(P,R,D,$){$===void 0&&($=D),P[$]=R[D]}),m=this&&this.__setModuleDefault||(Object.create?function(P,R){Object.defineProperty(P,"default",{enumerable:!0,value:R})}:function(P,R){P.default=R}),s=this&&this.__importStar||function(P){if(P&&P.__esModule)return P;var R={};if(P!=null)for(var D in P)D!=="default"&&Object.prototype.hasOwnProperty.call(P,D)&&p(R,P,D);return m(R,P),R};Object.defineProperty(u,"__esModule",{value:!0}),u.endProfiling=u.run=u.releaseSession=u.createSession=u.createSessionFinalize=u.createSessionAllocate=u.initOrt=u.initWasm=void 0;const l=b(8453),d=b(7675),a=s(b(1259)),o=b(263),t=()=>!!l.env.wasm.proxy&&typeof document<"u";let e,n,r,i=!1,c=!1,f=!1;const y=[],w=[],x=[],_=[],S=[],I=[],O=()=>{if(i||!c||f||!e)throw new Error("worker not ready")},T=P=>{switch(P.data.type){case"init-wasm":i=!1,P.data.err?(f=!0,n[1](P.data.err)):(c=!0,n[0]());break;case"init-ort":P.data.err?r[1](P.data.err):r[0]();break;case"create_allocate":P.data.err?y.shift()[1](P.data.err):y.shift()[0](P.data.out);break;case"create_finalize":P.data.err?w.shift()[1](P.data.err):w.shift()[0](P.data.out);break;case"create":P.data.err?x.shift()[1](P.data.err):x.shift()[0](P.data.out);break;case"release":P.data.err?_.shift()[1](P.data.err):_.shift()[0]();break;case"run":P.data.err?S.shift()[1](P.data.err):S.shift()[0](P.data.out);break;case"end-profiling":P.data.err?I.shift()[1](P.data.err):I.shift()[0]()}},A=typeof document<"u"?(g=document==null?void 0:document.currentScript)===null||g===void 0?void 0:g.src:void 0;u.initWasm=async()=>{if(t()){if(c)return;if(i)throw new Error("multiple calls to 'initWasm()' detected.");if(f)throw new Error("previous call to 'initWasm()' failed.");return i=!0,l.env.wasm.wasmPaths===void 0&&A&&A.indexOf("blob:")!==0&&(l.env.wasm.wasmPaths=A.substr(0,+A.lastIndexOf("/")+1)),new Promise((P,R)=>{e==null||e.terminate(),e=b(8050).Z(),e.onmessage=T,n=[P,R];const D={type:"init-wasm",in:l.env.wasm};e.postMessage(D)})}return(0,o.initializeWebAssembly)(l.env.wasm)},u.initOrt=async(P,R)=>{if(t())return O(),new Promise((D,$)=>{r=[D,$];const M={type:"init-ort",in:{numThreads:P,loggingLevel:R}};e.postMessage(M)});a.initOrt(P,R),await(0,d.init)((0,o.getInstance)())},u.createSessionAllocate=async P=>t()?(O(),new Promise((R,D)=>{y.push([R,D]);const $={type:"create_allocate",in:{model:P}};e.postMessage($,[P.buffer])})):a.createSessionAllocate(P),u.createSessionFinalize=async(P,R)=>t()?(O(),new Promise((D,$)=>{w.push([D,$]);const M={type:"create_finalize",in:{modeldata:P,options:R}};e.postMessage(M)})):a.createSessionFinalize(P,R),u.createSession=async(P,R)=>t()?(O(),new Promise((D,$)=>{x.push([D,$]);const M={type:"create",in:{model:P,options:R}};e.postMessage(M,[P.buffer])})):a.createSession(P,R),u.releaseSession=async P=>{if(t())return O(),new Promise((R,D)=>{_.push([R,D]);const $={type:"release",in:P};e.postMessage($)});a.releaseSession(P)},u.run=async(P,R,D,$,M)=>t()?(O(),new Promise((C,k)=>{S.push([C,k]);const z={type:"run",in:{sessionId:P,inputIndices:R,inputs:D,outputIndices:$,options:M}};e.postMessage(z,a.extractTransferableBuffers(D))})):a.run(P,R,D,$,M),u.endProfiling=async P=>{if(t())return O(),new Promise((R,D)=>{I.push([R,D]);const $={type:"end-profiling",in:P};e.postMessage($)});a.endProfiling(P)}},7918:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.setRunOptions=void 0;const g=b(3899),p=b(9444),m=b(263);u.setRunOptions=s=>{const l=(0,m.getInstance)();let d=0;const a=[],o=s||{};try{if((s==null?void 0:s.logSeverityLevel)===void 0)o.logSeverityLevel=2;else if(typeof s.logSeverityLevel!="number"||!Number.isInteger(s.logSeverityLevel)||s.logSeverityLevel<0||s.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${s.logSeverityLevel}`);if((s==null?void 0:s.logVerbosityLevel)===void 0)o.logVerbosityLevel=0;else if(typeof s.logVerbosityLevel!="number"||!Number.isInteger(s.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${s.logVerbosityLevel}`);(s==null?void 0:s.terminate)===void 0&&(o.terminate=!1);let t=0;if((s==null?void 0:s.tag)!==void 0&&(t=(0,p.allocWasmString)(s.tag,a)),d=l._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,t),d===0)throw new Error("Can't create run options");return(s==null?void 0:s.extra)!==void 0&&(0,g.iterateExtraOptions)(s.extra,"",new WeakSet,(e,n)=>{const r=(0,p.allocWasmString)(e,a),i=(0,p.allocWasmString)(n,a);if(l._OrtAddRunConfigEntry(d,r,i)!==0)throw new Error(`Can't set a run config entry: ${e} - ${n}`)}),[d,a]}catch(t){throw d!==0&&l._OrtReleaseRunOptions(d),a.forEach(l._free),t}}},6640:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.OnnxruntimeWebAssemblySessionHandler=void 0;const g=b(2806),p=b(8453),m=b(2850),s=b(9544),l=b(7917);let d;u.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(a){const o=await fetch(a),t=await o.arrayBuffer();return(0,s.createSessionAllocate)(new Uint8Array(t))}async loadModel(a,o){if(d||(await(0,s.initOrt)(p.env.wasm.numThreads,(0,l.logLevelStringToEnum)(p.env.logLevel)),d=!0),typeof a=="string")if(typeof fetch>"u"){const t=await(0,m.promisify)(g.readFile)(a);[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSession)(t,o)}else{const t=await this.createSessionAllocate(a);[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSessionFinalize)(t,o)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,s.createSession)(a,o)}async dispose(){return(0,s.releaseSession)(this.sessionId)}async run(a,o,t){const e=[],n=[];Object.entries(a).forEach(f=>{const y=f[0],w=f[1],x=this.inputNames.indexOf(y);if(x===-1)throw new Error(`invalid input '${y}'`);e.push(w),n.push(x)});const r=[];Object.entries(o).forEach(f=>{const y=f[0],w=this.outputNames.indexOf(y);if(w===-1)throw new Error(`invalid output '${y}'`);r.push(w)});const i=await(0,s.run)(this.sessionId,n,e.map(f=>[f.type,f.dims,f.data]),r,t),c={};for(let f=0;f<i.length;f++)c[this.outputNames[r[f]]]=new p.Tensor(i[f][0],i[f][2],i[f][1]);return c}startProfiling(){}endProfiling(){(0,s.endProfiling)(this.sessionId)}}},7622:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.setSessionOptions=void 0;const g=b(3899),p=b(9444),m=b(263);u.setSessionOptions=s=>{var l,d,a,o;const t=(0,m.getInstance)();let e=0;const n=[],r=s||{};(i=>{i.extra||(i.extra={}),i.extra.session||(i.extra.session={});const c=i.extra.session;c.use_ort_model_bytes_directly||(c.use_ort_model_bytes_directly="1"),i.executionProviders&&i.executionProviders.some(f=>(typeof f=="string"?f:f.name)==="webgpu")&&(i.enableMemPattern=!1)})(r);try{const i=(_=>{switch(_){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${_}`)}})((l=r.graphOptimizationLevel)!==null&&l!==void 0?l:"all"),c=(_=>{switch(_){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${_}`)}})((d=r.executionMode)!==null&&d!==void 0?d:"sequential"),f=typeof r.logId=="string"?(0,p.allocWasmString)(r.logId,n):0,y=(a=r.logSeverityLevel)!==null&&a!==void 0?a:2;if(!Number.isInteger(y)||y<0||y>4)throw new Error(`log serverity level is not valid: ${y}`);const w=(o=r.logVerbosityLevel)!==null&&o!==void 0?o:0;if(!Number.isInteger(w)||w<0||w>4)throw new Error(`log verbosity level is not valid: ${w}`);const x=typeof r.optimizedModelFilePath=="string"?(0,p.allocWasmString)(r.optimizedModelFilePath,n):0;if(e=t._OrtCreateSessionOptions(i,!!r.enableCpuMemArena,!!r.enableMemPattern,c,!!r.enableProfiling,0,f,y,w,x),e===0)throw new Error("Can't create session options");return r.executionProviders&&((_,S,I)=>{for(const O of S){let T=typeof O=="string"?O:O.name;switch(T){case"xnnpack":T="XNNPACK";break;case"webgpu":T="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${T}`)}const A=(0,p.allocWasmString)(T,I);if((0,m.getInstance)()._OrtAppendExecutionProvider(_,A)!==0)throw new Error(`Can't append execution provider: ${T}`)}})(e,r.executionProviders,n),r.extra!==void 0&&(0,g.iterateExtraOptions)(r.extra,"",new WeakSet,(_,S)=>{const I=(0,p.allocWasmString)(_,n),O=(0,p.allocWasmString)(S,n);if(t._OrtAddSessionConfigEntry(e,I,O)!==0)throw new Error(`Can't set a session config entry: ${_} - ${S}`)}),[e,n]}catch(i){throw e!==0&&t._OrtReleaseSessionOptions(e),n.forEach(t._free),i}}},9444:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.allocWasmString=void 0;const g=b(263);u.allocWasmString=(p,m)=>{const s=(0,g.getInstance)(),l=s.lengthBytesUTF8(p)+1,d=s._malloc(l);return s.stringToUTF8(p,d,l),m.push(d),d}},7917:(v,u)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.logLevelStringToEnum=u.tensorTypeToTypedArrayConstructor=u.getTensorElementSize=u.tensorDataTypeEnumToString=u.tensorDataTypeStringToEnum=void 0,u.tensorDataTypeStringToEnum=b=>{switch(b){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${b}`)}},u.tensorDataTypeEnumToString=b=>{switch(b){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${b}`)}},u.getTensorElementSize=b=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][b],u.tensorTypeToTypedArrayConstructor=b=>{switch(b){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${b}`)}},u.logLevelStringToEnum=b=>{switch(b){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${b}`)}}},1259:(v,u,b)=>{Object.defineProperty(u,"__esModule",{value:!0}),u.extractTransferableBuffers=u.endProfiling=u.run=u.releaseSession=u.createSession=u.createSessionFinalize=u.createSessionAllocate=u.initOrt=void 0;const g=b(7918),p=b(7622),m=b(9444),s=b(7917),l=b(263);u.initOrt=(a,o)=>{const t=(0,l.getInstance)()._OrtInit(a,o);if(t!==0)throw new Error(`Can't initialize onnxruntime. error code = ${t}`)};const d=new Map;u.createSessionAllocate=a=>{const o=(0,l.getInstance)(),t=o._malloc(a.byteLength);return o.HEAPU8.set(a,t),[t,a.byteLength]},u.createSessionFinalize=(a,o)=>{const t=(0,l.getInstance)();let e=0,n=0,r=[];try{if([n,r]=(0,p.setSessionOptions)(o),e=t._OrtCreateSession(a[0],a[1],n),e===0)throw new Error("Can't create a session")}finally{t._free(a[0]),n!==0&&t._OrtReleaseSessionOptions(n),r.forEach(t._free)}const i=t._OrtGetInputCount(e),c=t._OrtGetOutputCount(e),f=[],y=[],w=[],x=[];for(let _=0;_<i;_++){const S=t._OrtGetInputName(e,_);if(S===0)throw new Error("Can't get an input name");y.push(S),f.push(t.UTF8ToString(S))}for(let _=0;_<c;_++){const S=t._OrtGetOutputName(e,_);if(S===0)throw new Error("Can't get an output name");x.push(S),w.push(t.UTF8ToString(S))}return d.set(e,[e,y,x]),[e,f,w]},u.createSession=(a,o)=>{const t=(0,u.createSessionAllocate)(a);return(0,u.createSessionFinalize)(t,o)},u.releaseSession=a=>{const o=(0,l.getInstance)(),t=d.get(a);if(!t)throw new Error("invalid session id");const e=t[0],n=t[1],r=t[2];n.forEach(o._OrtFree),r.forEach(o._OrtFree),o._OrtReleaseSession(e),d.delete(a)},u.run=async(a,o,t,e,n)=>{const r=(0,l.getInstance)(),i=d.get(a);if(!i)throw new Error("invalid session id");const c=i[0],f=i[1],y=i[2],w=o.length,x=e.length;let _=0,S=[];const I=[],O=[];try{[_,S]=(0,g.setRunOptions)(n);for(let $=0;$<w;$++){const M=t[$][0],C=t[$][1],k=t[$][2];let z,G;if(Array.isArray(k)){G=4*k.length,z=r._malloc(G),O.push(z);let ee=z/4;for(let oe=0;oe<k.length;oe++){if(typeof k[oe]!="string")throw new TypeError(`tensor data at index ${oe} is not a string`);r.HEAPU32[ee++]=(0,m.allocWasmString)(k[oe],O)}}else G=k.byteLength,z=r._malloc(G),O.push(z),r.HEAPU8.set(new Uint8Array(k.buffer,k.byteOffset,G),z);const Y=r.stackSave(),K=r.stackAlloc(4*C.length);try{let ee=K/4;C.forEach(Q=>r.HEAP32[ee++]=Q);const oe=r._OrtCreateTensor((0,s.tensorDataTypeStringToEnum)(M),z,G,K,C.length);if(oe===0)throw new Error("Can't create a tensor");I.push(oe)}finally{r.stackRestore(Y)}}const T=r.stackSave(),A=r.stackAlloc(4*w),P=r.stackAlloc(4*w),R=r.stackAlloc(4*x),D=r.stackAlloc(4*x);try{let $=A/4,M=P/4,C=R/4,k=D/4;for(let K=0;K<w;K++)r.HEAPU32[$++]=I[K],r.HEAPU32[M++]=f[o[K]];for(let K=0;K<x;K++)r.HEAPU32[C++]=0,r.HEAPU32[k++]=y[e[K]];let z=r._OrtRun(c,P,A,w,D,x,R,_);const G=r.jsepRunPromise;G&&G.then!==void 0&&(z=await G);const Y=[];if(z===0)for(let K=0;K<x;K++){const ee=r.HEAPU32[R/4+K],oe=r.stackSave(),Q=r.stackAlloc(16);let ae,re=0;try{if(z=r._OrtGetTensorData(ee,Q,Q+4,Q+8,Q+12),z!==0)throw new Error(`Can't access output tensor data. error code = ${z}`);let ne=Q/4;const fe=r.HEAPU32[ne++];re=r.HEAPU32[ne++];const ie=r.HEAPU32[ne++],me=r.HEAPU32[ne++],de=[];for(let le=0;le<me;le++)de.push(r.HEAPU32[ie/4+le]);r._OrtFree(ie);const be=de.length===0?1:de.reduce((le,we)=>le*we);if(ae=(0,s.tensorDataTypeEnumToString)(fe),ae==="string"){const le=[];let we=re/4;for(let Ee=0;Ee<be;Ee++){const Ce=r.HEAPU32[we++],ke=Ee===be-1?void 0:r.HEAPU32[we]-Ce;le.push(r.UTF8ToString(Ce,ke))}Y.push([ae,de,le])}else{const le=new((0,s.tensorTypeToTypedArrayConstructor)(ae))(be);new Uint8Array(le.buffer,le.byteOffset,le.byteLength).set(r.HEAPU8.subarray(re,re+le.byteLength)),Y.push([ae,de,le])}}finally{r.stackRestore(oe),ae==="string"&&re&&r._free(re),r._OrtReleaseTensor(ee)}}if(z===0)return Y;throw new Error(`failed to call OrtRun(). error code = ${z}.`)}finally{r.stackRestore(T)}}finally{I.forEach(r._OrtReleaseTensor),O.forEach(r._free),r._OrtReleaseRunOptions(_),S.forEach(r._free)}},u.endProfiling=a=>{const o=(0,l.getInstance)(),t=d.get(a);if(!t)throw new Error("invalid session id");const e=t[0],n=o._OrtEndProfiling(e);if(n===0)throw new Error("Can't get an profile file name");o._OrtFree(n)},u.extractTransferableBuffers=a=>{const o=[];for(const t of a){const e=t[2];!Array.isArray(e)&&e.buffer&&o.push(e.buffer)}return o}},263:function(v,u,b){var g=this&&this.__createBinding||(Object.create?function(n,r,i,c){c===void 0&&(c=i);var f=Object.getOwnPropertyDescriptor(r,i);f&&!("get"in f?!r.__esModule:f.writable||f.configurable)||(f={enumerable:!0,get:function(){return r[i]}}),Object.defineProperty(n,c,f)}:function(n,r,i,c){c===void 0&&(c=i),n[c]=r[i]}),p=this&&this.__setModuleDefault||(Object.create?function(n,r){Object.defineProperty(n,"default",{enumerable:!0,value:r})}:function(n,r){n.default=r}),m=this&&this.__importStar||function(n){if(n&&n.__esModule)return n;var r={};if(n!=null)for(var i in n)i!=="default"&&Object.prototype.hasOwnProperty.call(n,i)&&g(r,n,i);return p(r,n),r};Object.defineProperty(u,"__esModule",{value:!0}),u.dispose=u.getInstance=u.initializeWebAssembly=void 0;const s=m(b(6449)),l=b(932),d=b(3474);let a,o=!1,t=!1,e=!1;u.initializeWebAssembly=async n=>{if(o)return Promise.resolve();if(t)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(e)throw new Error("previous call to 'initializeWebAssembly()' failed.");t=!0;const r=n.initTimeout,i=n.numThreads,c=n.simd,f=i>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),y=c&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),w=n.wasmPaths,x=typeof w=="string"?w:void 0,_=((T,A)=>A?T?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":T?"ort-wasm-simd.wasm":"ort-wasm.wasm")(y,f),S=typeof w=="object"?w[_]:void 0;let I=!1;const O=[];if(r>0&&O.push(new Promise(T=>{setTimeout(()=>{I=!0,T()},r)})),O.push(new Promise((T,A)=>{const P=f?d:l,R={locateFile:(D,$)=>f&&D.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([b(4154)],{type:"text/javascript"})):D.endsWith(".wasm")?S||(x??$)+_:$+D};if(f)if(typeof Blob>"u")R.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const D=`var ortWasmThreaded=(function(){var _scriptDir;return ${P.toString()}})();`;R.mainScriptUrlOrBlob=new Blob([D],{type:"text/javascript"})}P(R).then(D=>{t=!1,o=!0,a=D,T()},D=>{t=!1,e=!0,A(D)})})),await Promise.race(O),I)throw new Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},u.getInstance=()=>{if(o&&a)return a;throw new Error("WebAssembly is not initialized yet.")},u.dispose=()=>{var n;!o||t||e||(t=!0,(n=a.PThread)===null||n===void 0||n.terminateAllThreads(),a=void 0,t=!1,o=!1,e=!0)}},8050:(v,u,b)=>{b.d(u,{Z:()=>m});var g=b(6614),p=b.n(g);function m(){return p()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:v=>{v.exports=function(u,b,g,p){var m=self||window;try{try{var s;try{s=new m.Blob([u])}catch{(s=new(m.BlobBuilder||m.WebKitBlobBuilder||m.MozBlobBuilder||m.MSBlobBuilder)).append(u),s=s.getBlob()}var l=m.URL||m.webkitURL,d=l.createObjectURL(s),a=new m[b](d,g);return l.revokeObjectURL(d),a}catch{return new m[b]("data:application/javascript,".concat(encodeURIComponent(u)),g)}}catch{if(!p)throw Error("Inline worker is not supported");return new m[b](p,g)}}},3474:(v,u,b)=>{var g,p=(g=(g=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(m){function s(){return G.buffer!=K&&le(G.buffer),ee}function l(){return G.buffer!=K&&le(G.buffer),oe}function d(){return G.buffer!=K&&le(G.buffer),Q}function a(){return G.buffer!=K&&le(G.buffer),ae}function o(){return G.buffer!=K&&le(G.buffer),re}var t,e,n;m=m||{},t||(t=m!==void 0?m:{}),t.ready=new Promise(function(E,N){e=E,n=N});var r,i,c,f,y,w,x=Object.assign({},t),_="./this.program",S=(E,N)=>{throw N},I=typeof window=="object",O=typeof importScripts=="function",T=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=t.ENVIRONMENT_IS_PTHREAD||!1,P="";function R(E){return t.locateFile?t.locateFile(E,P):P+E}if(T){let E;P=O?b(908).dirname(P)+"/":"//",w=()=>{y||(f=b(1384),y=b(908))},r=function(N,F){return w(),N=y.normalize(N),f.readFileSync(N,F?void 0:"utf8")},c=N=>((N=r(N,!0)).buffer||(N=new Uint8Array(N)),N),i=(N,F,V)=>{w(),N=y.normalize(N),f.readFile(N,function(q,X){q?V(q):F(X.buffer)})},1<process.argv.length&&(_=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(N){if(!(N instanceof Me))throw N}),process.on("unhandledRejection",function(N){throw N}),S=(N,F)=>{if(z)throw process.exitCode=N,F;F instanceof Me||k("exiting due to exception: "+F),process.exit(N)},t.inspect=function(){return"[Emscripten Module object]"};try{E=b(9925)}catch(N){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),N}b.g.Worker=E.Worker}else(I||O)&&(O?P=self.location.href:typeof document<"u"&&document.currentScript&&(P=document.currentScript.src),g&&(P=g),P=P.indexOf("blob:")!==0?P.substr(0,P.replace(/[?#].*/,"").lastIndexOf("/")+1):"",T||(r=E=>{var N=new XMLHttpRequest;return N.open("GET",E,!1),N.send(null),N.responseText},O&&(c=E=>{var N=new XMLHttpRequest;return N.open("GET",E,!1),N.responseType="arraybuffer",N.send(null),new Uint8Array(N.response)}),i=(E,N,F)=>{var V=new XMLHttpRequest;V.open("GET",E,!0),V.responseType="arraybuffer",V.onload=()=>{V.status==200||V.status==0&&V.response?N(V.response):F()},V.onerror=F,V.send(null)}));T&&typeof performance>"u"&&(b.g.performance=b(6953).performance);var D=console.log.bind(console),$=console.warn.bind(console);T&&(w(),D=E=>f.writeSync(1,E+`
`),$=E=>f.writeSync(2,E+`
`));var M,C=t.print||D,k=t.printErr||$;Object.assign(t,x),x=null,t.thisProgram&&(_=t.thisProgram),t.quit&&(S=t.quit),t.wasmBinary&&(M=t.wasmBinary);var z=t.noExitRuntime||!0;typeof WebAssembly!="object"&&Te("no native wasm support detected");var G,Y,K,ee,oe,Q,ae,re,ne=!1,fe=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function ie(E,N,F){var V=(N>>>=0)+F;for(F=N;E[F]&&!(F>=V);)++F;if(16<F-N&&E.buffer&&fe)return fe.decode(E.buffer instanceof SharedArrayBuffer?E.slice(N,F):E.subarray(N,F));for(V="";N<F;){var q=E[N++];if(128&q){var X=63&E[N++];if((224&q)==192)V+=String.fromCharCode((31&q)<<6|X);else{var ue=63&E[N++];65536>(q=(240&q)==224?(15&q)<<12|X<<6|ue:(7&q)<<18|X<<12|ue<<6|63&E[N++])?V+=String.fromCharCode(q):(q-=65536,V+=String.fromCharCode(55296|q>>10,56320|1023&q))}}else V+=String.fromCharCode(q)}return V}function me(E,N){return(E>>>=0)?ie(l(),E,N):""}function de(E,N,F,V){if(!(0<V))return 0;var q=F>>>=0;V=F+V-1;for(var X=0;X<E.length;++X){var ue=E.charCodeAt(X);if(55296<=ue&&57343>=ue&&(ue=65536+((1023&ue)<<10)|1023&E.charCodeAt(++X)),127>=ue){if(F>=V)break;N[F++>>>0]=ue}else{if(2047>=ue){if(F+1>=V)break;N[F++>>>0]=192|ue>>6}else{if(65535>=ue){if(F+2>=V)break;N[F++>>>0]=224|ue>>12}else{if(F+3>=V)break;N[F++>>>0]=240|ue>>18,N[F++>>>0]=128|ue>>12&63}N[F++>>>0]=128|ue>>6&63}N[F++>>>0]=128|63&ue}}return N[F>>>0]=0,F-q}function be(E){for(var N=0,F=0;F<E.length;++F){var V=E.charCodeAt(F);127>=V?N++:2047>=V?N+=2:55296<=V&&57343>=V?(N+=4,++F):N+=3}return N}function le(E){K=E,t.HEAP8=ee=new Int8Array(E),t.HEAP16=new Int16Array(E),t.HEAP32=Q=new Int32Array(E),t.HEAPU8=oe=new Uint8Array(E),t.HEAPU16=new Uint16Array(E),t.HEAPU32=ae=new Uint32Array(E),t.HEAPF32=new Float32Array(E),t.HEAPF64=re=new Float64Array(E)}A&&(K=t.buffer);var we=t.INITIAL_MEMORY||16777216;if(A)G=t.wasmMemory,K=t.buffer;else if(t.wasmMemory)G=t.wasmMemory;else if(!((G=new WebAssembly.Memory({initial:we/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw k("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),T&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");G&&(K=G.buffer),we=K.byteLength,le(K);var Ee,Ce=[],ke=[],Re=[];function Ne(){var E=t.preRun.shift();Ce.unshift(E)}var ye,Pe=0,xe=null;function Te(E){throw A?postMessage({cmd:"onAbort",arg:E}):t.onAbort&&t.onAbort(E),k(E="Aborted("+E+")"),ne=!0,E=new WebAssembly.RuntimeError(E+". Build with -sASSERTIONS for more info."),n(E),E}function Ue(){return ye.startsWith("data:application/octet-stream;base64,")}function ze(){var E=ye;try{if(E==ye&&M)return new Uint8Array(M);if(c)return c(E);throw"both async and sync fetching of the wasm failed"}catch(N){Te(N)}}ye="ort-wasm-threaded.wasm",Ue()||(ye=R(ye));var Fe={};function Me(E){this.name="ExitStatus",this.message="Program terminated with exit("+E+")",this.status=E}function Ge(E){(E=te.La[E])||Te(),te.Xa(E)}function We(E){var N=te.lb();if(!N)return 6;te.Ra.push(N),te.La[E.Ka]=N,N.Ka=E.Ka;var F={cmd:"run",start_routine:E.pb,arg:E.ib,pthread_ptr:E.Ka};return N.Qa=()=>{F.time=performance.now(),N.postMessage(F,E.vb)},N.loaded&&(N.Qa(),delete N.Qa),0}function qe(E){if(A)return he(1,1,E);z||(te.qb(),t.onExit&&t.onExit(E),ne=!0),S(E,new Me(E))}function Ke(E,N){if(!N&&A)throw j(E),"unwind";qe(E)}var te={Oa:[],Ra:[],$a:[],La:{},Ua:function(){A&&te.mb()},xb:function(){},mb:function(){te.receiveObjectTransfer=te.ob,te.threadInitTLS=te.Za,te.setExitStatus=te.Ya,z=!1},Ya:function(){},qb:function(){for(var E of Object.values(te.La))te.Xa(E);for(E of te.Oa)E.terminate();te.Oa=[]},Xa:function(E){var N=E.Ka;delete te.La[N],te.Oa.push(E),te.Ra.splice(te.Ra.indexOf(E),1),E.Ka=0,it(N)},ob:function(){},Za:function(){te.$a.forEach(E=>E())},nb:function(E,N){E.onmessage=F=>{var V=(F=F.data).cmd;if(E.Ka&&(te.kb=E.Ka),F.targetThread&&F.targetThread!=Je()){var q=te.La[F.yb];q?q.postMessage(F,F.transferList):k('Internal error! Worker sent a message "'+V+'" to target pthread '+F.targetThread+", but that thread no longer exists!")}else V==="processProxyingQueue"?et(F.queue):V==="spawnThread"?We(F):V==="cleanupThread"?Ge(F.thread):V==="killThread"?(F=F.thread,V=te.La[F],delete te.La[F],V.terminate(),it(F),te.Ra.splice(te.Ra.indexOf(V),1),V.Ka=0):V==="cancelThread"?te.La[F.thread].postMessage({cmd:"cancel"}):V==="loaded"?(E.loaded=!0,N&&N(E),E.Qa&&(E.Qa(),delete E.Qa)):V==="print"?C("Thread "+F.threadId+": "+F.text):V==="printErr"?k("Thread "+F.threadId+": "+F.text):V==="alert"?alert("Thread "+F.threadId+": "+F.text):F.target==="setimmediate"?E.postMessage(F):V==="onAbort"?t.onAbort&&t.onAbort(F.arg):V&&k("worker sent an unknown command "+V);te.kb=void 0},E.onerror=F=>{throw k("worker sent an error! "+F.filename+":"+F.lineno+": "+F.message),F},T&&(E.on("message",function(F){E.onmessage({data:F})}),E.on("error",function(F){E.onerror(F)}),E.on("detachedExit",function(){})),E.postMessage({cmd:"load",urlOrBlob:t.mainScriptUrlOrBlob||g,wasmMemory:G,wasmModule:Y})},hb:function(){var E=R("ort-wasm-threaded.worker.js");te.Oa.push(new Worker(E))},lb:function(){return te.Oa.length==0&&(te.hb(),te.nb(te.Oa[0])),te.Oa.pop()}};function L(E){for(;0<E.length;)E.shift()(t)}function j(E){if(A)return he(2,0,E);try{Ke(E)}catch(N){N instanceof Me||N=="unwind"||S(1,N)}}t.PThread=te,t.establishStackSpace=function(){var E=Je(),N=d()[E+44>>2>>>0];E=d()[E+48>>2>>>0],$t(N,N-E),Qe(N)};var H,W,J=[];function Z(E){this.Pa=E-24,this.gb=function(N){a()[this.Pa+4>>2>>>0]=N},this.cb=function(N){a()[this.Pa+8>>2>>>0]=N},this.eb=function(){d()[this.Pa>>2>>>0]=0},this.bb=function(){s()[this.Pa+12>>0>>>0]=0},this.fb=function(){s()[this.Pa+13>>0>>>0]=0},this.Ua=function(N,F){this.ab(),this.gb(N),this.cb(F),this.eb(),this.bb(),this.fb()},this.ab=function(){a()[this.Pa+16>>2>>>0]=0}}function se(E,N,F,V){return A?he(3,1,E,N,F,V):Se(E,N,F,V)}function Se(E,N,F,V){if(typeof SharedArrayBuffer>"u")return k("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var q=[];return A&&q.length===0?se(E,N,F,V):(E={pb:F,Ka:E,ib:V,vb:q},A?(E.wb="spawnThread",postMessage(E,q),0):We(E))}function Ae(E,N,F){return A?he(4,1,E,N,F):0}function Oe(E,N){if(A)return he(5,1,E,N)}function _e(E,N){if(A)return he(6,1,E,N)}function Ve(E,N,F){if(A)return he(7,1,E,N,F)}function je(E,N,F){return A?he(8,1,E,N,F):0}function B(E,N){if(A)return he(9,1,E,N)}function ce(E,N,F){if(A)return he(10,1,E,N,F)}function ge(E,N,F,V){if(A)return he(11,1,E,N,F,V)}function Le(E,N,F,V){if(A)return he(12,1,E,N,F,V)}function Xe(E,N,F,V){if(A)return he(13,1,E,N,F,V)}function ut(E){if(A)return he(14,1,E)}function lt(E,N){if(A)return he(15,1,E,N)}function ct(E,N,F){if(A)return he(16,1,E,N,F)}function et(E){Atomics.store(d(),E>>2,1),Je()&&Et(E),Atomics.compareExchange(d(),E>>2,1,0)}function dt(E){return a()[E>>>2]+4294967296*d()[E+4>>>2]}function pt(E,N,F,V,q,X){return A?he(17,1,E,N,F,V,q,X):-52}function ft(E,N,F,V,q,X){if(A)return he(18,1,E,N,F,V,q,X)}function ht(E){var N=be(E)+1,F=ot(N);return F&&de(E,s(),F,N),F}function gt(E,N,F){function V($e){return($e=$e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?$e[1]:"GMT"}if(A)return he(19,1,E,N,F);var q=new Date().getFullYear(),X=new Date(q,0,1),ue=new Date(q,6,1);q=X.getTimezoneOffset();var Ie=ue.getTimezoneOffset(),Be=Math.max(q,Ie);d()[E>>2>>>0]=60*Be,d()[N>>2>>>0]=+(q!=Ie),E=V(X),N=V(ue),E=ht(E),N=ht(N),Ie<q?(a()[F>>2>>>0]=E,a()[F+4>>2>>>0]=N):(a()[F>>2>>>0]=N,a()[F+4>>2>>>0]=E)}function he(E,N){var F=arguments.length-2,V=arguments;return function(q){var X=at();return q=q(),Qe(X),q}(()=>{for(var q=st(8*F),X=q>>3,ue=0;ue<F;ue++){var Ie=V[2+ue];o()[X+ue>>>0]=Ie}return At(E,F,q,N)})}t.invokeEntryPoint=function(E,N){var F=J[E];F||(E>=J.length&&(J.length=E+1),J[E]=F=Ee.get(E)),E=F(N),z?te.Ya(E):Pt(E)},t.executeNotifiedProxyingQueue=et,W=T?()=>{var E=process.hrtime();return 1e3*E[0]+E[1]/1e6}:A?()=>performance.now()-t.__performance_now_clock_drift:()=>performance.now();var tt,nt=[],rt={};function mt(){if(!tt){var E,N={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:_||"./this.program"};for(E in rt)rt[E]===void 0?delete N[E]:N[E]=rt[E];var F=[];for(E in N)F.push(E+"="+N[E]);tt=F}return tt}function bt(E,N){if(A)return he(20,1,E,N);var F=0;return mt().forEach(function(V,q){var X=N+F;for(q=a()[E+4*q>>2>>>0]=X,X=0;X<V.length;++X)s()[q++>>0>>>0]=V.charCodeAt(X);s()[q>>0>>>0]=0,F+=V.length+1}),0}function yt(E,N){if(A)return he(21,1,E,N);var F=mt();a()[E>>2>>>0]=F.length;var V=0;return F.forEach(function(q){V+=q.length+1}),a()[N>>2>>>0]=V,0}function vt(E){return A?he(22,1,E):52}function wt(E,N,F,V){return A?he(23,1,E,N,F,V):52}function _t(E,N,F,V,q){return A?he(24,1,E,N,F,V,q):70}var Nt=[null,[],[]];function xt(E,N,F,V){if(A)return he(25,1,E,N,F,V);for(var q=0,X=0;X<F;X++){var ue=a()[N>>2>>>0],Ie=a()[N+4>>2>>>0];N+=8;for(var Be=0;Be<Ie;Be++){var $e=l()[ue+Be>>>0],De=Nt[E];$e===0||$e===10?((E===1?C:k)(ie(De,0)),De.length=0):De.push($e)}q+=Ie}return a()[V>>2>>>0]=q,0}function Ye(E){return E%4==0&&(E%100!=0||E%400==0)}var Tt=[31,29,31,30,31,30,31,31,30,31,30,31],St=[31,28,31,30,31,30,31,31,30,31,30,31];function Ot(E,N,F,V){function q(U,pe,ve){for(U=typeof U=="number"?U.toString():U||"";U.length<pe;)U=ve[0]+U;return U}function X(U,pe){return q(U,pe,"0")}function ue(U,pe){function ve(Rt){return 0>Rt?-1:0<Rt?1:0}var He;return(He=ve(U.getFullYear()-pe.getFullYear()))===0&&(He=ve(U.getMonth()-pe.getMonth()))===0&&(He=ve(U.getDate()-pe.getDate())),He}function Ie(U){switch(U.getDay()){case 0:return new Date(U.getFullYear()-1,11,29);case 1:return U;case 2:return new Date(U.getFullYear(),0,3);case 3:return new Date(U.getFullYear(),0,2);case 4:return new Date(U.getFullYear(),0,1);case 5:return new Date(U.getFullYear()-1,11,31);case 6:return new Date(U.getFullYear()-1,11,30)}}function Be(U){var pe=U.Ma;for(U=new Date(new Date(U.Na+1900,0,1).getTime());0<pe;){var ve=U.getMonth(),He=(Ye(U.getFullYear())?Tt:St)[ve];if(!(pe>He-U.getDate())){U.setDate(U.getDate()+pe);break}pe-=He-U.getDate()+1,U.setDate(1),11>ve?U.setMonth(ve+1):(U.setMonth(0),U.setFullYear(U.getFullYear()+1))}return ve=new Date(U.getFullYear()+1,0,4),pe=Ie(new Date(U.getFullYear(),0,4)),ve=Ie(ve),0>=ue(pe,U)?0>=ue(ve,U)?U.getFullYear()+1:U.getFullYear():U.getFullYear()-1}var $e=d()[V+40>>2>>>0];for(var De in V={tb:d()[V>>2>>>0],sb:d()[V+4>>2>>>0],Sa:d()[V+8>>2>>>0],Va:d()[V+12>>2>>>0],Ta:d()[V+16>>2>>>0],Na:d()[V+20>>2>>>0],Ja:d()[V+24>>2>>>0],Ma:d()[V+28>>2>>>0],zb:d()[V+32>>2>>>0],rb:d()[V+36>>2>>>0],ub:$e?me($e):""},F=me(F),$e={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})F=F.replace(new RegExp(De,"g"),$e[De]);var Ct="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),kt="January February March April May June July August September October November December".split(" ");for(De in $e={"%a":function(U){return Ct[U.Ja].substring(0,3)},"%A":function(U){return Ct[U.Ja]},"%b":function(U){return kt[U.Ta].substring(0,3)},"%B":function(U){return kt[U.Ta]},"%C":function(U){return X((U.Na+1900)/100|0,2)},"%d":function(U){return X(U.Va,2)},"%e":function(U){return q(U.Va,2," ")},"%g":function(U){return Be(U).toString().substring(2)},"%G":function(U){return Be(U)},"%H":function(U){return X(U.Sa,2)},"%I":function(U){return(U=U.Sa)==0?U=12:12<U&&(U-=12),X(U,2)},"%j":function(U){for(var pe=0,ve=0;ve<=U.Ta-1;pe+=(Ye(U.Na+1900)?Tt:St)[ve++]);return X(U.Va+pe,3)},"%m":function(U){return X(U.Ta+1,2)},"%M":function(U){return X(U.sb,2)},"%n":function(){return`
`},"%p":function(U){return 0<=U.Sa&&12>U.Sa?"AM":"PM"},"%S":function(U){return X(U.tb,2)},"%t":function(){return"	"},"%u":function(U){return U.Ja||7},"%U":function(U){return X(Math.floor((U.Ma+7-U.Ja)/7),2)},"%V":function(U){var pe=Math.floor((U.Ma+7-(U.Ja+6)%7)/7);if(2>=(U.Ja+371-U.Ma-2)%7&&pe++,pe)pe==53&&((ve=(U.Ja+371-U.Ma)%7)==4||ve==3&&Ye(U.Na)||(pe=1));else{pe=52;var ve=(U.Ja+7-U.Ma-1)%7;(ve==4||ve==5&&Ye(U.Na%400-1))&&pe++}return X(pe,2)},"%w":function(U){return U.Ja},"%W":function(U){return X(Math.floor((U.Ma+7-(U.Ja+6)%7)/7),2)},"%y":function(U){return(U.Na+1900).toString().substring(2)},"%Y":function(U){return U.Na+1900},"%z":function(U){var pe=0<=(U=U.rb);return U=Math.abs(U)/60,(pe?"+":"-")+("0000"+(U/60*100+U%60)).slice(-4)},"%Z":function(U){return U.ub},"%%":function(){return"%"}},F=F.replace(/%%/g,"\0\0"),$e)F.includes(De)&&(F=F.replace(new RegExp(De,"g"),$e[De](V)));return De=function(U){var pe=Array(be(U)+1);return de(U,pe,0,pe.length),pe}(F=F.replace(/\0\0/g,"%")),De.length>N?0:(function(U,pe){s().set(U,pe>>>0)}(De,E),De.length-1)}te.Ua();var Lt=[null,qe,j,se,Ae,Oe,_e,Ve,je,B,ce,ge,Le,Xe,ut,lt,ct,pt,ft,gt,bt,yt,vt,wt,_t,xt],Ft={b:function(E){return ot(E+24)+24},c:function(E,N,F){throw new Z(E).Ua(N,F),E},L:function(E){It(E,!O,1,!I),te.Za()},l:function(E){A?postMessage({cmd:"cleanupThread",thread:E}):Ge(E)},D:Se,i:Ae,R:Oe,z:_e,B:Ve,T:je,P:B,I:ce,O:ge,p:Le,A:Xe,x:ut,Q:lt,y:ct,r:function(){},j:function(){Te("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){Te("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(E,N,F,V){if(E==N)setTimeout(()=>et(V));else if(A)postMessage({targetThread:E,cmd:"processProxyingQueue",queue:V});else{if(!(E=te.La[E]))return;E.postMessage({cmd:"processProxyingQueue",queue:V})}return 1},K:function(){return-1},W:function(E,N){E=new Date(1e3*dt(E)),d()[N>>2>>>0]=E.getUTCSeconds(),d()[N+4>>2>>>0]=E.getUTCMinutes(),d()[N+8>>2>>>0]=E.getUTCHours(),d()[N+12>>2>>>0]=E.getUTCDate(),d()[N+16>>2>>>0]=E.getUTCMonth(),d()[N+20>>2>>>0]=E.getUTCFullYear()-1900,d()[N+24>>2>>>0]=E.getUTCDay(),E=(E.getTime()-Date.UTC(E.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,d()[N+28>>2>>>0]=E},X:function(E,N){E=new Date(1e3*dt(E)),d()[N>>2>>>0]=E.getSeconds(),d()[N+4>>2>>>0]=E.getMinutes(),d()[N+8>>2>>>0]=E.getHours(),d()[N+12>>2>>>0]=E.getDate(),d()[N+16>>2>>>0]=E.getMonth(),d()[N+20>>2>>>0]=E.getFullYear()-1900,d()[N+24>>2>>>0]=E.getDay();var F=new Date(E.getFullYear(),0,1),V=(E.getTime()-F.getTime())/864e5|0;d()[N+28>>2>>>0]=V,d()[N+36>>2>>>0]=-60*E.getTimezoneOffset(),V=new Date(E.getFullYear(),6,1).getTimezoneOffset(),E=0|(V!=(F=F.getTimezoneOffset())&&E.getTimezoneOffset()==Math.min(F,V)),d()[N+32>>2>>>0]=E},Y:function(E){var N=new Date(d()[E+20>>2>>>0]+1900,d()[E+16>>2>>>0],d()[E+12>>2>>>0],d()[E+8>>2>>>0],d()[E+4>>2>>>0],d()[E>>2>>>0],0),F=d()[E+32>>2>>>0],V=N.getTimezoneOffset(),q=new Date(N.getFullYear(),0,1),X=new Date(N.getFullYear(),6,1).getTimezoneOffset(),ue=q.getTimezoneOffset(),Ie=Math.min(ue,X);return 0>F?d()[E+32>>2>>>0]=+(X!=ue&&Ie==V):0<F!=(Ie==V)&&(X=Math.max(ue,X),N.setTime(N.getTime()+6e4*((0<F?Ie:X)-V))),d()[E+24>>2>>>0]=N.getDay(),F=(N.getTime()-q.getTime())/864e5|0,d()[E+28>>2>>>0]=F,d()[E>>2>>>0]=N.getSeconds(),d()[E+4>>2>>>0]=N.getMinutes(),d()[E+8>>2>>>0]=N.getHours(),d()[E+12>>2>>>0]=N.getDate(),d()[E+16>>2>>>0]=N.getMonth(),N.getTime()/1e3|0},G:pt,H:ft,Z:function E(N,F,V){E.jb||(E.jb=!0,gt(N,F,V))},d:function(){Te("")},m:function(){if(!T&&!O){var E="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";H||(H={}),H[E]||(H[E]=1,T&&(E="warning: "+E),k(E))}},w:function(){return 4294901760},f:W,S:function(E,N,F){l().copyWithin(E>>>0,N>>>0,N+F>>>0)},g:function(){return T?b(3993).cpus().length:navigator.hardwareConcurrency},J:function(E,N,F){nt.length=N,F>>=3;for(var V=0;V<N;V++)nt[V]=o()[F+V>>>0];return(0>E?Fe[-E-1]:Lt[E]).apply(null,nt)},v:function(E){var N=l().length;if((E>>>=0)<=N||4294901760<E)return!1;for(var F=1;4>=F;F*=2){var V=N*(1+.2/F);V=Math.min(V,E+100663296);var q=Math;V=Math.max(E,V),q=q.min.call(q,4294901760,V+(65536-V%65536)%65536);e:{try{G.grow(q-K.byteLength+65535>>>16),le(G.buffer);var X=1;break e}catch{}X=void 0}if(X)return!0}return!1},U:function(){throw"unwind"},M:bt,N:yt,k:Ke,h:vt,o:wt,t:_t,n:xt,u:function E(N,F){E.Wa||(E.Wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var q=new Uint8Array(1);return()=>(crypto.getRandomValues(q),q[0])}if(T)try{var X=b(760);return()=>X.randomBytes(1)[0]}catch{}return()=>Te("randomDevice")}());for(var V=0;V<F;V++)s()[N+V>>0>>>0]=E.Wa();return 0},a:G||t.wasmMemory,C:Ot,e:function(E,N,F,V){return Ot(E,N,F,V)}};(function(){function E(q,X){t.asm=q.exports,te.$a.push(t.asm.wa),Ee=t.asm.za,ke.unshift(t.asm._),Y=X,A||(Pe--,t.monitorRunDependencies&&t.monitorRunDependencies(Pe),Pe==0&&xe&&(q=xe,xe=null,q()))}function N(q){E(q.instance,q.module)}function F(q){return function(){if(!M&&(I||O)){if(typeof fetch=="function"&&!ye.startsWith("file://"))return fetch(ye,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+ye+"'";return X.arrayBuffer()}).catch(function(){return ze()});if(i)return new Promise(function(X,ue){i(ye,function(Ie){X(new Uint8Array(Ie))},ue)})}return Promise.resolve().then(function(){return ze()})}().then(function(X){return WebAssembly.instantiate(X,V)}).then(function(X){return X}).then(q,function(X){k("failed to asynchronously prepare wasm: "+X),Te(X)})}var V={a:Ft};if(A||(Pe++,t.monitorRunDependencies&&t.monitorRunDependencies(Pe)),t.instantiateWasm)try{return t.instantiateWasm(V,E)}catch(q){return k("Module.instantiateWasm callback failed with error: "+q),!1}(M||typeof WebAssembly.instantiateStreaming!="function"||Ue()||ye.startsWith("file://")||T||typeof fetch!="function"?F(N):fetch(ye,{credentials:"same-origin"}).then(function(q){return WebAssembly.instantiateStreaming(q,V).then(N,function(X){return k("wasm streaming compile failed: "+X),k("falling back to ArrayBuffer instantiation"),F(N)})})).catch(n)})(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm._).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.$).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.aa).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.ba).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.ca).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.da).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.ea).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.fa).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.ga).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.ha).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.ia).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.ja).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.ka).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.la).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ma).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.na).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.oa).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.pa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.qa).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ra).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.sa).apply(null,arguments)};var Je=t._pthread_self=function(){return(Je=t._pthread_self=t.asm.ta).apply(null,arguments)},ot=t._malloc=function(){return(ot=t._malloc=t.asm.ua).apply(null,arguments)};t._free=function(){return(t._free=t.asm.va).apply(null,arguments)},t.__emscripten_tls_init=function(){return(t.__emscripten_tls_init=t.asm.wa).apply(null,arguments)};var It=t.__emscripten_thread_init=function(){return(It=t.__emscripten_thread_init=t.asm.xa).apply(null,arguments)};t.__emscripten_thread_crashed=function(){return(t.__emscripten_thread_crashed=t.asm.ya).apply(null,arguments)};var Ze,At=t._emscripten_run_in_main_runtime_thread_js=function(){return(At=t._emscripten_run_in_main_runtime_thread_js=t.asm.Aa).apply(null,arguments)},Et=t.__emscripten_proxy_execute_task_queue=function(){return(Et=t.__emscripten_proxy_execute_task_queue=t.asm.Ba).apply(null,arguments)},it=t.__emscripten_thread_free_data=function(){return(it=t.__emscripten_thread_free_data=t.asm.Ca).apply(null,arguments)},Pt=t.__emscripten_thread_exit=function(){return(Pt=t.__emscripten_thread_exit=t.asm.Da).apply(null,arguments)},$t=t._emscripten_stack_set_limits=function(){return($t=t._emscripten_stack_set_limits=t.asm.Ea).apply(null,arguments)},at=t.stackSave=function(){return(at=t.stackSave=t.asm.Fa).apply(null,arguments)},Qe=t.stackRestore=function(){return(Qe=t.stackRestore=t.asm.Ga).apply(null,arguments)},st=t.stackAlloc=function(){return(st=t.stackAlloc=t.asm.Ha).apply(null,arguments)};function Dt(){function E(){if(!Ze&&(Ze=!0,t.calledRun=!0,!ne)&&(A||L(ke),e(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),!A)){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;){var N=t.postRun.shift();Re.unshift(N)}L(Re)}}if(!(0<Pe))if(A)e(t),A||L(ke),postMessage({cmd:"loaded"});else{if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)Ne();L(Ce),0<Pe||(t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),E()},1)):E())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.Ia).apply(null,arguments)},t.UTF8ToString=me,t.stringToUTF8=function(E,N,F){return de(E,l(),N,F)},t.lengthBytesUTF8=be,t.keepRuntimeAlive=function(){return z},t.wasmMemory=G,t.stackSave=at,t.stackRestore=Qe,t.stackAlloc=st,t.ExitStatus=Me,t.PThread=te,xe=function E(){Ze||Dt(),Ze||(xe=E)},t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return Dt(),m.ready});v.exports=p},932:(v,u,b)=>{var g,p=(g=(g=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(m){var s,l,d;m=m||{},s||(s=m!==void 0?m:{}),s.ready=new Promise(function(L,j){l=L,d=j});var a,o,t,e,n,r,i=Object.assign({},s),c="./this.program",f=(L,j)=>{throw j},y=typeof window=="object",w=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_="";x?(_=w?b(908).dirname(_)+"/":"//",r=()=>{n||(e=b(1384),n=b(908))},a=function(L,j){return r(),L=n.normalize(L),e.readFileSync(L,j?void 0:"utf8")},t=L=>((L=a(L,!0)).buffer||(L=new Uint8Array(L)),L),o=(L,j,H)=>{r(),L=n.normalize(L),e.readFile(L,function(W,J){W?H(W):j(J.buffer)})},1<process.argv.length&&(c=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(L){if(!(L instanceof we))throw L}),process.on("unhandledRejection",function(L){throw L}),f=(L,j)=>{if(T)throw process.exitCode=L,j;j instanceof we||O("exiting due to exception: "+j),process.exit(L)},s.inspect=function(){return"[Emscripten Module object]"}):(y||w)&&(w?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),g&&(_=g),_=_.indexOf("blob:")!==0?_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):"",a=L=>{var j=new XMLHttpRequest;return j.open("GET",L,!1),j.send(null),j.responseText},w&&(t=L=>{var j=new XMLHttpRequest;return j.open("GET",L,!1),j.responseType="arraybuffer",j.send(null),new Uint8Array(j.response)}),o=(L,j,H)=>{var W=new XMLHttpRequest;W.open("GET",L,!0),W.responseType="arraybuffer",W.onload=()=>{W.status==200||W.status==0&&W.response?j(W.response):H()},W.onerror=H,W.send(null)});var S,I=s.print||console.log.bind(console),O=s.printErr||console.warn.bind(console);Object.assign(s,i),i=null,s.thisProgram&&(c=s.thisProgram),s.quit&&(f=s.quit),s.wasmBinary&&(S=s.wasmBinary);var T=s.noExitRuntime||!0;typeof WebAssembly!="object"&&me("no native wasm support detected");var A,P,R,D,$,M,C=!1,k=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function z(L,j,H){var W=(j>>>=0)+H;for(H=j;L[H]&&!(H>=W);)++H;if(16<H-j&&L.buffer&&k)return k.decode(L.subarray(j,H));for(W="";j<H;){var J=L[j++];if(128&J){var Z=63&L[j++];if((224&J)==192)W+=String.fromCharCode((31&J)<<6|Z);else{var se=63&L[j++];65536>(J=(240&J)==224?(15&J)<<12|Z<<6|se:(7&J)<<18|Z<<12|se<<6|63&L[j++])?W+=String.fromCharCode(J):(J-=65536,W+=String.fromCharCode(55296|J>>10,56320|1023&J))}}else W+=String.fromCharCode(J)}return W}function G(L,j){return(L>>>=0)?z(D,L,j):""}function Y(L,j,H,W){if(!(0<W))return 0;var J=H>>>=0;W=H+W-1;for(var Z=0;Z<L.length;++Z){var se=L.charCodeAt(Z);if(55296<=se&&57343>=se&&(se=65536+((1023&se)<<10)|1023&L.charCodeAt(++Z)),127>=se){if(H>=W)break;j[H++>>>0]=se}else{if(2047>=se){if(H+1>=W)break;j[H++>>>0]=192|se>>6}else{if(65535>=se){if(H+2>=W)break;j[H++>>>0]=224|se>>12}else{if(H+3>=W)break;j[H++>>>0]=240|se>>18,j[H++>>>0]=128|se>>12&63}j[H++>>>0]=128|se>>6&63}j[H++>>>0]=128|63&se}}return j[H>>>0]=0,H-J}function K(L){for(var j=0,H=0;H<L.length;++H){var W=L.charCodeAt(H);127>=W?j++:2047>=W?j+=2:55296<=W&&57343>=W?(j+=4,++H):j+=3}return j}function ee(){var L=A.buffer;P=L,s.HEAP8=R=new Int8Array(L),s.HEAP16=new Int16Array(L),s.HEAP32=$=new Int32Array(L),s.HEAPU8=D=new Uint8Array(L),s.HEAPU16=new Uint16Array(L),s.HEAPU32=M=new Uint32Array(L),s.HEAPF32=new Float32Array(L),s.HEAPF64=new Float64Array(L)}var oe=[],Q=[],ae=[];function re(){var L=s.preRun.shift();oe.unshift(L)}var ne,fe=0,ie=null;function me(L){throw s.onAbort&&s.onAbort(L),O(L="Aborted("+L+")"),C=!0,L=new WebAssembly.RuntimeError(L+". Build with -sASSERTIONS for more info."),d(L),L}function de(){return ne.startsWith("data:application/octet-stream;base64,")}if(ne="ort-wasm.wasm",!de()){var be=ne;ne=s.locateFile?s.locateFile(be,_):_+be}function le(){var L=ne;try{if(L==ne&&S)return new Uint8Array(S);if(t)return t(L);throw"both async and sync fetching of the wasm failed"}catch(j){me(j)}}function we(L){this.name="ExitStatus",this.message="Program terminated with exit("+L+")",this.status=L}function Ee(L){for(;0<L.length;)L.shift()(s)}function Ce(L){this.sa=L-24,this.Ia=function(j){M[this.sa+4>>2>>>0]=j},this.Ba=function(j){M[this.sa+8>>2>>>0]=j},this.Ga=function(){$[this.sa>>2>>>0]=0},this.Aa=function(){R[this.sa+12>>0>>>0]=0},this.Ha=function(){R[this.sa+13>>0>>>0]=0},this.ya=function(j,H){this.za(),this.Ia(j),this.Ba(H),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function ke(L){var j=K(L)+1,H=Me(j);return H&&Y(L,R,H,j),H}var Re={};function Ne(){if(!ye){var L,j={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:c||"./this.program"};for(L in Re)Re[L]===void 0?delete j[L]:j[L]=Re[L];var H=[];for(L in j)H.push(L+"="+j[L]);ye=H}return ye}var ye,Pe=[null,[],[]];function xe(L){return L%4==0&&(L%100!=0||L%400==0)}var Te=[31,29,31,30,31,30,31,31,30,31,30,31],Ue=[31,28,31,30,31,30,31,31,30,31,30,31];function ze(L,j,H,W){function J(B,ce,ge){for(B=typeof B=="number"?B.toString():B||"";B.length<ce;)B=ge[0]+B;return B}function Z(B,ce){return J(B,ce,"0")}function se(B,ce){function ge(Xe){return 0>Xe?-1:0<Xe?1:0}var Le;return(Le=ge(B.getFullYear()-ce.getFullYear()))===0&&(Le=ge(B.getMonth()-ce.getMonth()))===0&&(Le=ge(B.getDate()-ce.getDate())),Le}function Se(B){switch(B.getDay()){case 0:return new Date(B.getFullYear()-1,11,29);case 1:return B;case 2:return new Date(B.getFullYear(),0,3);case 3:return new Date(B.getFullYear(),0,2);case 4:return new Date(B.getFullYear(),0,1);case 5:return new Date(B.getFullYear()-1,11,31);case 6:return new Date(B.getFullYear()-1,11,30)}}function Ae(B){var ce=B.qa;for(B=new Date(new Date(B.ra+1900,0,1).getTime());0<ce;){var ge=B.getMonth(),Le=(xe(B.getFullYear())?Te:Ue)[ge];if(!(ce>Le-B.getDate())){B.setDate(B.getDate()+ce);break}ce-=Le-B.getDate()+1,B.setDate(1),11>ge?B.setMonth(ge+1):(B.setMonth(0),B.setFullYear(B.getFullYear()+1))}return ge=new Date(B.getFullYear()+1,0,4),ce=Se(new Date(B.getFullYear(),0,4)),ge=Se(ge),0>=se(ce,B)?0>=se(ge,B)?B.getFullYear()+1:B.getFullYear():B.getFullYear()-1}var Oe=$[W+40>>2>>>0];for(var _e in W={Ea:$[W>>2>>>0],Da:$[W+4>>2>>>0],ta:$[W+8>>2>>>0],va:$[W+12>>2>>>0],ua:$[W+16>>2>>>0],ra:$[W+20>>2>>>0],la:$[W+24>>2>>>0],qa:$[W+28>>2>>>0],Ja:$[W+32>>2>>>0],Ca:$[W+36>>2>>>0],Fa:Oe?G(Oe):""},H=G(H),Oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})H=H.replace(new RegExp(_e,"g"),Oe[_e]);var Ve="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),je="January February March April May June July August September October November December".split(" ");for(_e in Oe={"%a":function(B){return Ve[B.la].substring(0,3)},"%A":function(B){return Ve[B.la]},"%b":function(B){return je[B.ua].substring(0,3)},"%B":function(B){return je[B.ua]},"%C":function(B){return Z((B.ra+1900)/100|0,2)},"%d":function(B){return Z(B.va,2)},"%e":function(B){return J(B.va,2," ")},"%g":function(B){return Ae(B).toString().substring(2)},"%G":function(B){return Ae(B)},"%H":function(B){return Z(B.ta,2)},"%I":function(B){return(B=B.ta)==0?B=12:12<B&&(B-=12),Z(B,2)},"%j":function(B){for(var ce=0,ge=0;ge<=B.ua-1;ce+=(xe(B.ra+1900)?Te:Ue)[ge++]);return Z(B.va+ce,3)},"%m":function(B){return Z(B.ua+1,2)},"%M":function(B){return Z(B.Da,2)},"%n":function(){return`
`},"%p":function(B){return 0<=B.ta&&12>B.ta?"AM":"PM"},"%S":function(B){return Z(B.Ea,2)},"%t":function(){return"	"},"%u":function(B){return B.la||7},"%U":function(B){return Z(Math.floor((B.qa+7-B.la)/7),2)},"%V":function(B){var ce=Math.floor((B.qa+7-(B.la+6)%7)/7);if(2>=(B.la+371-B.qa-2)%7&&ce++,ce)ce==53&&((ge=(B.la+371-B.qa)%7)==4||ge==3&&xe(B.ra)||(ce=1));else{ce=52;var ge=(B.la+7-B.qa-1)%7;(ge==4||ge==5&&xe(B.ra%400-1))&&ce++}return Z(ce,2)},"%w":function(B){return B.la},"%W":function(B){return Z(Math.floor((B.qa+7-(B.la+6)%7)/7),2)},"%y":function(B){return(B.ra+1900).toString().substring(2)},"%Y":function(B){return B.ra+1900},"%z":function(B){var ce=0<=(B=B.Ca);return B=Math.abs(B)/60,(ce?"+":"-")+("0000"+(B/60*100+B%60)).slice(-4)},"%Z":function(B){return B.Fa},"%%":function(){return"%"}},H=H.replace(/%%/g,"\0\0"),Oe)H.includes(_e)&&(H=H.replace(new RegExp(_e,"g"),Oe[_e](W)));return _e=function(B){var ce=Array(K(B)+1);return Y(B,ce,0,ce.length),ce}(H=H.replace(/\0\0/g,"%")),_e.length>j?0:(R.set(_e,L>>>0),_e.length-1)}var Fe={a:function(L){return Me(L+24)+24},b:function(L,j,H){throw new Ce(L).ya(j,H),L},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){me("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){me("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(L,j){L=new Date(1e3*(M[L>>>2]+4294967296*$[L+4>>>2])),$[j>>2>>>0]=L.getUTCSeconds(),$[j+4>>2>>>0]=L.getUTCMinutes(),$[j+8>>2>>>0]=L.getUTCHours(),$[j+12>>2>>>0]=L.getUTCDate(),$[j+16>>2>>>0]=L.getUTCMonth(),$[j+20>>2>>>0]=L.getUTCFullYear()-1900,$[j+24>>2>>>0]=L.getUTCDay(),$[j+28>>2>>>0]=(L.getTime()-Date.UTC(L.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(L,j){L=new Date(1e3*(M[L>>>2]+4294967296*$[L+4>>>2])),$[j>>2>>>0]=L.getSeconds(),$[j+4>>2>>>0]=L.getMinutes(),$[j+8>>2>>>0]=L.getHours(),$[j+12>>2>>>0]=L.getDate(),$[j+16>>2>>>0]=L.getMonth(),$[j+20>>2>>>0]=L.getFullYear()-1900,$[j+24>>2>>>0]=L.getDay();var H=new Date(L.getFullYear(),0,1);$[j+28>>2>>>0]=(L.getTime()-H.getTime())/864e5|0,$[j+36>>2>>>0]=-60*L.getTimezoneOffset();var W=new Date(L.getFullYear(),6,1).getTimezoneOffset();H=H.getTimezoneOffset(),$[j+32>>2>>>0]=0|(W!=H&&L.getTimezoneOffset()==Math.min(H,W))},O:function(L){var j=new Date($[L+20>>2>>>0]+1900,$[L+16>>2>>>0],$[L+12>>2>>>0],$[L+8>>2>>>0],$[L+4>>2>>>0],$[L>>2>>>0],0),H=$[L+32>>2>>>0],W=j.getTimezoneOffset(),J=new Date(j.getFullYear(),0,1),Z=new Date(j.getFullYear(),6,1).getTimezoneOffset(),se=J.getTimezoneOffset(),Se=Math.min(se,Z);return 0>H?$[L+32>>2>>>0]=+(Z!=se&&Se==W):0<H!=(Se==W)&&(Z=Math.max(se,Z),j.setTime(j.getTime()+6e4*((0<H?Se:Z)-W))),$[L+24>>2>>>0]=j.getDay(),$[L+28>>2>>>0]=(j.getTime()-J.getTime())/864e5|0,$[L>>2>>>0]=j.getSeconds(),$[L+4>>2>>>0]=j.getMinutes(),$[L+8>>2>>>0]=j.getHours(),$[L+12>>2>>>0]=j.getDate(),$[L+16>>2>>>0]=j.getMonth(),j.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function L(j,H,W){L.xa||(L.xa=!0,function(J,Z,se){function Se(je){return(je=je.toTimeString().match(/\(([A-Za-z ]+)\)$/))?je[1]:"GMT"}var Ae=new Date().getFullYear(),Oe=new Date(Ae,0,1),_e=new Date(Ae,6,1);Ae=Oe.getTimezoneOffset();var Ve=_e.getTimezoneOffset();$[J>>2>>>0]=60*Math.max(Ae,Ve),$[Z>>2>>>0]=+(Ae!=Ve),J=Se(Oe),Z=Se(_e),J=ke(J),Z=ke(Z),Ve<Ae?(M[se>>2>>>0]=J,M[se+4>>2>>>0]=Z):(M[se>>2>>>0]=Z,M[se+4>>2>>>0]=J)}(j,H,W))},d:function(){me("")},t:function(){return 4294901760},h:x?()=>{var L=process.hrtime();return 1e3*L[0]+L[1]/1e6}:()=>performance.now(),J:function(L,j,H){D.copyWithin(L>>>0,j>>>0,j+H>>>0)},f:function(L){var j=D.length;if(4294901760<(L>>>=0))return!1;for(var H=1;4>=H;H*=2){var W=j*(1+.2/H);W=Math.min(W,L+100663296);var J=Math;W=Math.max(L,W),J=J.min.call(J,4294901760,W+(65536-W%65536)%65536);e:{try{A.grow(J-P.byteLength+65535>>>16),ee();var Z=1;break e}catch{}Z=void 0}if(Z)return!0}return!1},D:function(L,j){var H=0;return Ne().forEach(function(W,J){var Z=j+H;for(J=M[L+4*J>>2>>>0]=Z,Z=0;Z<W.length;++Z)R[J++>>0>>>0]=W.charCodeAt(Z);R[J>>0>>>0]=0,H+=W.length+1}),0},E:function(L,j){var H=Ne();M[L>>2>>>0]=H.length;var W=0;return H.forEach(function(J){W+=J.length+1}),M[j>>2>>>0]=W,0},r:function(L){T||(s.onExit&&s.onExit(L),C=!0),f(L,new we(L))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(L,j,H,W){for(var J=0,Z=0;Z<H;Z++){var se=M[j>>2>>>0],Se=M[j+4>>2>>>0];j+=8;for(var Ae=0;Ae<Se;Ae++){var Oe=D[se+Ae>>>0],_e=Pe[L];Oe===0||Oe===10?((L===1?I:O)(z(_e,0)),_e.length=0):_e.push(Oe)}J+=Se}return M[W>>2>>>0]=J,0},s:function L(j,H){L.wa||(L.wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var J=new Uint8Array(1);return()=>(crypto.getRandomValues(J),J[0])}if(x)try{var Z=b(760);return()=>Z.randomBytes(1)[0]}catch{}return()=>me("randomDevice")}());for(var W=0;W<H;W++)R[j+W>>0>>>0]=L.wa();return 0},A:ze,c:function(L,j,H,W){return ze(L,j,H,W)}};(function(){function L(J){s.asm=J.exports,A=s.asm.P,ee(),Q.unshift(s.asm.Q),fe--,s.monitorRunDependencies&&s.monitorRunDependencies(fe),fe==0&&ie&&(J=ie,ie=null,J())}function j(J){L(J.instance)}function H(J){return function(){if(!S&&(y||w)){if(typeof fetch=="function"&&!ne.startsWith("file://"))return fetch(ne,{credentials:"same-origin"}).then(function(Z){if(!Z.ok)throw"failed to load wasm binary file at '"+ne+"'";return Z.arrayBuffer()}).catch(function(){return le()});if(o)return new Promise(function(Z,se){o(ne,function(Se){Z(new Uint8Array(Se))},se)})}return Promise.resolve().then(function(){return le()})}().then(function(Z){return WebAssembly.instantiate(Z,W)}).then(function(Z){return Z}).then(J,function(Z){O("failed to asynchronously prepare wasm: "+Z),me(Z)})}var W={a:Fe};if(fe++,s.monitorRunDependencies&&s.monitorRunDependencies(fe),s.instantiateWasm)try{return s.instantiateWasm(W,L)}catch(J){return O("Module.instantiateWasm callback failed with error: "+J),!1}(S||typeof WebAssembly.instantiateStreaming!="function"||de()||ne.startsWith("file://")||x||typeof fetch!="function"?H(j):fetch(ne,{credentials:"same-origin"}).then(function(J){return WebAssembly.instantiateStreaming(J,W).then(j,function(Z){return O("wasm streaming compile failed: "+Z),O("falling back to ArrayBuffer instantiation"),H(j)})})).catch(d)})(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.Q).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.R).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.S).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.T).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.U).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.V).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.W).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.X).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.Y).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.Z).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm._).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.$).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.aa).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.ba).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ca).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.da).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.ea).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.fa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.ga).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ha).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.ia).apply(null,arguments)};var Me=s._malloc=function(){return(Me=s._malloc=s.asm.ja).apply(null,arguments)};s._free=function(){return(s._free=s.asm.ka).apply(null,arguments)};var Ge,We=s.stackSave=function(){return(We=s.stackSave=s.asm.ma).apply(null,arguments)},qe=s.stackRestore=function(){return(qe=s.stackRestore=s.asm.na).apply(null,arguments)},Ke=s.stackAlloc=function(){return(Ke=s.stackAlloc=s.asm.oa).apply(null,arguments)};function te(){function L(){if(!Ge&&(Ge=!0,s.calledRun=!0,!C)){if(Ee(Q),l(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var j=s.postRun.shift();ae.unshift(j)}Ee(ae)}}if(!(0<fe)){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)re();Ee(oe),0<fe||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),L()},1)):L())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.pa).apply(null,arguments)},s.UTF8ToString=G,s.stringToUTF8=function(L,j,H){return Y(L,D,j,H)},s.lengthBytesUTF8=K,s.stackSave=We,s.stackRestore=qe,s.stackAlloc=Ke,ie=function L(){Ge||te(),Ge||(ie=L)},s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return te(),m.ready});v.exports=p},4537:v=>{v.exports=function(u,b){for(var g=new Array(arguments.length-1),p=0,m=2,s=!0;m<arguments.length;)g[p++]=arguments[m++];return new Promise(function(l,d){g[p]=function(a){if(s)if(s=!1,a)d(a);else{for(var o=new Array(arguments.length-1),t=0;t<o.length;)o[t++]=arguments[t];l.apply(null,o)}};try{u.apply(b||null,g)}catch(a){s&&(s=!1,d(a))}})}},7419:(v,u)=>{var b=u;b.length=function(l){var d=l.length;if(!d)return 0;for(var a=0;--d%4>1&&l.charAt(d)==="=";)++a;return Math.ceil(3*l.length)/4-a};for(var g=new Array(64),p=new Array(123),m=0;m<64;)p[g[m]=m<26?m+65:m<52?m+71:m<62?m-4:m-59|43]=m++;b.encode=function(l,d,a){for(var o,t=null,e=[],n=0,r=0;d<a;){var i=l[d++];switch(r){case 0:e[n++]=g[i>>2],o=(3&i)<<4,r=1;break;case 1:e[n++]=g[o|i>>4],o=(15&i)<<2,r=2;break;case 2:e[n++]=g[o|i>>6],e[n++]=g[63&i],r=0}n>8191&&((t||(t=[])).push(String.fromCharCode.apply(String,e)),n=0)}return r&&(e[n++]=g[o],e[n++]=61,r===1&&(e[n++]=61)),t?(n&&t.push(String.fromCharCode.apply(String,e.slice(0,n))),t.join("")):String.fromCharCode.apply(String,e.slice(0,n))};var s="invalid encoding";b.decode=function(l,d,a){for(var o,t=a,e=0,n=0;n<l.length;){var r=l.charCodeAt(n++);if(r===61&&e>1)break;if((r=p[r])===void 0)throw Error(s);switch(e){case 0:o=r,e=1;break;case 1:d[a++]=o<<2|(48&r)>>4,o=r,e=2;break;case 2:d[a++]=(15&o)<<4|(60&r)>>2,o=r,e=3;break;case 3:d[a++]=(3&o)<<6|r,e=0}}if(e===1)throw Error(s);return a-t},b.test=function(l){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(l)}},9211:v=>{function u(){this._listeners={}}v.exports=u,u.prototype.on=function(b,g,p){return(this._listeners[b]||(this._listeners[b]=[])).push({fn:g,ctx:p||this}),this},u.prototype.off=function(b,g){if(b===void 0)this._listeners={};else if(g===void 0)this._listeners[b]=[];else for(var p=this._listeners[b],m=0;m<p.length;)p[m].fn===g?p.splice(m,1):++m;return this},u.prototype.emit=function(b){var g=this._listeners[b];if(g){for(var p=[],m=1;m<arguments.length;)p.push(arguments[m++]);for(m=0;m<g.length;)g[m].fn.apply(g[m++].ctx,p)}return this}},945:v=>{function u(s){return typeof Float32Array<"u"?function(){var l=new Float32Array([-0]),d=new Uint8Array(l.buffer),a=d[3]===128;function o(r,i,c){l[0]=r,i[c]=d[0],i[c+1]=d[1],i[c+2]=d[2],i[c+3]=d[3]}function t(r,i,c){l[0]=r,i[c]=d[3],i[c+1]=d[2],i[c+2]=d[1],i[c+3]=d[0]}function e(r,i){return d[0]=r[i],d[1]=r[i+1],d[2]=r[i+2],d[3]=r[i+3],l[0]}function n(r,i){return d[3]=r[i],d[2]=r[i+1],d[1]=r[i+2],d[0]=r[i+3],l[0]}s.writeFloatLE=a?o:t,s.writeFloatBE=a?t:o,s.readFloatLE=a?e:n,s.readFloatBE=a?n:e}():function(){function l(a,o,t,e){var n=o<0?1:0;if(n&&(o=-o),o===0)a(1/o>0?0:2147483648,t,e);else if(isNaN(o))a(2143289344,t,e);else if(o>34028234663852886e22)a((n<<31|2139095040)>>>0,t,e);else if(o<11754943508222875e-54)a((n<<31|Math.round(o/1401298464324817e-60))>>>0,t,e);else{var r=Math.floor(Math.log(o)/Math.LN2);a((n<<31|r+127<<23|8388607&Math.round(o*Math.pow(2,-r)*8388608))>>>0,t,e)}}function d(a,o,t){var e=a(o,t),n=2*(e>>31)+1,r=e>>>23&255,i=8388607&e;return r===255?i?NaN:n*(1/0):r===0?1401298464324817e-60*n*i:n*Math.pow(2,r-150)*(i+8388608)}s.writeFloatLE=l.bind(null,b),s.writeFloatBE=l.bind(null,g),s.readFloatLE=d.bind(null,p),s.readFloatBE=d.bind(null,m)}(),typeof Float64Array<"u"?function(){var l=new Float64Array([-0]),d=new Uint8Array(l.buffer),a=d[7]===128;function o(r,i,c){l[0]=r,i[c]=d[0],i[c+1]=d[1],i[c+2]=d[2],i[c+3]=d[3],i[c+4]=d[4],i[c+5]=d[5],i[c+6]=d[6],i[c+7]=d[7]}function t(r,i,c){l[0]=r,i[c]=d[7],i[c+1]=d[6],i[c+2]=d[5],i[c+3]=d[4],i[c+4]=d[3],i[c+5]=d[2],i[c+6]=d[1],i[c+7]=d[0]}function e(r,i){return d[0]=r[i],d[1]=r[i+1],d[2]=r[i+2],d[3]=r[i+3],d[4]=r[i+4],d[5]=r[i+5],d[6]=r[i+6],d[7]=r[i+7],l[0]}function n(r,i){return d[7]=r[i],d[6]=r[i+1],d[5]=r[i+2],d[4]=r[i+3],d[3]=r[i+4],d[2]=r[i+5],d[1]=r[i+6],d[0]=r[i+7],l[0]}s.writeDoubleLE=a?o:t,s.writeDoubleBE=a?t:o,s.readDoubleLE=a?e:n,s.readDoubleBE=a?n:e}():function(){function l(a,o,t,e,n,r){var i=e<0?1:0;if(i&&(e=-e),e===0)a(0,n,r+o),a(1/e>0?0:2147483648,n,r+t);else if(isNaN(e))a(0,n,r+o),a(2146959360,n,r+t);else if(e>17976931348623157e292)a(0,n,r+o),a((i<<31|2146435072)>>>0,n,r+t);else{var c;if(e<22250738585072014e-324)a((c=e/5e-324)>>>0,n,r+o),a((i<<31|c/4294967296)>>>0,n,r+t);else{var f=Math.floor(Math.log(e)/Math.LN2);f===1024&&(f=1023),a(4503599627370496*(c=e*Math.pow(2,-f))>>>0,n,r+o),a((i<<31|f+1023<<20|1048576*c&1048575)>>>0,n,r+t)}}}function d(a,o,t,e,n){var r=a(e,n+o),i=a(e,n+t),c=2*(i>>31)+1,f=i>>>20&2047,y=4294967296*(1048575&i)+r;return f===2047?y?NaN:c*(1/0):f===0?5e-324*c*y:c*Math.pow(2,f-1075)*(y+4503599627370496)}s.writeDoubleLE=l.bind(null,b,0,4),s.writeDoubleBE=l.bind(null,g,4,0),s.readDoubleLE=d.bind(null,p,0,4),s.readDoubleBE=d.bind(null,m,4,0)}(),s}function b(s,l,d){l[d]=255&s,l[d+1]=s>>>8&255,l[d+2]=s>>>16&255,l[d+3]=s>>>24}function g(s,l,d){l[d]=s>>>24,l[d+1]=s>>>16&255,l[d+2]=s>>>8&255,l[d+3]=255&s}function p(s,l){return(s[l]|s[l+1]<<8|s[l+2]<<16|s[l+3]<<24)>>>0}function m(s,l){return(s[l]<<24|s[l+1]<<16|s[l+2]<<8|s[l+3])>>>0}v.exports=u(u)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(v){}return null}module.exports=inquire},6662:v=>{v.exports=function(u,b,g){var p=g||8192,m=p>>>1,s=null,l=p;return function(d){if(d<1||d>m)return u(d);l+d>p&&(s=u(p),l=0);var a=b.call(s,l,l+=d);return 7&l&&(l=1+(7|l)),a}}},4997:(v,u)=>{var b=u;b.length=function(g){for(var p=0,m=0,s=0;s<g.length;++s)(m=g.charCodeAt(s))<128?p+=1:m<2048?p+=2:(64512&m)==55296&&(64512&g.charCodeAt(s+1))==56320?(++s,p+=4):p+=3;return p},b.read=function(g,p,m){if(m-p<1)return"";for(var s,l=null,d=[],a=0;p<m;)(s=g[p++])<128?d[a++]=s:s>191&&s<224?d[a++]=(31&s)<<6|63&g[p++]:s>239&&s<365?(s=((7&s)<<18|(63&g[p++])<<12|(63&g[p++])<<6|63&g[p++])-65536,d[a++]=55296+(s>>10),d[a++]=56320+(1023&s)):d[a++]=(15&s)<<12|(63&g[p++])<<6|63&g[p++],a>8191&&((l||(l=[])).push(String.fromCharCode.apply(String,d)),a=0);return l?(a&&l.push(String.fromCharCode.apply(String,d.slice(0,a))),l.join("")):String.fromCharCode.apply(String,d.slice(0,a))},b.write=function(g,p,m){for(var s,l,d=m,a=0;a<g.length;++a)(s=g.charCodeAt(a))<128?p[m++]=s:s<2048?(p[m++]=s>>6|192,p[m++]=63&s|128):(64512&s)==55296&&(64512&(l=g.charCodeAt(a+1)))==56320?(s=65536+((1023&s)<<10)+(1023&l),++a,p[m++]=s>>18|240,p[m++]=s>>12&63|128,p[m++]=s>>6&63|128,p[m++]=63&s|128):(p[m++]=s>>12|224,p[m++]=s>>6&63|128,p[m++]=63&s|128);return m-d}},3442:(v,u)=>{u.__esModule=!0;var b=function(){function g(p){if(!p)throw new TypeError("Invalid argument; `value` has no value.");this.value=g.EMPTY,p&&g.isGuid(p)&&(this.value=p)}return g.isGuid=function(p){var m=p.toString();return p&&(p instanceof g||g.validator.test(m))},g.create=function(){return new g([g.gen(2),g.gen(1),g.gen(1),g.gen(1),g.gen(3)].join("-"))},g.createEmpty=function(){return new g("emptyguid")},g.parse=function(p){return new g(p)},g.raw=function(){return[g.gen(2),g.gen(1),g.gen(1),g.gen(1),g.gen(3)].join("-")},g.gen=function(p){for(var m="",s=0;s<p;s++)m+=(65536*(1+Math.random())|0).toString(16).substring(1);return m},g.prototype.equals=function(p){return g.isGuid(p)&&this.value===p.toString()},g.prototype.isEmpty=function(){return this.value===g.EMPTY},g.prototype.toString=function(){return this.value},g.prototype.toJSON=function(){return{value:this.value}},g.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),g.EMPTY="00000000-0000-0000-0000-000000000000",g}();u.Guid=b},3720:v=>{v.exports=b;var u=null;try{u=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function b(T,A,P){this.low=0|T,this.high=0|A,this.unsigned=!!P}function g(T){return(T&&T.__isLong__)===!0}b.prototype.__isLong__,Object.defineProperty(b.prototype,"__isLong__",{value:!0}),b.isLong=g;var p={},m={};function s(T,A){var P,R,D;return A?(D=0<=(T>>>=0)&&T<256)&&(R=m[T])?R:(P=d(T,(0|T)<0?-1:0,!0),D&&(m[T]=P),P):(D=-128<=(T|=0)&&T<128)&&(R=p[T])?R:(P=d(T,T<0?-1:0,!1),D&&(p[T]=P),P)}function l(T,A){if(isNaN(T))return A?f:c;if(A){if(T<0)return f;if(T>=n)return S}else{if(T<=-r)return I;if(T+1>=r)return _}return T<0?l(-T,A).neg():d(T%e|0,T/e|0,A)}function d(T,A,P){return new b(T,A,P)}b.fromInt=s,b.fromNumber=l,b.fromBits=d;var a=Math.pow;function o(T,A,P){if(T.length===0)throw Error("empty string");if(T==="NaN"||T==="Infinity"||T==="+Infinity"||T==="-Infinity")return c;if(typeof A=="number"?(P=A,A=!1):A=!!A,(P=P||10)<2||36<P)throw RangeError("radix");var R;if((R=T.indexOf("-"))>0)throw Error("interior hyphen");if(R===0)return o(T.substring(1),A,P).neg();for(var D=l(a(P,8)),$=c,M=0;M<T.length;M+=8){var C=Math.min(8,T.length-M),k=parseInt(T.substring(M,M+C),P);if(C<8){var z=l(a(P,C));$=$.mul(z).add(l(k))}else $=($=$.mul(D)).add(l(k))}return $.unsigned=A,$}function t(T,A){return typeof T=="number"?l(T,A):typeof T=="string"?o(T,A):d(T.low,T.high,typeof A=="boolean"?A:T.unsigned)}b.fromString=o,b.fromValue=t;var e=4294967296,n=e*e,r=n/2,i=s(1<<24),c=s(0);b.ZERO=c;var f=s(0,!0);b.UZERO=f;var y=s(1);b.ONE=y;var w=s(1,!0);b.UONE=w;var x=s(-1);b.NEG_ONE=x;var _=d(-1,2147483647,!1);b.MAX_VALUE=_;var S=d(-1,-1,!0);b.MAX_UNSIGNED_VALUE=S;var I=d(0,-2147483648,!1);b.MIN_VALUE=I;var O=b.prototype;O.toInt=function(){return this.unsigned?this.low>>>0:this.low},O.toNumber=function(){return this.unsigned?(this.high>>>0)*e+(this.low>>>0):this.high*e+(this.low>>>0)},O.toString=function(T){if((T=T||10)<2||36<T)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(I)){var A=l(T),P=this.div(A),R=P.mul(A).sub(this);return P.toString(T)+R.toInt().toString(T)}return"-"+this.neg().toString(T)}for(var D=l(a(T,6),this.unsigned),$=this,M="";;){var C=$.div(D),k=($.sub(C.mul(D)).toInt()>>>0).toString(T);if(($=C).isZero())return k+M;for(;k.length<6;)k="0"+k;M=""+k+M}},O.getHighBits=function(){return this.high},O.getHighBitsUnsigned=function(){return this.high>>>0},O.getLowBits=function(){return this.low},O.getLowBitsUnsigned=function(){return this.low>>>0},O.getNumBitsAbs=function(){if(this.isNegative())return this.eq(I)?64:this.neg().getNumBitsAbs();for(var T=this.high!=0?this.high:this.low,A=31;A>0&&!(T&1<<A);A--);return this.high!=0?A+33:A+1},O.isZero=function(){return this.high===0&&this.low===0},O.eqz=O.isZero,O.isNegative=function(){return!this.unsigned&&this.high<0},O.isPositive=function(){return this.unsigned||this.high>=0},O.isOdd=function(){return(1&this.low)==1},O.isEven=function(){return(1&this.low)==0},O.equals=function(T){return g(T)||(T=t(T)),(this.unsigned===T.unsigned||this.high>>>31!=1||T.high>>>31!=1)&&this.high===T.high&&this.low===T.low},O.eq=O.equals,O.notEquals=function(T){return!this.eq(T)},O.neq=O.notEquals,O.ne=O.notEquals,O.lessThan=function(T){return this.comp(T)<0},O.lt=O.lessThan,O.lessThanOrEqual=function(T){return this.comp(T)<=0},O.lte=O.lessThanOrEqual,O.le=O.lessThanOrEqual,O.greaterThan=function(T){return this.comp(T)>0},O.gt=O.greaterThan,O.greaterThanOrEqual=function(T){return this.comp(T)>=0},O.gte=O.greaterThanOrEqual,O.ge=O.greaterThanOrEqual,O.compare=function(T){if(g(T)||(T=t(T)),this.eq(T))return 0;var A=this.isNegative(),P=T.isNegative();return A&&!P?-1:!A&&P?1:this.unsigned?T.high>>>0>this.high>>>0||T.high===this.high&&T.low>>>0>this.low>>>0?-1:1:this.sub(T).isNegative()?-1:1},O.comp=O.compare,O.negate=function(){return!this.unsigned&&this.eq(I)?I:this.not().add(y)},O.neg=O.negate,O.add=function(T){g(T)||(T=t(T));var A=this.high>>>16,P=65535&this.high,R=this.low>>>16,D=65535&this.low,$=T.high>>>16,M=65535&T.high,C=T.low>>>16,k=0,z=0,G=0,Y=0;return G+=(Y+=D+(65535&T.low))>>>16,z+=(G+=R+C)>>>16,k+=(z+=P+M)>>>16,k+=A+$,d((G&=65535)<<16|(Y&=65535),(k&=65535)<<16|(z&=65535),this.unsigned)},O.subtract=function(T){return g(T)||(T=t(T)),this.add(T.neg())},O.sub=O.subtract,O.multiply=function(T){if(this.isZero())return c;if(g(T)||(T=t(T)),u)return d(u.mul(this.low,this.high,T.low,T.high),u.get_high(),this.unsigned);if(T.isZero())return c;if(this.eq(I))return T.isOdd()?I:c;if(T.eq(I))return this.isOdd()?I:c;if(this.isNegative())return T.isNegative()?this.neg().mul(T.neg()):this.neg().mul(T).neg();if(T.isNegative())return this.mul(T.neg()).neg();if(this.lt(i)&&T.lt(i))return l(this.toNumber()*T.toNumber(),this.unsigned);var A=this.high>>>16,P=65535&this.high,R=this.low>>>16,D=65535&this.low,$=T.high>>>16,M=65535&T.high,C=T.low>>>16,k=65535&T.low,z=0,G=0,Y=0,K=0;return Y+=(K+=D*k)>>>16,G+=(Y+=R*k)>>>16,Y&=65535,G+=(Y+=D*C)>>>16,z+=(G+=P*k)>>>16,G&=65535,z+=(G+=R*C)>>>16,G&=65535,z+=(G+=D*M)>>>16,z+=A*k+P*C+R*M+D*$,d((Y&=65535)<<16|(K&=65535),(z&=65535)<<16|(G&=65535),this.unsigned)},O.mul=O.multiply,O.divide=function(T){if(g(T)||(T=t(T)),T.isZero())throw Error("division by zero");var A,P,R;if(u)return this.unsigned||this.high!==-2147483648||T.low!==-1||T.high!==-1?d((this.unsigned?u.div_u:u.div_s)(this.low,this.high,T.low,T.high),u.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?f:c;if(this.unsigned){if(T.unsigned||(T=T.toUnsigned()),T.gt(this))return f;if(T.gt(this.shru(1)))return w;R=f}else{if(this.eq(I))return T.eq(y)||T.eq(x)?I:T.eq(I)?y:(A=this.shr(1).div(T).shl(1)).eq(c)?T.isNegative()?y:x:(P=this.sub(T.mul(A)),R=A.add(P.div(T)));if(T.eq(I))return this.unsigned?f:c;if(this.isNegative())return T.isNegative()?this.neg().div(T.neg()):this.neg().div(T).neg();if(T.isNegative())return this.div(T.neg()).neg();R=c}for(P=this;P.gte(T);){A=Math.max(1,Math.floor(P.toNumber()/T.toNumber()));for(var D=Math.ceil(Math.log(A)/Math.LN2),$=D<=48?1:a(2,D-48),M=l(A),C=M.mul(T);C.isNegative()||C.gt(P);)C=(M=l(A-=$,this.unsigned)).mul(T);M.isZero()&&(M=y),R=R.add(M),P=P.sub(C)}return R},O.div=O.divide,O.modulo=function(T){return g(T)||(T=t(T)),u?d((this.unsigned?u.rem_u:u.rem_s)(this.low,this.high,T.low,T.high),u.get_high(),this.unsigned):this.sub(this.div(T).mul(T))},O.mod=O.modulo,O.rem=O.modulo,O.not=function(){return d(~this.low,~this.high,this.unsigned)},O.and=function(T){return g(T)||(T=t(T)),d(this.low&T.low,this.high&T.high,this.unsigned)},O.or=function(T){return g(T)||(T=t(T)),d(this.low|T.low,this.high|T.high,this.unsigned)},O.xor=function(T){return g(T)||(T=t(T)),d(this.low^T.low,this.high^T.high,this.unsigned)},O.shiftLeft=function(T){return g(T)&&(T=T.toInt()),(T&=63)==0?this:T<32?d(this.low<<T,this.high<<T|this.low>>>32-T,this.unsigned):d(0,this.low<<T-32,this.unsigned)},O.shl=O.shiftLeft,O.shiftRight=function(T){return g(T)&&(T=T.toInt()),(T&=63)==0?this:T<32?d(this.low>>>T|this.high<<32-T,this.high>>T,this.unsigned):d(this.high>>T-32,this.high>=0?0:-1,this.unsigned)},O.shr=O.shiftRight,O.shiftRightUnsigned=function(T){if(g(T)&&(T=T.toInt()),(T&=63)==0)return this;var A=this.high;return T<32?d(this.low>>>T|A<<32-T,A>>>T,this.unsigned):d(T===32?A:A>>>T-32,0,this.unsigned)},O.shru=O.shiftRightUnsigned,O.shr_u=O.shiftRightUnsigned,O.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},O.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},O.toBytes=function(T){return T?this.toBytesLE():this.toBytesBE()},O.toBytesLE=function(){var T=this.high,A=this.low;return[255&A,A>>>8&255,A>>>16&255,A>>>24,255&T,T>>>8&255,T>>>16&255,T>>>24]},O.toBytesBE=function(){var T=this.high,A=this.low;return[T>>>24,T>>>16&255,T>>>8&255,255&T,A>>>24,A>>>16&255,A>>>8&255,255&A]},b.fromBytes=function(T,A,P){return P?b.fromBytesLE(T,A):b.fromBytesBE(T,A)},b.fromBytesLE=function(T,A){return new b(T[0]|T[1]<<8|T[2]<<16|T[3]<<24,T[4]|T[5]<<8|T[6]<<16|T[7]<<24,A)},b.fromBytesBE=function(T,A){return new b(T[4]<<24|T[5]<<16|T[6]<<8|T[7],T[0]<<24|T[1]<<16|T[2]<<8|T[3],A)}},1446:(v,u,b)=>{var g,p,m,s=b(2100),l=s.Reader,d=s.Writer,a=s.util,o=s.roots.default||(s.roots.default={});o.onnx=((m={}).Version=(g={},(p=Object.create(g))[g[0]="_START_VERSION"]=0,p[g[1]="IR_VERSION_2017_10_10"]=1,p[g[2]="IR_VERSION_2017_10_30"]=2,p[g[3]="IR_VERSION_2017_11_3"]=3,p[g[4]="IR_VERSION_2019_1_22"]=4,p[g[5]="IR_VERSION"]=5,p),m.AttributeProto=function(){function t(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.name="",t.prototype.refAttrName="",t.prototype.docString="",t.prototype.type=0,t.prototype.f=0,t.prototype.i=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.s=a.newBuffer([]),t.prototype.t=null,t.prototype.g=null,t.prototype.floats=a.emptyArray,t.prototype.ints=a.emptyArray,t.prototype.strings=a.emptyArray,t.prototype.tensors=a.emptyArray,t.prototype.graphs=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.name!=null&&e.hasOwnProperty("name")&&n.uint32(10).string(e.name),e.f!=null&&e.hasOwnProperty("f")&&n.uint32(21).float(e.f),e.i!=null&&e.hasOwnProperty("i")&&n.uint32(24).int64(e.i),e.s!=null&&e.hasOwnProperty("s")&&n.uint32(34).bytes(e.s),e.t!=null&&e.hasOwnProperty("t")&&o.onnx.TensorProto.encode(e.t,n.uint32(42).fork()).ldelim(),e.g!=null&&e.hasOwnProperty("g")&&o.onnx.GraphProto.encode(e.g,n.uint32(50).fork()).ldelim(),e.floats!=null&&e.floats.length){n.uint32(58).fork();for(var r=0;r<e.floats.length;++r)n.float(e.floats[r]);n.ldelim()}if(e.ints!=null&&e.ints.length){for(n.uint32(66).fork(),r=0;r<e.ints.length;++r)n.int64(e.ints[r]);n.ldelim()}if(e.strings!=null&&e.strings.length)for(r=0;r<e.strings.length;++r)n.uint32(74).bytes(e.strings[r]);if(e.tensors!=null&&e.tensors.length)for(r=0;r<e.tensors.length;++r)o.onnx.TensorProto.encode(e.tensors[r],n.uint32(82).fork()).ldelim();if(e.graphs!=null&&e.graphs.length)for(r=0;r<e.graphs.length;++r)o.onnx.GraphProto.encode(e.graphs[r],n.uint32(90).fork()).ldelim();return e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(106).string(e.docString),e.type!=null&&e.hasOwnProperty("type")&&n.uint32(160).int32(e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&n.uint32(170).string(e.refAttrName),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.AttributeProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.name=e.string();break;case 21:i.refAttrName=e.string();break;case 13:i.docString=e.string();break;case 20:i.type=e.int32();break;case 2:i.f=e.float();break;case 3:i.i=e.int64();break;case 4:i.s=e.bytes();break;case 5:i.t=o.onnx.TensorProto.decode(e,e.uint32());break;case 6:i.g=o.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(i.floats&&i.floats.length||(i.floats=[]),(7&c)==2)for(var f=e.uint32()+e.pos;e.pos<f;)i.floats.push(e.float());else i.floats.push(e.float());break;case 8:if(i.ints&&i.ints.length||(i.ints=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.ints.push(e.int64());else i.ints.push(e.int64());break;case 9:i.strings&&i.strings.length||(i.strings=[]),i.strings.push(e.bytes());break;case 10:i.tensors&&i.tensors.length||(i.tensors=[]),i.tensors.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 11:i.graphs&&i.graphs.length||(i.graphs=[]),i.graphs.push(o.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&!a.isString(e.refAttrName))return"refAttrName: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.type!=null&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(e.f!=null&&e.hasOwnProperty("f")&&typeof e.f!="number")return"f: number expected";if(e.i!=null&&e.hasOwnProperty("i")&&!(a.isInteger(e.i)||e.i&&a.isInteger(e.i.low)&&a.isInteger(e.i.high)))return"i: integer|Long expected";if(e.s!=null&&e.hasOwnProperty("s")&&!(e.s&&typeof e.s.length=="number"||a.isString(e.s)))return"s: buffer expected";if(e.t!=null&&e.hasOwnProperty("t")&&(r=o.onnx.TensorProto.verify(e.t)))return"t."+r;if(e.g!=null&&e.hasOwnProperty("g")&&(r=o.onnx.GraphProto.verify(e.g)))return"g."+r;if(e.floats!=null&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var n=0;n<e.floats.length;++n)if(typeof e.floats[n]!="number")return"floats: number[] expected"}if(e.ints!=null&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(n=0;n<e.ints.length;++n)if(!(a.isInteger(e.ints[n])||e.ints[n]&&a.isInteger(e.ints[n].low)&&a.isInteger(e.ints[n].high)))return"ints: integer|Long[] expected"}if(e.strings!=null&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(n=0;n<e.strings.length;++n)if(!(e.strings[n]&&typeof e.strings[n].length=="number"||a.isString(e.strings[n])))return"strings: buffer[] expected"}if(e.tensors!=null&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(n=0;n<e.tensors.length;++n)if(r=o.onnx.TensorProto.verify(e.tensors[n]))return"tensors."+r}if(e.graphs!=null&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(n=0;n<e.graphs.length;++n){var r;if(r=o.onnx.GraphProto.verify(e.graphs[n]))return"graphs."+r}}return null},t.fromObject=function(e){if(e instanceof o.onnx.AttributeProto)return e;var n=new o.onnx.AttributeProto;switch(e.name!=null&&(n.name=String(e.name)),e.refAttrName!=null&&(n.refAttrName=String(e.refAttrName)),e.docString!=null&&(n.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:n.type=0;break;case"FLOAT":case 1:n.type=1;break;case"INT":case 2:n.type=2;break;case"STRING":case 3:n.type=3;break;case"TENSOR":case 4:n.type=4;break;case"GRAPH":case 5:n.type=5;break;case"FLOATS":case 6:n.type=6;break;case"INTS":case 7:n.type=7;break;case"STRINGS":case 8:n.type=8;break;case"TENSORS":case 9:n.type=9;break;case"GRAPHS":case 10:n.type=10}if(e.f!=null&&(n.f=Number(e.f)),e.i!=null&&(a.Long?(n.i=a.Long.fromValue(e.i)).unsigned=!1:typeof e.i=="string"?n.i=parseInt(e.i,10):typeof e.i=="number"?n.i=e.i:typeof e.i=="object"&&(n.i=new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),e.s!=null&&(typeof e.s=="string"?a.base64.decode(e.s,n.s=a.newBuffer(a.base64.length(e.s)),0):e.s.length&&(n.s=e.s)),e.t!=null){if(typeof e.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");n.t=o.onnx.TensorProto.fromObject(e.t)}if(e.g!=null){if(typeof e.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");n.g=o.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");n.floats=[];for(var r=0;r<e.floats.length;++r)n.floats[r]=Number(e.floats[r])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(n.ints=[],r=0;r<e.ints.length;++r)a.Long?(n.ints[r]=a.Long.fromValue(e.ints[r])).unsigned=!1:typeof e.ints[r]=="string"?n.ints[r]=parseInt(e.ints[r],10):typeof e.ints[r]=="number"?n.ints[r]=e.ints[r]:typeof e.ints[r]=="object"&&(n.ints[r]=new a.LongBits(e.ints[r].low>>>0,e.ints[r].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(n.strings=[],r=0;r<e.strings.length;++r)typeof e.strings[r]=="string"?a.base64.decode(e.strings[r],n.strings[r]=a.newBuffer(a.base64.length(e.strings[r])),0):e.strings[r].length&&(n.strings[r]=e.strings[r])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(n.tensors=[],r=0;r<e.tensors.length;++r){if(typeof e.tensors[r]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");n.tensors[r]=o.onnx.TensorProto.fromObject(e.tensors[r])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(n.graphs=[],r=0;r<e.graphs.length;++r){if(typeof e.graphs[r]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");n.graphs[r]=o.onnx.GraphProto.fromObject(e.graphs[r])}}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[]),n.defaults){if(r.name="",r.f=0,a.Long){var i=new a.Long(0,0,!1);r.i=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else r.i=n.longs===String?"0":0;n.bytes===String?r.s="":(r.s=[],n.bytes!==Array&&(r.s=a.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.type=n.enums===String?"UNDEFINED":0,r.refAttrName=""}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.f!=null&&e.hasOwnProperty("f")&&(r.f=n.json&&!isFinite(e.f)?String(e.f):e.f),e.i!=null&&e.hasOwnProperty("i")&&(typeof e.i=="number"?r.i=n.longs===String?String(e.i):e.i:r.i=n.longs===String?a.Long.prototype.toString.call(e.i):n.longs===Number?new a.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),e.s!=null&&e.hasOwnProperty("s")&&(r.s=n.bytes===String?a.base64.encode(e.s,0,e.s.length):n.bytes===Array?Array.prototype.slice.call(e.s):e.s),e.t!=null&&e.hasOwnProperty("t")&&(r.t=o.onnx.TensorProto.toObject(e.t,n)),e.g!=null&&e.hasOwnProperty("g")&&(r.g=o.onnx.GraphProto.toObject(e.g,n)),e.floats&&e.floats.length){r.floats=[];for(var c=0;c<e.floats.length;++c)r.floats[c]=n.json&&!isFinite(e.floats[c])?String(e.floats[c]):e.floats[c]}if(e.ints&&e.ints.length)for(r.ints=[],c=0;c<e.ints.length;++c)typeof e.ints[c]=="number"?r.ints[c]=n.longs===String?String(e.ints[c]):e.ints[c]:r.ints[c]=n.longs===String?a.Long.prototype.toString.call(e.ints[c]):n.longs===Number?new a.LongBits(e.ints[c].low>>>0,e.ints[c].high>>>0).toNumber():e.ints[c];if(e.strings&&e.strings.length)for(r.strings=[],c=0;c<e.strings.length;++c)r.strings[c]=n.bytes===String?a.base64.encode(e.strings[c],0,e.strings[c].length):n.bytes===Array?Array.prototype.slice.call(e.strings[c]):e.strings[c];if(e.tensors&&e.tensors.length)for(r.tensors=[],c=0;c<e.tensors.length;++c)r.tensors[c]=o.onnx.TensorProto.toObject(e.tensors[c],n);if(e.graphs&&e.graphs.length)for(r.graphs=[],c=0;c<e.graphs.length;++c)r.graphs[c]=o.onnx.GraphProto.toObject(e.graphs[c],n);return e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.type!=null&&e.hasOwnProperty("type")&&(r.type=n.enums===String?o.onnx.AttributeProto.AttributeType[e.type]:e.type),e.refAttrName!=null&&e.hasOwnProperty("refAttrName")&&(r.refAttrName=e.refAttrName),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t.AttributeType=function(){var e={},n=Object.create(e);return n[e[0]="UNDEFINED"]=0,n[e[1]="FLOAT"]=1,n[e[2]="INT"]=2,n[e[3]="STRING"]=3,n[e[4]="TENSOR"]=4,n[e[5]="GRAPH"]=5,n[e[6]="FLOATS"]=6,n[e[7]="INTS"]=7,n[e[8]="STRINGS"]=8,n[e[9]="TENSORS"]=9,n[e[10]="GRAPHS"]=10,n}(),t}(),m.ValueInfoProto=function(){function t(e){if(e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.name="",t.prototype.type=null,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(e,n){return n||(n=d.create()),e.name!=null&&e.hasOwnProperty("name")&&n.uint32(10).string(e.name),e.type!=null&&e.hasOwnProperty("type")&&o.onnx.TypeProto.encode(e.type,n.uint32(18).fork()).ldelim(),e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(26).string(e.docString),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.ValueInfoProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.name=e.string();break;case 2:i.type=o.onnx.TypeProto.decode(e,e.uint32());break;case 3:i.docString=e.string();break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.type!=null&&e.hasOwnProperty("type")){var n=o.onnx.TypeProto.verify(e.type);if(n)return"type."+n}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},t.fromObject=function(e){if(e instanceof o.onnx.ValueInfoProto)return e;var n=new o.onnx.ValueInfoProto;if(e.name!=null&&(n.name=String(e.name)),e.type!=null){if(typeof e.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");n.type=o.onnx.TypeProto.fromObject(e.type)}return e.docString!=null&&(n.docString=String(e.docString)),n},t.toObject=function(e,n){n||(n={});var r={};return n.defaults&&(r.name="",r.type=null,r.docString=""),e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.type!=null&&e.hasOwnProperty("type")&&(r.type=o.onnx.TypeProto.toObject(e.type,n)),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.NodeProto=function(){function t(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.input=a.emptyArray,t.prototype.output=a.emptyArray,t.prototype.name="",t.prototype.opType="",t.prototype.domain="",t.prototype.attribute=a.emptyArray,t.prototype.docString="",t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.input!=null&&e.input.length)for(var r=0;r<e.input.length;++r)n.uint32(10).string(e.input[r]);if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)n.uint32(18).string(e.output[r]);if(e.name!=null&&e.hasOwnProperty("name")&&n.uint32(26).string(e.name),e.opType!=null&&e.hasOwnProperty("opType")&&n.uint32(34).string(e.opType),e.attribute!=null&&e.attribute.length)for(r=0;r<e.attribute.length;++r)o.onnx.AttributeProto.encode(e.attribute[r],n.uint32(42).fork()).ldelim();return e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(50).string(e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&n.uint32(58).string(e.domain),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.NodeProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.input&&i.input.length||(i.input=[]),i.input.push(e.string());break;case 2:i.output&&i.output.length||(i.output=[]),i.output.push(e.string());break;case 3:i.name=e.string();break;case 4:i.opType=e.string();break;case 7:i.domain=e.string();break;case 5:i.attribute&&i.attribute.length||(i.attribute=[]),i.attribute.push(o.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:i.docString=e.string();break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var n=0;n<e.input.length;++n)if(!a.isString(e.input[n]))return"input: string[] expected"}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(n=0;n<e.output.length;++n)if(!a.isString(e.output[n]))return"output: string[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.opType!=null&&e.hasOwnProperty("opType")&&!a.isString(e.opType))return"opType: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.attribute!=null&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(n=0;n<e.attribute.length;++n){var r=o.onnx.AttributeProto.verify(e.attribute[n]);if(r)return"attribute."+r}}return e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString)?"docString: string expected":null},t.fromObject=function(e){if(e instanceof o.onnx.NodeProto)return e;var n=new o.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");n.input=[];for(var r=0;r<e.input.length;++r)n.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(n.output=[],r=0;r<e.output.length;++r)n.output[r]=String(e.output[r])}if(e.name!=null&&(n.name=String(e.name)),e.opType!=null&&(n.opType=String(e.opType)),e.domain!=null&&(n.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(n.attribute=[],r=0;r<e.attribute.length;++r){if(typeof e.attribute[r]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");n.attribute[r]=o.onnx.AttributeProto.fromObject(e.attribute[r])}}return e.docString!=null&&(n.docString=String(e.docString)),n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.input=[],r.output=[],r.attribute=[]),n.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),e.input&&e.input.length){r.input=[];for(var i=0;i<e.input.length;++i)r.input[i]=e.input[i]}if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=e.output[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.opType!=null&&e.hasOwnProperty("opType")&&(r.opType=e.opType),e.attribute&&e.attribute.length)for(r.attribute=[],i=0;i<e.attribute.length;++i)r.attribute[i]=o.onnx.AttributeProto.toObject(e.attribute[i],n);return e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.ModelProto=function(){function t(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.irVersion=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.opsetImport=a.emptyArray,t.prototype.producerName="",t.prototype.producerVersion="",t.prototype.domain="",t.prototype.modelVersion=a.Long?a.Long.fromBits(0,0,!1):0,t.prototype.docString="",t.prototype.graph=null,t.prototype.metadataProps=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.irVersion!=null&&e.hasOwnProperty("irVersion")&&n.uint32(8).int64(e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&n.uint32(18).string(e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&n.uint32(26).string(e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&n.uint32(34).string(e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&n.uint32(40).int64(e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(50).string(e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&o.onnx.GraphProto.encode(e.graph,n.uint32(58).fork()).ldelim(),e.opsetImport!=null&&e.opsetImport.length)for(var r=0;r<e.opsetImport.length;++r)o.onnx.OperatorSetIdProto.encode(e.opsetImport[r],n.uint32(66).fork()).ldelim();if(e.metadataProps!=null&&e.metadataProps.length)for(r=0;r<e.metadataProps.length;++r)o.onnx.StringStringEntryProto.encode(e.metadataProps[r],n.uint32(114).fork()).ldelim();return n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.ModelProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.irVersion=e.int64();break;case 8:i.opsetImport&&i.opsetImport.length||(i.opsetImport=[]),i.opsetImport.push(o.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:i.producerName=e.string();break;case 3:i.producerVersion=e.string();break;case 4:i.domain=e.string();break;case 5:i.modelVersion=e.int64();break;case 6:i.docString=e.string();break;case 7:i.graph=o.onnx.GraphProto.decode(e,e.uint32());break;case 14:i.metadataProps&&i.metadataProps.length||(i.metadataProps=[]),i.metadataProps.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&!(a.isInteger(e.irVersion)||e.irVersion&&a.isInteger(e.irVersion.low)&&a.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(e.opsetImport!=null&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var n=0;n<e.opsetImport.length;++n)if(r=o.onnx.OperatorSetIdProto.verify(e.opsetImport[n]))return"opsetImport."+r}if(e.producerName!=null&&e.hasOwnProperty("producerName")&&!a.isString(e.producerName))return"producerName: string expected";if(e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&!a.isString(e.producerVersion))return"producerVersion: string expected";if(e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain))return"domain: string expected";if(e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&!(a.isInteger(e.modelVersion)||e.modelVersion&&a.isInteger(e.modelVersion.low)&&a.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.graph!=null&&e.hasOwnProperty("graph")&&(r=o.onnx.GraphProto.verify(e.graph)))return"graph."+r;if(e.metadataProps!=null&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(n=0;n<e.metadataProps.length;++n){var r;if(r=o.onnx.StringStringEntryProto.verify(e.metadataProps[n]))return"metadataProps."+r}}return null},t.fromObject=function(e){if(e instanceof o.onnx.ModelProto)return e;var n=new o.onnx.ModelProto;if(e.irVersion!=null&&(a.Long?(n.irVersion=a.Long.fromValue(e.irVersion)).unsigned=!1:typeof e.irVersion=="string"?n.irVersion=parseInt(e.irVersion,10):typeof e.irVersion=="number"?n.irVersion=e.irVersion:typeof e.irVersion=="object"&&(n.irVersion=new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");n.opsetImport=[];for(var r=0;r<e.opsetImport.length;++r){if(typeof e.opsetImport[r]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");n.opsetImport[r]=o.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}if(e.producerName!=null&&(n.producerName=String(e.producerName)),e.producerVersion!=null&&(n.producerVersion=String(e.producerVersion)),e.domain!=null&&(n.domain=String(e.domain)),e.modelVersion!=null&&(a.Long?(n.modelVersion=a.Long.fromValue(e.modelVersion)).unsigned=!1:typeof e.modelVersion=="string"?n.modelVersion=parseInt(e.modelVersion,10):typeof e.modelVersion=="number"?n.modelVersion=e.modelVersion:typeof e.modelVersion=="object"&&(n.modelVersion=new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),e.docString!=null&&(n.docString=String(e.docString)),e.graph!=null){if(typeof e.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");n.graph=o.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(n.metadataProps=[],r=0;r<e.metadataProps.length;++r){if(typeof e.metadataProps[r]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");n.metadataProps[r]=o.onnx.StringStringEntryProto.fromObject(e.metadataProps[r])}}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.opsetImport=[],r.metadataProps=[]),n.defaults){if(a.Long){var i=new a.Long(0,0,!1);r.irVersion=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else r.irVersion=n.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",a.Long?(i=new a.Long(0,0,!1),r.modelVersion=n.longs===String?i.toString():n.longs===Number?i.toNumber():i):r.modelVersion=n.longs===String?"0":0,r.docString="",r.graph=null}if(e.irVersion!=null&&e.hasOwnProperty("irVersion")&&(typeof e.irVersion=="number"?r.irVersion=n.longs===String?String(e.irVersion):e.irVersion:r.irVersion=n.longs===String?a.Long.prototype.toString.call(e.irVersion):n.longs===Number?new a.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),e.producerName!=null&&e.hasOwnProperty("producerName")&&(r.producerName=e.producerName),e.producerVersion!=null&&e.hasOwnProperty("producerVersion")&&(r.producerVersion=e.producerVersion),e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.modelVersion!=null&&e.hasOwnProperty("modelVersion")&&(typeof e.modelVersion=="number"?r.modelVersion=n.longs===String?String(e.modelVersion):e.modelVersion:r.modelVersion=n.longs===String?a.Long.prototype.toString.call(e.modelVersion):n.longs===Number?new a.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.graph!=null&&e.hasOwnProperty("graph")&&(r.graph=o.onnx.GraphProto.toObject(e.graph,n)),e.opsetImport&&e.opsetImport.length){r.opsetImport=[];for(var c=0;c<e.opsetImport.length;++c)r.opsetImport[c]=o.onnx.OperatorSetIdProto.toObject(e.opsetImport[c],n)}if(e.metadataProps&&e.metadataProps.length)for(r.metadataProps=[],c=0;c<e.metadataProps.length;++c)r.metadataProps[c]=o.onnx.StringStringEntryProto.toObject(e.metadataProps[c],n);return r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.StringStringEntryProto=function(){function t(e){if(e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.key="",t.prototype.value="",t.create=function(e){return new t(e)},t.encode=function(e,n){return n||(n=d.create()),e.key!=null&&e.hasOwnProperty("key")&&n.uint32(10).string(e.key),e.value!=null&&e.hasOwnProperty("value")&&n.uint32(18).string(e.value),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.StringStringEntryProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.key=e.string();break;case 2:i.value=e.string();break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){return typeof e!="object"||e===null?"object expected":e.key!=null&&e.hasOwnProperty("key")&&!a.isString(e.key)?"key: string expected":e.value!=null&&e.hasOwnProperty("value")&&!a.isString(e.value)?"value: string expected":null},t.fromObject=function(e){if(e instanceof o.onnx.StringStringEntryProto)return e;var n=new o.onnx.StringStringEntryProto;return e.key!=null&&(n.key=String(e.key)),e.value!=null&&(n.value=String(e.value)),n},t.toObject=function(e,n){n||(n={});var r={};return n.defaults&&(r.key="",r.value=""),e.key!=null&&e.hasOwnProperty("key")&&(r.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(r.value=e.value),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.TensorAnnotation=function(){function t(e){if(this.quantParameterTensorNames=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.tensorName="",t.prototype.quantParameterTensorNames=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&n.uint32(10).string(e.tensorName),e.quantParameterTensorNames!=null&&e.quantParameterTensorNames.length)for(var r=0;r<e.quantParameterTensorNames.length;++r)o.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[r],n.uint32(18).fork()).ldelim();return n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.TensorAnnotation;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.tensorName=e.string();break;case 2:i.quantParameterTensorNames&&i.quantParameterTensorNames.length||(i.quantParameterTensorNames=[]),i.quantParameterTensorNames.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.tensorName!=null&&e.hasOwnProperty("tensorName")&&!a.isString(e.tensorName))return"tensorName: string expected";if(e.quantParameterTensorNames!=null&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var n=0;n<e.quantParameterTensorNames.length;++n){var r=o.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[n]);if(r)return"quantParameterTensorNames."+r}}return null},t.fromObject=function(e){if(e instanceof o.onnx.TensorAnnotation)return e;var n=new o.onnx.TensorAnnotation;if(e.tensorName!=null&&(n.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");n.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r){if(typeof e.quantParameterTensorNames[r]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");n.quantParameterTensorNames[r]=o.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[r])}}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.quantParameterTensorNames=[]),n.defaults&&(r.tensorName=""),e.tensorName!=null&&e.hasOwnProperty("tensorName")&&(r.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var i=0;i<e.quantParameterTensorNames.length;++i)r.quantParameterTensorNames[i]=o.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[i],n)}return r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.GraphProto=function(){function t(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.node=a.emptyArray,t.prototype.name="",t.prototype.initializer=a.emptyArray,t.prototype.docString="",t.prototype.input=a.emptyArray,t.prototype.output=a.emptyArray,t.prototype.valueInfo=a.emptyArray,t.prototype.quantizationAnnotation=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.node!=null&&e.node.length)for(var r=0;r<e.node.length;++r)o.onnx.NodeProto.encode(e.node[r],n.uint32(10).fork()).ldelim();if(e.name!=null&&e.hasOwnProperty("name")&&n.uint32(18).string(e.name),e.initializer!=null&&e.initializer.length)for(r=0;r<e.initializer.length;++r)o.onnx.TensorProto.encode(e.initializer[r],n.uint32(42).fork()).ldelim();if(e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(82).string(e.docString),e.input!=null&&e.input.length)for(r=0;r<e.input.length;++r)o.onnx.ValueInfoProto.encode(e.input[r],n.uint32(90).fork()).ldelim();if(e.output!=null&&e.output.length)for(r=0;r<e.output.length;++r)o.onnx.ValueInfoProto.encode(e.output[r],n.uint32(98).fork()).ldelim();if(e.valueInfo!=null&&e.valueInfo.length)for(r=0;r<e.valueInfo.length;++r)o.onnx.ValueInfoProto.encode(e.valueInfo[r],n.uint32(106).fork()).ldelim();if(e.quantizationAnnotation!=null&&e.quantizationAnnotation.length)for(r=0;r<e.quantizationAnnotation.length;++r)o.onnx.TensorAnnotation.encode(e.quantizationAnnotation[r],n.uint32(114).fork()).ldelim();return n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.GraphProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.node&&i.node.length||(i.node=[]),i.node.push(o.onnx.NodeProto.decode(e,e.uint32()));break;case 2:i.name=e.string();break;case 5:i.initializer&&i.initializer.length||(i.initializer=[]),i.initializer.push(o.onnx.TensorProto.decode(e,e.uint32()));break;case 10:i.docString=e.string();break;case 11:i.input&&i.input.length||(i.input=[]),i.input.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:i.output&&i.output.length||(i.output=[]),i.output.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:i.valueInfo&&i.valueInfo.length||(i.valueInfo=[]),i.valueInfo.push(o.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:i.quantizationAnnotation&&i.quantizationAnnotation.length||(i.quantizationAnnotation=[]),i.quantizationAnnotation.push(o.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.node!=null&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var n=0;n<e.node.length;++n)if(r=o.onnx.NodeProto.verify(e.node[n]))return"node."+r}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.initializer!=null&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(n=0;n<e.initializer.length;++n)if(r=o.onnx.TensorProto.verify(e.initializer[n]))return"initializer."+r}if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.input!=null&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(n=0;n<e.input.length;++n)if(r=o.onnx.ValueInfoProto.verify(e.input[n]))return"input."+r}if(e.output!=null&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(n=0;n<e.output.length;++n)if(r=o.onnx.ValueInfoProto.verify(e.output[n]))return"output."+r}if(e.valueInfo!=null&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(n=0;n<e.valueInfo.length;++n)if(r=o.onnx.ValueInfoProto.verify(e.valueInfo[n]))return"valueInfo."+r}if(e.quantizationAnnotation!=null&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(n=0;n<e.quantizationAnnotation.length;++n){var r;if(r=o.onnx.TensorAnnotation.verify(e.quantizationAnnotation[n]))return"quantizationAnnotation."+r}}return null},t.fromObject=function(e){if(e instanceof o.onnx.GraphProto)return e;var n=new o.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");n.node=[];for(var r=0;r<e.node.length;++r){if(typeof e.node[r]!="object")throw TypeError(".onnx.GraphProto.node: object expected");n.node[r]=o.onnx.NodeProto.fromObject(e.node[r])}}if(e.name!=null&&(n.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(n.initializer=[],r=0;r<e.initializer.length;++r){if(typeof e.initializer[r]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");n.initializer[r]=o.onnx.TensorProto.fromObject(e.initializer[r])}}if(e.docString!=null&&(n.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(n.input=[],r=0;r<e.input.length;++r){if(typeof e.input[r]!="object")throw TypeError(".onnx.GraphProto.input: object expected");n.input[r]=o.onnx.ValueInfoProto.fromObject(e.input[r])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(n.output=[],r=0;r<e.output.length;++r){if(typeof e.output[r]!="object")throw TypeError(".onnx.GraphProto.output: object expected");n.output[r]=o.onnx.ValueInfoProto.fromObject(e.output[r])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(n.valueInfo=[],r=0;r<e.valueInfo.length;++r){if(typeof e.valueInfo[r]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");n.valueInfo[r]=o.onnx.ValueInfoProto.fromObject(e.valueInfo[r])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(n.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r){if(typeof e.quantizationAnnotation[r]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");n.quantizationAnnotation[r]=o.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[r])}}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[]),n.defaults&&(r.name="",r.docString=""),e.node&&e.node.length){r.node=[];for(var i=0;i<e.node.length;++i)r.node[i]=o.onnx.NodeProto.toObject(e.node[i],n)}if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.initializer&&e.initializer.length)for(r.initializer=[],i=0;i<e.initializer.length;++i)r.initializer[i]=o.onnx.TensorProto.toObject(e.initializer[i],n);if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.input&&e.input.length)for(r.input=[],i=0;i<e.input.length;++i)r.input[i]=o.onnx.ValueInfoProto.toObject(e.input[i],n);if(e.output&&e.output.length)for(r.output=[],i=0;i<e.output.length;++i)r.output[i]=o.onnx.ValueInfoProto.toObject(e.output[i],n);if(e.valueInfo&&e.valueInfo.length)for(r.valueInfo=[],i=0;i<e.valueInfo.length;++i)r.valueInfo[i]=o.onnx.ValueInfoProto.toObject(e.valueInfo[i],n);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(r.quantizationAnnotation=[],i=0;i<e.quantizationAnnotation.length;++i)r.quantizationAnnotation[i]=o.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[i],n);return r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m.TensorProto=function(){function t(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.dims=a.emptyArray,t.prototype.dataType=0,t.prototype.segment=null,t.prototype.floatData=a.emptyArray,t.prototype.int32Data=a.emptyArray,t.prototype.stringData=a.emptyArray,t.prototype.int64Data=a.emptyArray,t.prototype.name="",t.prototype.docString="",t.prototype.rawData=a.newBuffer([]),t.prototype.externalData=a.emptyArray,t.prototype.dataLocation=0,t.prototype.doubleData=a.emptyArray,t.prototype.uint64Data=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.dims!=null&&e.dims.length){n.uint32(10).fork();for(var r=0;r<e.dims.length;++r)n.int64(e.dims[r]);n.ldelim()}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&n.uint32(16).int32(e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&o.onnx.TensorProto.Segment.encode(e.segment,n.uint32(26).fork()).ldelim(),e.floatData!=null&&e.floatData.length){for(n.uint32(34).fork(),r=0;r<e.floatData.length;++r)n.float(e.floatData[r]);n.ldelim()}if(e.int32Data!=null&&e.int32Data.length){for(n.uint32(42).fork(),r=0;r<e.int32Data.length;++r)n.int32(e.int32Data[r]);n.ldelim()}if(e.stringData!=null&&e.stringData.length)for(r=0;r<e.stringData.length;++r)n.uint32(50).bytes(e.stringData[r]);if(e.int64Data!=null&&e.int64Data.length){for(n.uint32(58).fork(),r=0;r<e.int64Data.length;++r)n.int64(e.int64Data[r]);n.ldelim()}if(e.name!=null&&e.hasOwnProperty("name")&&n.uint32(66).string(e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&n.uint32(74).bytes(e.rawData),e.doubleData!=null&&e.doubleData.length){for(n.uint32(82).fork(),r=0;r<e.doubleData.length;++r)n.double(e.doubleData[r]);n.ldelim()}if(e.uint64Data!=null&&e.uint64Data.length){for(n.uint32(90).fork(),r=0;r<e.uint64Data.length;++r)n.uint64(e.uint64Data[r]);n.ldelim()}if(e.docString!=null&&e.hasOwnProperty("docString")&&n.uint32(98).string(e.docString),e.externalData!=null&&e.externalData.length)for(r=0;r<e.externalData.length;++r)o.onnx.StringStringEntryProto.encode(e.externalData[r],n.uint32(106).fork()).ldelim();return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&n.uint32(112).int32(e.dataLocation),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.TensorProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:if(i.dims&&i.dims.length||(i.dims=[]),(7&c)==2)for(var f=e.uint32()+e.pos;e.pos<f;)i.dims.push(e.int64());else i.dims.push(e.int64());break;case 2:i.dataType=e.int32();break;case 3:i.segment=o.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(i.floatData&&i.floatData.length||(i.floatData=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.floatData.push(e.float());else i.floatData.push(e.float());break;case 5:if(i.int32Data&&i.int32Data.length||(i.int32Data=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.int32Data.push(e.int32());else i.int32Data.push(e.int32());break;case 6:i.stringData&&i.stringData.length||(i.stringData=[]),i.stringData.push(e.bytes());break;case 7:if(i.int64Data&&i.int64Data.length||(i.int64Data=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.int64Data.push(e.int64());else i.int64Data.push(e.int64());break;case 8:i.name=e.string();break;case 12:i.docString=e.string();break;case 9:i.rawData=e.bytes();break;case 13:i.externalData&&i.externalData.length||(i.externalData=[]),i.externalData.push(o.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:i.dataLocation=e.int32();break;case 10:if(i.doubleData&&i.doubleData.length||(i.doubleData=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.doubleData.push(e.double());else i.doubleData.push(e.double());break;case 11:if(i.uint64Data&&i.uint64Data.length||(i.uint64Data=[]),(7&c)==2)for(f=e.uint32()+e.pos;e.pos<f;)i.uint64Data.push(e.uint64());else i.uint64Data.push(e.uint64());break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dims!=null&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var n=0;n<e.dims.length;++n)if(!(a.isInteger(e.dims[n])||e.dims[n]&&a.isInteger(e.dims[n].low)&&a.isInteger(e.dims[n].high)))return"dims: integer|Long[] expected"}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&!a.isInteger(e.dataType))return"dataType: integer expected";if(e.segment!=null&&e.hasOwnProperty("segment")&&(r=o.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+r;if(e.floatData!=null&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(n=0;n<e.floatData.length;++n)if(typeof e.floatData[n]!="number")return"floatData: number[] expected"}if(e.int32Data!=null&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(n=0;n<e.int32Data.length;++n)if(!a.isInteger(e.int32Data[n]))return"int32Data: integer[] expected"}if(e.stringData!=null&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(n=0;n<e.stringData.length;++n)if(!(e.stringData[n]&&typeof e.stringData[n].length=="number"||a.isString(e.stringData[n])))return"stringData: buffer[] expected"}if(e.int64Data!=null&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(n=0;n<e.int64Data.length;++n)if(!(a.isInteger(e.int64Data[n])||e.int64Data[n]&&a.isInteger(e.int64Data[n].low)&&a.isInteger(e.int64Data[n].high)))return"int64Data: integer|Long[] expected"}if(e.name!=null&&e.hasOwnProperty("name")&&!a.isString(e.name))return"name: string expected";if(e.docString!=null&&e.hasOwnProperty("docString")&&!a.isString(e.docString))return"docString: string expected";if(e.rawData!=null&&e.hasOwnProperty("rawData")&&!(e.rawData&&typeof e.rawData.length=="number"||a.isString(e.rawData)))return"rawData: buffer expected";if(e.externalData!=null&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(n=0;n<e.externalData.length;++n){var r;if(r=o.onnx.StringStringEntryProto.verify(e.externalData[n]))return"externalData."+r}}if(e.dataLocation!=null&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(e.doubleData!=null&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(n=0;n<e.doubleData.length;++n)if(typeof e.doubleData[n]!="number")return"doubleData: number[] expected"}if(e.uint64Data!=null&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(n=0;n<e.uint64Data.length;++n)if(!(a.isInteger(e.uint64Data[n])||e.uint64Data[n]&&a.isInteger(e.uint64Data[n].low)&&a.isInteger(e.uint64Data[n].high)))return"uint64Data: integer|Long[] expected"}return null},t.fromObject=function(e){if(e instanceof o.onnx.TensorProto)return e;var n=new o.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");n.dims=[];for(var r=0;r<e.dims.length;++r)a.Long?(n.dims[r]=a.Long.fromValue(e.dims[r])).unsigned=!1:typeof e.dims[r]=="string"?n.dims[r]=parseInt(e.dims[r],10):typeof e.dims[r]=="number"?n.dims[r]=e.dims[r]:typeof e.dims[r]=="object"&&(n.dims[r]=new a.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}if(e.dataType!=null&&(n.dataType=0|e.dataType),e.segment!=null){if(typeof e.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");n.segment=o.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(n.floatData=[],r=0;r<e.floatData.length;++r)n.floatData[r]=Number(e.floatData[r])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(n.int32Data=[],r=0;r<e.int32Data.length;++r)n.int32Data[r]=0|e.int32Data[r]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(n.stringData=[],r=0;r<e.stringData.length;++r)typeof e.stringData[r]=="string"?a.base64.decode(e.stringData[r],n.stringData[r]=a.newBuffer(a.base64.length(e.stringData[r])),0):e.stringData[r].length&&(n.stringData[r]=e.stringData[r])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(n.int64Data=[],r=0;r<e.int64Data.length;++r)a.Long?(n.int64Data[r]=a.Long.fromValue(e.int64Data[r])).unsigned=!1:typeof e.int64Data[r]=="string"?n.int64Data[r]=parseInt(e.int64Data[r],10):typeof e.int64Data[r]=="number"?n.int64Data[r]=e.int64Data[r]:typeof e.int64Data[r]=="object"&&(n.int64Data[r]=new a.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber())}if(e.name!=null&&(n.name=String(e.name)),e.docString!=null&&(n.docString=String(e.docString)),e.rawData!=null&&(typeof e.rawData=="string"?a.base64.decode(e.rawData,n.rawData=a.newBuffer(a.base64.length(e.rawData)),0):e.rawData.length&&(n.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(n.externalData=[],r=0;r<e.externalData.length;++r){if(typeof e.externalData[r]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");n.externalData[r]=o.onnx.StringStringEntryProto.fromObject(e.externalData[r])}}switch(e.dataLocation){case"DEFAULT":case 0:n.dataLocation=0;break;case"EXTERNAL":case 1:n.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(n.doubleData=[],r=0;r<e.doubleData.length;++r)n.doubleData[r]=Number(e.doubleData[r])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(n.uint64Data=[],r=0;r<e.uint64Data.length;++r)a.Long?(n.uint64Data[r]=a.Long.fromValue(e.uint64Data[r])).unsigned=!0:typeof e.uint64Data[r]=="string"?n.uint64Data[r]=parseInt(e.uint64Data[r],10):typeof e.uint64Data[r]=="number"?n.uint64Data[r]=e.uint64Data[r]:typeof e.uint64Data[r]=="object"&&(n.uint64Data[r]=new a.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0))}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),n.defaults&&(r.dataType=0,r.segment=null,r.name="",n.bytes===String?r.rawData="":(r.rawData=[],n.bytes!==Array&&(r.rawData=a.newBuffer(r.rawData))),r.docString="",r.dataLocation=n.enums===String?"DEFAULT":0),e.dims&&e.dims.length){r.dims=[];for(var i=0;i<e.dims.length;++i)typeof e.dims[i]=="number"?r.dims[i]=n.longs===String?String(e.dims[i]):e.dims[i]:r.dims[i]=n.longs===String?a.Long.prototype.toString.call(e.dims[i]):n.longs===Number?new a.LongBits(e.dims[i].low>>>0,e.dims[i].high>>>0).toNumber():e.dims[i]}if(e.dataType!=null&&e.hasOwnProperty("dataType")&&(r.dataType=e.dataType),e.segment!=null&&e.hasOwnProperty("segment")&&(r.segment=o.onnx.TensorProto.Segment.toObject(e.segment,n)),e.floatData&&e.floatData.length)for(r.floatData=[],i=0;i<e.floatData.length;++i)r.floatData[i]=n.json&&!isFinite(e.floatData[i])?String(e.floatData[i]):e.floatData[i];if(e.int32Data&&e.int32Data.length)for(r.int32Data=[],i=0;i<e.int32Data.length;++i)r.int32Data[i]=e.int32Data[i];if(e.stringData&&e.stringData.length)for(r.stringData=[],i=0;i<e.stringData.length;++i)r.stringData[i]=n.bytes===String?a.base64.encode(e.stringData[i],0,e.stringData[i].length):n.bytes===Array?Array.prototype.slice.call(e.stringData[i]):e.stringData[i];if(e.int64Data&&e.int64Data.length)for(r.int64Data=[],i=0;i<e.int64Data.length;++i)typeof e.int64Data[i]=="number"?r.int64Data[i]=n.longs===String?String(e.int64Data[i]):e.int64Data[i]:r.int64Data[i]=n.longs===String?a.Long.prototype.toString.call(e.int64Data[i]):n.longs===Number?new a.LongBits(e.int64Data[i].low>>>0,e.int64Data[i].high>>>0).toNumber():e.int64Data[i];if(e.name!=null&&e.hasOwnProperty("name")&&(r.name=e.name),e.rawData!=null&&e.hasOwnProperty("rawData")&&(r.rawData=n.bytes===String?a.base64.encode(e.rawData,0,e.rawData.length):n.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(r.doubleData=[],i=0;i<e.doubleData.length;++i)r.doubleData[i]=n.json&&!isFinite(e.doubleData[i])?String(e.doubleData[i]):e.doubleData[i];if(e.uint64Data&&e.uint64Data.length)for(r.uint64Data=[],i=0;i<e.uint64Data.length;++i)typeof e.uint64Data[i]=="number"?r.uint64Data[i]=n.longs===String?String(e.uint64Data[i]):e.uint64Data[i]:r.uint64Data[i]=n.longs===String?a.Long.prototype.toString.call(e.uint64Data[i]):n.longs===Number?new a.LongBits(e.uint64Data[i].low>>>0,e.uint64Data[i].high>>>0).toNumber(!0):e.uint64Data[i];if(e.docString!=null&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.externalData&&e.externalData.length)for(r.externalData=[],i=0;i<e.externalData.length;++i)r.externalData[i]=o.onnx.StringStringEntryProto.toObject(e.externalData[i],n);return e.dataLocation!=null&&e.hasOwnProperty("dataLocation")&&(r.dataLocation=n.enums===String?o.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t.DataType=function(){var e={},n=Object.create(e);return n[e[0]="UNDEFINED"]=0,n[e[1]="FLOAT"]=1,n[e[2]="UINT8"]=2,n[e[3]="INT8"]=3,n[e[4]="UINT16"]=4,n[e[5]="INT16"]=5,n[e[6]="INT32"]=6,n[e[7]="INT64"]=7,n[e[8]="STRING"]=8,n[e[9]="BOOL"]=9,n[e[10]="FLOAT16"]=10,n[e[11]="DOUBLE"]=11,n[e[12]="UINT32"]=12,n[e[13]="UINT64"]=13,n[e[14]="COMPLEX64"]=14,n[e[15]="COMPLEX128"]=15,n[e[16]="BFLOAT16"]=16,n}(),t.Segment=function(){function e(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)n[r[i]]!=null&&(this[r[i]]=n[r[i]])}return e.prototype.begin=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.end=a.Long?a.Long.fromBits(0,0,!1):0,e.create=function(n){return new e(n)},e.encode=function(n,r){return r||(r=d.create()),n.begin!=null&&n.hasOwnProperty("begin")&&r.uint32(8).int64(n.begin),n.end!=null&&n.hasOwnProperty("end")&&r.uint32(16).int64(n.end),r},e.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},e.decode=function(n,r){n instanceof l||(n=l.create(n));for(var i=r===void 0?n.len:n.pos+r,c=new o.onnx.TensorProto.Segment;n.pos<i;){var f=n.uint32();switch(f>>>3){case 1:c.begin=n.int64();break;case 2:c.end=n.int64();break;default:n.skipType(7&f)}}return c},e.decodeDelimited=function(n){return n instanceof l||(n=new l(n)),this.decode(n,n.uint32())},e.verify=function(n){return typeof n!="object"||n===null?"object expected":n.begin!=null&&n.hasOwnProperty("begin")&&!(a.isInteger(n.begin)||n.begin&&a.isInteger(n.begin.low)&&a.isInteger(n.begin.high))?"begin: integer|Long expected":n.end!=null&&n.hasOwnProperty("end")&&!(a.isInteger(n.end)||n.end&&a.isInteger(n.end.low)&&a.isInteger(n.end.high))?"end: integer|Long expected":null},e.fromObject=function(n){if(n instanceof o.onnx.TensorProto.Segment)return n;var r=new o.onnx.TensorProto.Segment;return n.begin!=null&&(a.Long?(r.begin=a.Long.fromValue(n.begin)).unsigned=!1:typeof n.begin=="string"?r.begin=parseInt(n.begin,10):typeof n.begin=="number"?r.begin=n.begin:typeof n.begin=="object"&&(r.begin=new a.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber())),n.end!=null&&(a.Long?(r.end=a.Long.fromValue(n.end)).unsigned=!1:typeof n.end=="string"?r.end=parseInt(n.end,10):typeof n.end=="number"?r.end=n.end:typeof n.end=="object"&&(r.end=new a.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber())),r},e.toObject=function(n,r){r||(r={});var i={};if(r.defaults){if(a.Long){var c=new a.Long(0,0,!1);i.begin=r.longs===String?c.toString():r.longs===Number?c.toNumber():c}else i.begin=r.longs===String?"0":0;a.Long?(c=new a.Long(0,0,!1),i.end=r.longs===String?c.toString():r.longs===Number?c.toNumber():c):i.end=r.longs===String?"0":0}return n.begin!=null&&n.hasOwnProperty("begin")&&(typeof n.begin=="number"?i.begin=r.longs===String?String(n.begin):n.begin:i.begin=r.longs===String?a.Long.prototype.toString.call(n.begin):r.longs===Number?new a.LongBits(n.begin.low>>>0,n.begin.high>>>0).toNumber():n.begin),n.end!=null&&n.hasOwnProperty("end")&&(typeof n.end=="number"?i.end=r.longs===String?String(n.end):n.end:i.end=r.longs===String?a.Long.prototype.toString.call(n.end):r.longs===Number?new a.LongBits(n.end.low>>>0,n.end.high>>>0).toNumber():n.end),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),t.DataLocation=function(){var e={},n=Object.create(e);return n[e[0]="DEFAULT"]=0,n[e[1]="EXTERNAL"]=1,n}(),t}(),m.TensorShapeProto=function(){function t(e){if(this.dim=[],e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.dim=a.emptyArray,t.create=function(e){return new t(e)},t.encode=function(e,n){if(n||(n=d.create()),e.dim!=null&&e.dim.length)for(var r=0;r<e.dim.length;++r)o.onnx.TensorShapeProto.Dimension.encode(e.dim[r],n.uint32(10).fork()).ldelim();return n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.TensorShapeProto;e.pos<r;){var c=e.uint32();c>>>3==1?(i.dim&&i.dim.length||(i.dim=[]),i.dim.push(o.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&c)}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){if(typeof e!="object"||e===null)return"object expected";if(e.dim!=null&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var n=0;n<e.dim.length;++n){var r=o.onnx.TensorShapeProto.Dimension.verify(e.dim[n]);if(r)return"dim."+r}}return null},t.fromObject=function(e){if(e instanceof o.onnx.TensorShapeProto)return e;var n=new o.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");n.dim=[];for(var r=0;r<e.dim.length;++r){if(typeof e.dim[r]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");n.dim[r]=o.onnx.TensorShapeProto.Dimension.fromObject(e.dim[r])}}return n},t.toObject=function(e,n){n||(n={});var r={};if((n.arrays||n.defaults)&&(r.dim=[]),e.dim&&e.dim.length){r.dim=[];for(var i=0;i<e.dim.length;++i)r.dim[i]=o.onnx.TensorShapeProto.Dimension.toObject(e.dim[i],n)}return r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t.Dimension=function(){function e(r){if(r)for(var i=Object.keys(r),c=0;c<i.length;++c)r[i[c]]!=null&&(this[i[c]]=r[i[c]])}var n;return e.prototype.dimValue=a.Long?a.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:a.oneOfGetter(n=["dimValue","dimParam"]),set:a.oneOfSetter(n)}),e.create=function(r){return new e(r)},e.encode=function(r,i){return i||(i=d.create()),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&i.uint32(8).int64(r.dimValue),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&i.uint32(18).string(r.dimParam),r.denotation!=null&&r.hasOwnProperty("denotation")&&i.uint32(26).string(r.denotation),i},e.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},e.decode=function(r,i){r instanceof l||(r=l.create(r));for(var c=i===void 0?r.len:r.pos+i,f=new o.onnx.TensorShapeProto.Dimension;r.pos<c;){var y=r.uint32();switch(y>>>3){case 1:f.dimValue=r.int64();break;case 2:f.dimParam=r.string();break;case 3:f.denotation=r.string();break;default:r.skipType(7&y)}}return f},e.decodeDelimited=function(r){return r instanceof l||(r=new l(r)),this.decode(r,r.uint32())},e.verify=function(r){if(typeof r!="object"||r===null)return"object expected";var i={};if(r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(i.value=1,!(a.isInteger(r.dimValue)||r.dimValue&&a.isInteger(r.dimValue.low)&&a.isInteger(r.dimValue.high))))return"dimValue: integer|Long expected";if(r.dimParam!=null&&r.hasOwnProperty("dimParam")){if(i.value===1)return"value: multiple values";if(i.value=1,!a.isString(r.dimParam))return"dimParam: string expected"}return r.denotation!=null&&r.hasOwnProperty("denotation")&&!a.isString(r.denotation)?"denotation: string expected":null},e.fromObject=function(r){if(r instanceof o.onnx.TensorShapeProto.Dimension)return r;var i=new o.onnx.TensorShapeProto.Dimension;return r.dimValue!=null&&(a.Long?(i.dimValue=a.Long.fromValue(r.dimValue)).unsigned=!1:typeof r.dimValue=="string"?i.dimValue=parseInt(r.dimValue,10):typeof r.dimValue=="number"?i.dimValue=r.dimValue:typeof r.dimValue=="object"&&(i.dimValue=new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber())),r.dimParam!=null&&(i.dimParam=String(r.dimParam)),r.denotation!=null&&(i.denotation=String(r.denotation)),i},e.toObject=function(r,i){i||(i={});var c={};return i.defaults&&(c.denotation=""),r.dimValue!=null&&r.hasOwnProperty("dimValue")&&(typeof r.dimValue=="number"?c.dimValue=i.longs===String?String(r.dimValue):r.dimValue:c.dimValue=i.longs===String?a.Long.prototype.toString.call(r.dimValue):i.longs===Number?new a.LongBits(r.dimValue.low>>>0,r.dimValue.high>>>0).toNumber():r.dimValue,i.oneofs&&(c.value="dimValue")),r.dimParam!=null&&r.hasOwnProperty("dimParam")&&(c.dimParam=r.dimParam,i.oneofs&&(c.value="dimParam")),r.denotation!=null&&r.hasOwnProperty("denotation")&&(c.denotation=r.denotation),c},e.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},e}(),t}(),m.TypeProto=function(){function t(n){if(n)for(var r=Object.keys(n),i=0;i<r.length;++i)n[r[i]]!=null&&(this[r[i]]=n[r[i]])}var e;return t.prototype.tensorType=null,t.prototype.denotation="",Object.defineProperty(t.prototype,"value",{get:a.oneOfGetter(e=["tensorType"]),set:a.oneOfSetter(e)}),t.create=function(n){return new t(n)},t.encode=function(n,r){return r||(r=d.create()),n.tensorType!=null&&n.hasOwnProperty("tensorType")&&o.onnx.TypeProto.Tensor.encode(n.tensorType,r.uint32(10).fork()).ldelim(),n.denotation!=null&&n.hasOwnProperty("denotation")&&r.uint32(50).string(n.denotation),r},t.encodeDelimited=function(n,r){return this.encode(n,r).ldelim()},t.decode=function(n,r){n instanceof l||(n=l.create(n));for(var i=r===void 0?n.len:n.pos+r,c=new o.onnx.TypeProto;n.pos<i;){var f=n.uint32();switch(f>>>3){case 1:c.tensorType=o.onnx.TypeProto.Tensor.decode(n,n.uint32());break;case 6:c.denotation=n.string();break;default:n.skipType(7&f)}}return c},t.decodeDelimited=function(n){return n instanceof l||(n=new l(n)),this.decode(n,n.uint32())},t.verify=function(n){if(typeof n!="object"||n===null)return"object expected";if(n.tensorType!=null&&n.hasOwnProperty("tensorType")){var r=o.onnx.TypeProto.Tensor.verify(n.tensorType);if(r)return"tensorType."+r}return n.denotation!=null&&n.hasOwnProperty("denotation")&&!a.isString(n.denotation)?"denotation: string expected":null},t.fromObject=function(n){if(n instanceof o.onnx.TypeProto)return n;var r=new o.onnx.TypeProto;if(n.tensorType!=null){if(typeof n.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");r.tensorType=o.onnx.TypeProto.Tensor.fromObject(n.tensorType)}return n.denotation!=null&&(r.denotation=String(n.denotation)),r},t.toObject=function(n,r){r||(r={});var i={};return r.defaults&&(i.denotation=""),n.tensorType!=null&&n.hasOwnProperty("tensorType")&&(i.tensorType=o.onnx.TypeProto.Tensor.toObject(n.tensorType,r),r.oneofs&&(i.value="tensorType")),n.denotation!=null&&n.hasOwnProperty("denotation")&&(i.denotation=n.denotation),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t.Tensor=function(){function n(r){if(r)for(var i=Object.keys(r),c=0;c<i.length;++c)r[i[c]]!=null&&(this[i[c]]=r[i[c]])}return n.prototype.elemType=0,n.prototype.shape=null,n.create=function(r){return new n(r)},n.encode=function(r,i){return i||(i=d.create()),r.elemType!=null&&r.hasOwnProperty("elemType")&&i.uint32(8).int32(r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&o.onnx.TensorShapeProto.encode(r.shape,i.uint32(18).fork()).ldelim(),i},n.encodeDelimited=function(r,i){return this.encode(r,i).ldelim()},n.decode=function(r,i){r instanceof l||(r=l.create(r));for(var c=i===void 0?r.len:r.pos+i,f=new o.onnx.TypeProto.Tensor;r.pos<c;){var y=r.uint32();switch(y>>>3){case 1:f.elemType=r.int32();break;case 2:f.shape=o.onnx.TensorShapeProto.decode(r,r.uint32());break;default:r.skipType(7&y)}}return f},n.decodeDelimited=function(r){return r instanceof l||(r=new l(r)),this.decode(r,r.uint32())},n.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.elemType!=null&&r.hasOwnProperty("elemType")&&!a.isInteger(r.elemType))return"elemType: integer expected";if(r.shape!=null&&r.hasOwnProperty("shape")){var i=o.onnx.TensorShapeProto.verify(r.shape);if(i)return"shape."+i}return null},n.fromObject=function(r){if(r instanceof o.onnx.TypeProto.Tensor)return r;var i=new o.onnx.TypeProto.Tensor;if(r.elemType!=null&&(i.elemType=0|r.elemType),r.shape!=null){if(typeof r.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");i.shape=o.onnx.TensorShapeProto.fromObject(r.shape)}return i},n.toObject=function(r,i){i||(i={});var c={};return i.defaults&&(c.elemType=0,c.shape=null),r.elemType!=null&&r.hasOwnProperty("elemType")&&(c.elemType=r.elemType),r.shape!=null&&r.hasOwnProperty("shape")&&(c.shape=o.onnx.TensorShapeProto.toObject(r.shape,i)),c},n.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},n}(),t}(),m.OperatorSetIdProto=function(){function t(e){if(e)for(var n=Object.keys(e),r=0;r<n.length;++r)e[n[r]]!=null&&(this[n[r]]=e[n[r]])}return t.prototype.domain="",t.prototype.version=a.Long?a.Long.fromBits(0,0,!1):0,t.create=function(e){return new t(e)},t.encode=function(e,n){return n||(n=d.create()),e.domain!=null&&e.hasOwnProperty("domain")&&n.uint32(10).string(e.domain),e.version!=null&&e.hasOwnProperty("version")&&n.uint32(16).int64(e.version),n},t.encodeDelimited=function(e,n){return this.encode(e,n).ldelim()},t.decode=function(e,n){e instanceof l||(e=l.create(e));for(var r=n===void 0?e.len:e.pos+n,i=new o.onnx.OperatorSetIdProto;e.pos<r;){var c=e.uint32();switch(c>>>3){case 1:i.domain=e.string();break;case 2:i.version=e.int64();break;default:e.skipType(7&c)}}return i},t.decodeDelimited=function(e){return e instanceof l||(e=new l(e)),this.decode(e,e.uint32())},t.verify=function(e){return typeof e!="object"||e===null?"object expected":e.domain!=null&&e.hasOwnProperty("domain")&&!a.isString(e.domain)?"domain: string expected":e.version!=null&&e.hasOwnProperty("version")&&!(a.isInteger(e.version)||e.version&&a.isInteger(e.version.low)&&a.isInteger(e.version.high))?"version: integer|Long expected":null},t.fromObject=function(e){if(e instanceof o.onnx.OperatorSetIdProto)return e;var n=new o.onnx.OperatorSetIdProto;return e.domain!=null&&(n.domain=String(e.domain)),e.version!=null&&(a.Long?(n.version=a.Long.fromValue(e.version)).unsigned=!1:typeof e.version=="string"?n.version=parseInt(e.version,10):typeof e.version=="number"?n.version=e.version:typeof e.version=="object"&&(n.version=new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),n},t.toObject=function(e,n){n||(n={});var r={};if(n.defaults)if(r.domain="",a.Long){var i=new a.Long(0,0,!1);r.version=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else r.version=n.longs===String?"0":0;return e.domain!=null&&e.hasOwnProperty("domain")&&(r.domain=e.domain),e.version!=null&&e.hasOwnProperty("version")&&(typeof e.version=="number"?r.version=n.longs===String?String(e.version):e.version:r.version=n.longs===String?a.Long.prototype.toString.call(e.version):n.longs===Number?new a.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),r},t.prototype.toJSON=function(){return this.constructor.toObject(this,s.util.toJSONOptions)},t}(),m),v.exports=o},2100:(v,u,b)=>{v.exports=b(9482)},9482:(v,u,b)=>{var g=u;function p(){g.util._configure(),g.Writer._configure(g.BufferWriter),g.Reader._configure(g.BufferReader)}g.build="minimal",g.Writer=b(1173),g.BufferWriter=b(3155),g.Reader=b(1408),g.BufferReader=b(593),g.util=b(9693),g.rpc=b(5994),g.roots=b(5054),g.configure=p,p()},1408:(v,u,b)=>{v.exports=d;var g,p=b(9693),m=p.LongBits,s=p.utf8;function l(i,c){return RangeError("index out of range: "+i.pos+" + "+(c||1)+" > "+i.len)}function d(i){this.buf=i,this.pos=0,this.len=i.length}var a,o=typeof Uint8Array<"u"?function(i){if(i instanceof Uint8Array||Array.isArray(i))return new d(i);throw Error("illegal buffer")}:function(i){if(Array.isArray(i))return new d(i);throw Error("illegal buffer")},t=function(){return p.Buffer?function(i){return(d.create=function(c){return p.Buffer.isBuffer(c)?new g(c):o(c)})(i)}:o};function e(){var i=new m(0,0),c=0;if(!(this.len-this.pos>4)){for(;c<3;++c){if(this.pos>=this.len)throw l(this);if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*c)>>>0,this.buf[this.pos++]<128)return i}return i.lo=(i.lo|(127&this.buf[this.pos++])<<7*c)>>>0,i}for(;c<4;++c)if(i.lo=(i.lo|(127&this.buf[this.pos])<<7*c)>>>0,this.buf[this.pos++]<128)return i;if(i.lo=(i.lo|(127&this.buf[this.pos])<<28)>>>0,i.hi=(i.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return i;if(c=0,this.len-this.pos>4){for(;c<5;++c)if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*c+3)>>>0,this.buf[this.pos++]<128)return i}else for(;c<5;++c){if(this.pos>=this.len)throw l(this);if(i.hi=(i.hi|(127&this.buf[this.pos])<<7*c+3)>>>0,this.buf[this.pos++]<128)return i}throw Error("invalid varint encoding")}function n(i,c){return(i[c-4]|i[c-3]<<8|i[c-2]<<16|i[c-1]<<24)>>>0}function r(){if(this.pos+8>this.len)throw l(this,8);return new m(n(this.buf,this.pos+=4),n(this.buf,this.pos+=4))}d.create=t(),d.prototype._slice=p.Array.prototype.subarray||p.Array.prototype.slice,d.prototype.uint32=(a=4294967295,function(){if(a=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(a=(a|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(a=(a|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(a=(a|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return a;if((this.pos+=5)>this.len)throw this.pos=this.len,l(this,10);return a}),d.prototype.int32=function(){return 0|this.uint32()},d.prototype.sint32=function(){var i=this.uint32();return i>>>1^-(1&i)|0},d.prototype.bool=function(){return this.uint32()!==0},d.prototype.fixed32=function(){if(this.pos+4>this.len)throw l(this,4);return n(this.buf,this.pos+=4)},d.prototype.sfixed32=function(){if(this.pos+4>this.len)throw l(this,4);return 0|n(this.buf,this.pos+=4)},d.prototype.float=function(){if(this.pos+4>this.len)throw l(this,4);var i=p.float.readFloatLE(this.buf,this.pos);return this.pos+=4,i},d.prototype.double=function(){if(this.pos+8>this.len)throw l(this,4);var i=p.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,i},d.prototype.bytes=function(){var i=this.uint32(),c=this.pos,f=this.pos+i;if(f>this.len)throw l(this,i);return this.pos+=i,Array.isArray(this.buf)?this.buf.slice(c,f):c===f?new this.buf.constructor(0):this._slice.call(this.buf,c,f)},d.prototype.string=function(){var i=this.bytes();return s.read(i,0,i.length)},d.prototype.skip=function(i){if(typeof i=="number"){if(this.pos+i>this.len)throw l(this,i);this.pos+=i}else do if(this.pos>=this.len)throw l(this);while(128&this.buf[this.pos++]);return this},d.prototype.skipType=function(i){switch(i){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(i=7&this.uint32())!=4;)this.skipType(i);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+i+" at offset "+this.pos)}return this},d._configure=function(i){g=i,d.create=t(),g._configure();var c=p.Long?"toLong":"toNumber";p.merge(d.prototype,{int64:function(){return e.call(this)[c](!1)},uint64:function(){return e.call(this)[c](!0)},sint64:function(){return e.call(this).zzDecode()[c](!1)},fixed64:function(){return r.call(this)[c](!0)},sfixed64:function(){return r.call(this)[c](!1)}})}},593:(v,u,b)=>{v.exports=m;var g=b(1408);(m.prototype=Object.create(g.prototype)).constructor=m;var p=b(9693);function m(s){g.call(this,s)}m._configure=function(){p.Buffer&&(m.prototype._slice=p.Buffer.prototype.slice)},m.prototype.string=function(){var s=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+s,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+s,this.len))},m._configure()},5054:v=>{v.exports={}},5994:(v,u,b)=>{u.Service=b(7948)},7948:(v,u,b)=>{v.exports=p;var g=b(9693);function p(m,s,l){if(typeof m!="function")throw TypeError("rpcImpl must be a function");g.EventEmitter.call(this),this.rpcImpl=m,this.requestDelimited=!!s,this.responseDelimited=!!l}(p.prototype=Object.create(g.EventEmitter.prototype)).constructor=p,p.prototype.rpcCall=function m(s,l,d,a,o){if(!a)throw TypeError("request must be specified");var t=this;if(!o)return g.asPromise(m,t,s,l,d,a);if(t.rpcImpl)try{return t.rpcImpl(s,l[t.requestDelimited?"encodeDelimited":"encode"](a).finish(),function(e,n){if(e)return t.emit("error",e,s),o(e);if(n!==null){if(!(n instanceof d))try{n=d[t.responseDelimited?"decodeDelimited":"decode"](n)}catch(r){return t.emit("error",r,s),o(r)}return t.emit("data",n,s),o(null,n)}t.end(!0)})}catch(e){return t.emit("error",e,s),void setTimeout(function(){o(e)},0)}else setTimeout(function(){o(Error("already ended"))},0)},p.prototype.end=function(m){return this.rpcImpl&&(m||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(v,u,b)=>{v.exports=p;var g=b(9693);function p(d,a){this.lo=d>>>0,this.hi=a>>>0}var m=p.zero=new p(0,0);m.toNumber=function(){return 0},m.zzEncode=m.zzDecode=function(){return this},m.length=function(){return 1};var s=p.zeroHash="\0\0\0\0\0\0\0\0";p.fromNumber=function(d){if(d===0)return m;var a=d<0;a&&(d=-d);var o=d>>>0,t=(d-o)/4294967296>>>0;return a&&(t=~t>>>0,o=~o>>>0,++o>4294967295&&(o=0,++t>4294967295&&(t=0))),new p(o,t)},p.from=function(d){if(typeof d=="number")return p.fromNumber(d);if(g.isString(d)){if(!g.Long)return p.fromNumber(parseInt(d,10));d=g.Long.fromString(d)}return d.low||d.high?new p(d.low>>>0,d.high>>>0):m},p.prototype.toNumber=function(d){if(!d&&this.hi>>>31){var a=1+~this.lo>>>0,o=~this.hi>>>0;return a||(o=o+1>>>0),-(a+4294967296*o)}return this.lo+4294967296*this.hi},p.prototype.toLong=function(d){return g.Long?new g.Long(0|this.lo,0|this.hi,!!d):{low:0|this.lo,high:0|this.hi,unsigned:!!d}};var l=String.prototype.charCodeAt;p.fromHash=function(d){return d===s?m:new p((l.call(d,0)|l.call(d,1)<<8|l.call(d,2)<<16|l.call(d,3)<<24)>>>0,(l.call(d,4)|l.call(d,5)<<8|l.call(d,6)<<16|l.call(d,7)<<24)>>>0)},p.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},p.prototype.zzEncode=function(){var d=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^d)>>>0,this.lo=(this.lo<<1^d)>>>0,this},p.prototype.zzDecode=function(){var d=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^d)>>>0,this.hi=(this.hi>>>1^d)>>>0,this},p.prototype.length=function(){var d=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,o=this.hi>>>24;return o===0?a===0?d<16384?d<128?1:2:d<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:o<128?9:10}},9693:function(v,u,b){var g=u;function p(s,l,d){for(var a=Object.keys(l),o=0;o<a.length;++o)s[a[o]]!==void 0&&d||(s[a[o]]=l[a[o]]);return s}function m(s){function l(d,a){if(!(this instanceof l))return new l(d,a);Object.defineProperty(this,"message",{get:function(){return d}}),Error.captureStackTrace?Error.captureStackTrace(this,l):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&p(this,a)}return(l.prototype=Object.create(Error.prototype)).constructor=l,Object.defineProperty(l.prototype,"name",{get:function(){return s}}),l.prototype.toString=function(){return this.name+": "+this.message},l}g.asPromise=b(4537),g.base64=b(7419),g.EventEmitter=b(9211),g.float=b(945),g.inquire=b(7199),g.utf8=b(4997),g.pool=b(6662),g.LongBits=b(1945),g.isNode=!!(b.g!==void 0&&b.g&&b.g.process&&b.g.process.versions&&b.g.process.versions.node),g.global=g.isNode&&b.g||typeof window<"u"&&window||typeof self<"u"&&self||this,g.emptyArray=Object.freeze?Object.freeze([]):[],g.emptyObject=Object.freeze?Object.freeze({}):{},g.isInteger=Number.isInteger||function(s){return typeof s=="number"&&isFinite(s)&&Math.floor(s)===s},g.isString=function(s){return typeof s=="string"||s instanceof String},g.isObject=function(s){return s&&typeof s=="object"},g.isset=g.isSet=function(s,l){var d=s[l];return!(d==null||!s.hasOwnProperty(l))&&(typeof d!="object"||(Array.isArray(d)?d.length:Object.keys(d).length)>0)},g.Buffer=function(){try{var s=g.inquire("buffer").Buffer;return s.prototype.utf8Write?s:null}catch{return null}}(),g._Buffer_from=null,g._Buffer_allocUnsafe=null,g.newBuffer=function(s){return typeof s=="number"?g.Buffer?g._Buffer_allocUnsafe(s):new g.Array(s):g.Buffer?g._Buffer_from(s):typeof Uint8Array>"u"?s:new Uint8Array(s)},g.Array=typeof Uint8Array<"u"?Uint8Array:Array,g.Long=g.global.dcodeIO&&g.global.dcodeIO.Long||g.global.Long||g.inquire("long"),g.key2Re=/^true|false|0|1$/,g.key32Re=/^-?(?:0|[1-9][0-9]*)$/,g.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,g.longToHash=function(s){return s?g.LongBits.from(s).toHash():g.LongBits.zeroHash},g.longFromHash=function(s,l){var d=g.LongBits.fromHash(s);return g.Long?g.Long.fromBits(d.lo,d.hi,l):d.toNumber(!!l)},g.merge=p,g.lcFirst=function(s){return s.charAt(0).toLowerCase()+s.substring(1)},g.newError=m,g.ProtocolError=m("ProtocolError"),g.oneOfGetter=function(s){for(var l={},d=0;d<s.length;++d)l[s[d]]=1;return function(){for(var a=Object.keys(this),o=a.length-1;o>-1;--o)if(l[a[o]]===1&&this[a[o]]!==void 0&&this[a[o]]!==null)return a[o]}},g.oneOfSetter=function(s){return function(l){for(var d=0;d<s.length;++d)s[d]!==l&&delete this[s[d]]}},g.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},g._configure=function(){var s=g.Buffer;s?(g._Buffer_from=s.from!==Uint8Array.from&&s.from||function(l,d){return new s(l,d)},g._Buffer_allocUnsafe=s.allocUnsafe||function(l){return new s(l)}):g._Buffer_from=g._Buffer_allocUnsafe=null}},1173:(v,u,b)=>{v.exports=t;var g,p=b(9693),m=p.LongBits,s=p.base64,l=p.utf8;function d(y,w,x){this.fn=y,this.len=w,this.next=void 0,this.val=x}function a(){}function o(y){this.head=y.head,this.tail=y.tail,this.len=y.len,this.next=y.states}function t(){this.len=0,this.head=new d(a,0,0),this.tail=this.head,this.states=null}var e=function(){return p.Buffer?function(){return(t.create=function(){return new g})()}:function(){return new t}};function n(y,w,x){w[x]=255&y}function r(y,w){this.len=y,this.next=void 0,this.val=w}function i(y,w,x){for(;y.hi;)w[x++]=127&y.lo|128,y.lo=(y.lo>>>7|y.hi<<25)>>>0,y.hi>>>=7;for(;y.lo>127;)w[x++]=127&y.lo|128,y.lo=y.lo>>>7;w[x++]=y.lo}function c(y,w,x){w[x]=255&y,w[x+1]=y>>>8&255,w[x+2]=y>>>16&255,w[x+3]=y>>>24}t.create=e(),t.alloc=function(y){return new p.Array(y)},p.Array!==Array&&(t.alloc=p.pool(t.alloc,p.Array.prototype.subarray)),t.prototype._push=function(y,w,x){return this.tail=this.tail.next=new d(y,w,x),this.len+=w,this},r.prototype=Object.create(d.prototype),r.prototype.fn=function(y,w,x){for(;y>127;)w[x++]=127&y|128,y>>>=7;w[x]=y},t.prototype.uint32=function(y){return this.len+=(this.tail=this.tail.next=new r((y>>>=0)<128?1:y<16384?2:y<2097152?3:y<268435456?4:5,y)).len,this},t.prototype.int32=function(y){return y<0?this._push(i,10,m.fromNumber(y)):this.uint32(y)},t.prototype.sint32=function(y){return this.uint32((y<<1^y>>31)>>>0)},t.prototype.uint64=function(y){var w=m.from(y);return this._push(i,w.length(),w)},t.prototype.int64=t.prototype.uint64,t.prototype.sint64=function(y){var w=m.from(y).zzEncode();return this._push(i,w.length(),w)},t.prototype.bool=function(y){return this._push(n,1,y?1:0)},t.prototype.fixed32=function(y){return this._push(c,4,y>>>0)},t.prototype.sfixed32=t.prototype.fixed32,t.prototype.fixed64=function(y){var w=m.from(y);return this._push(c,4,w.lo)._push(c,4,w.hi)},t.prototype.sfixed64=t.prototype.fixed64,t.prototype.float=function(y){return this._push(p.float.writeFloatLE,4,y)},t.prototype.double=function(y){return this._push(p.float.writeDoubleLE,8,y)};var f=p.Array.prototype.set?function(y,w,x){w.set(y,x)}:function(y,w,x){for(var _=0;_<y.length;++_)w[x+_]=y[_]};t.prototype.bytes=function(y){var w=y.length>>>0;if(!w)return this._push(n,1,0);if(p.isString(y)){var x=t.alloc(w=s.length(y));s.decode(y,x,0),y=x}return this.uint32(w)._push(f,w,y)},t.prototype.string=function(y){var w=l.length(y);return w?this.uint32(w)._push(l.write,w,y):this._push(n,1,0)},t.prototype.fork=function(){return this.states=new o(this),this.head=this.tail=new d(a,0,0),this.len=0,this},t.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new d(a,0,0),this.len=0),this},t.prototype.ldelim=function(){var y=this.head,w=this.tail,x=this.len;return this.reset().uint32(x),x&&(this.tail.next=y.next,this.tail=w,this.len+=x),this},t.prototype.finish=function(){for(var y=this.head.next,w=this.constructor.alloc(this.len),x=0;y;)y.fn(y.val,w,x),x+=y.len,y=y.next;return w},t._configure=function(y){g=y,t.create=e(),g._configure()}},3155:(v,u,b)=>{v.exports=m;var g=b(1173);(m.prototype=Object.create(g.prototype)).constructor=m;var p=b(9693);function m(){g.call(this)}function s(l,d,a){l.length<40?p.utf8.write(l,d,a):d.utf8Write?d.utf8Write(l,a):d.write(l,a)}m._configure=function(){m.alloc=p._Buffer_allocUnsafe,m.writeBytesBuffer=p.Buffer&&p.Buffer.prototype instanceof Uint8Array&&p.Buffer.prototype.set.name==="set"?function(l,d,a){d.set(l,a)}:function(l,d,a){if(l.copy)l.copy(d,a,0,l.length);else for(var o=0;o<l.length;)d[a++]=l[o++]}},m.prototype.bytes=function(l){p.isString(l)&&(l=p._Buffer_from(l,"base64"));var d=l.length>>>0;return this.uint32(d),d&&this._push(m.writeBytesBuffer,d,l),this},m.prototype.string=function(l){var d=p.Buffer.byteLength(l);return this.uint32(d),d&&this._push(s,d,l),this},m._configure()},4154:v=>{v.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(v,u,b)=>{b.r(u),b.d(u,{flatbuffers:()=>g});var g={};g.Offset,g.Table,g.SIZEOF_SHORT=2,g.SIZEOF_INT=4,g.FILE_IDENTIFIER_LENGTH=4,g.SIZE_PREFIX_LENGTH=4,g.Encoding={UTF8_BYTES:1,UTF16_STRING:2},g.int32=new Int32Array(2),g.float32=new Float32Array(g.int32.buffer),g.float64=new Float64Array(g.int32.buffer),g.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,g.Long=function(p,m){this.low=0|p,this.high=0|m},g.Long.create=function(p,m){return p==0&&m==0?g.Long.ZERO:new g.Long(p,m)},g.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},g.Long.prototype.equals=function(p){return this.low==p.low&&this.high==p.high},g.Long.ZERO=new g.Long(0,0),g.Builder=function(p){if(p)m=p;else var m=1024;this.bb=g.ByteBuffer.allocate(m),this.space=m,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},g.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},g.Builder.prototype.forceDefaults=function(p){this.force_defaults=p},g.Builder.prototype.dataBuffer=function(){return this.bb},g.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},g.Builder.prototype.prep=function(p,m){p>this.minalign&&(this.minalign=p);for(var s=1+~(this.bb.capacity()-this.space+m)&p-1;this.space<s+p+m;){var l=this.bb.capacity();this.bb=g.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-l}this.pad(s)},g.Builder.prototype.pad=function(p){for(var m=0;m<p;m++)this.bb.writeInt8(--this.space,0)},g.Builder.prototype.writeInt8=function(p){this.bb.writeInt8(this.space-=1,p)},g.Builder.prototype.writeInt16=function(p){this.bb.writeInt16(this.space-=2,p)},g.Builder.prototype.writeInt32=function(p){this.bb.writeInt32(this.space-=4,p)},g.Builder.prototype.writeInt64=function(p){this.bb.writeInt64(this.space-=8,p)},g.Builder.prototype.writeFloat32=function(p){this.bb.writeFloat32(this.space-=4,p)},g.Builder.prototype.writeFloat64=function(p){this.bb.writeFloat64(this.space-=8,p)},g.Builder.prototype.addInt8=function(p){this.prep(1,0),this.writeInt8(p)},g.Builder.prototype.addInt16=function(p){this.prep(2,0),this.writeInt16(p)},g.Builder.prototype.addInt32=function(p){this.prep(4,0),this.writeInt32(p)},g.Builder.prototype.addInt64=function(p){this.prep(8,0),this.writeInt64(p)},g.Builder.prototype.addFloat32=function(p){this.prep(4,0),this.writeFloat32(p)},g.Builder.prototype.addFloat64=function(p){this.prep(8,0),this.writeFloat64(p)},g.Builder.prototype.addFieldInt8=function(p,m,s){(this.force_defaults||m!=s)&&(this.addInt8(m),this.slot(p))},g.Builder.prototype.addFieldInt16=function(p,m,s){(this.force_defaults||m!=s)&&(this.addInt16(m),this.slot(p))},g.Builder.prototype.addFieldInt32=function(p,m,s){(this.force_defaults||m!=s)&&(this.addInt32(m),this.slot(p))},g.Builder.prototype.addFieldInt64=function(p,m,s){!this.force_defaults&&m.equals(s)||(this.addInt64(m),this.slot(p))},g.Builder.prototype.addFieldFloat32=function(p,m,s){(this.force_defaults||m!=s)&&(this.addFloat32(m),this.slot(p))},g.Builder.prototype.addFieldFloat64=function(p,m,s){(this.force_defaults||m!=s)&&(this.addFloat64(m),this.slot(p))},g.Builder.prototype.addFieldOffset=function(p,m,s){(this.force_defaults||m!=s)&&(this.addOffset(m),this.slot(p))},g.Builder.prototype.addFieldStruct=function(p,m,s){m!=s&&(this.nested(m),this.slot(p))},g.Builder.prototype.nested=function(p){if(p!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},g.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},g.Builder.prototype.slot=function(p){this.vtable[p]=this.offset()},g.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},g.Builder.growByteBuffer=function(p){var m=p.capacity();if(3221225472&m)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var s=m<<1,l=g.ByteBuffer.allocate(s);return l.setPosition(s-m),l.bytes().set(p.bytes(),s-m),l},g.Builder.prototype.addOffset=function(p){this.prep(g.SIZEOF_INT,0),this.writeInt32(this.offset()-p+g.SIZEOF_INT)},g.Builder.prototype.startObject=function(p){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=p;for(var m=0;m<p;m++)this.vtable[m]=0;this.isNested=!0,this.object_start=this.offset()},g.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var p=this.offset(),m=this.vtable_in_use-1;m>=0&&this.vtable[m]==0;m--);for(var s=m+1;m>=0;m--)this.addInt16(this.vtable[m]!=0?p-this.vtable[m]:0);this.addInt16(p-this.object_start);var l=(s+2)*g.SIZEOF_SHORT;this.addInt16(l);var d=0,a=this.space;e:for(m=0;m<this.vtables.length;m++){var o=this.bb.capacity()-this.vtables[m];if(l==this.bb.readInt16(o)){for(var t=g.SIZEOF_SHORT;t<l;t+=g.SIZEOF_SHORT)if(this.bb.readInt16(a+t)!=this.bb.readInt16(o+t))continue e;d=this.vtables[m];break}}return d?(this.space=this.bb.capacity()-p,this.bb.writeInt32(this.space,d-p)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-p,this.offset()-p)),this.isNested=!1,p},g.Builder.prototype.finish=function(p,m,s){var l=s?g.SIZE_PREFIX_LENGTH:0;if(m){var d=m;if(this.prep(this.minalign,g.SIZEOF_INT+g.FILE_IDENTIFIER_LENGTH+l),d.length!=g.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+g.FILE_IDENTIFIER_LENGTH);for(var a=g.FILE_IDENTIFIER_LENGTH-1;a>=0;a--)this.writeInt8(d.charCodeAt(a))}this.prep(this.minalign,g.SIZEOF_INT+l),this.addOffset(p),l&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},g.Builder.prototype.finishSizePrefixed=function(p,m){this.finish(p,m,!0)},g.Builder.prototype.requiredField=function(p,m){var s=this.bb.capacity()-p,l=s-this.bb.readInt32(s);if(this.bb.readInt16(l+m)==0)throw new Error("FlatBuffers: field "+m+" must be set")},g.Builder.prototype.startVector=function(p,m,s){this.notNested(),this.vector_num_elems=m,this.prep(g.SIZEOF_INT,p*m),this.prep(s,p*m)},g.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},g.Builder.prototype.createString=function(p){if(p instanceof Uint8Array)var m=p;else{m=[];for(var s=0;s<p.length;){var l,d=p.charCodeAt(s++);(l=d<55296||d>=56320?d:(d<<10)+p.charCodeAt(s++)+-56613888)<128?m.push(l):(l<2048?m.push(l>>6&31|192):(l<65536?m.push(l>>12&15|224):m.push(l>>18&7|240,l>>12&63|128),m.push(l>>6&63|128)),m.push(63&l|128))}}this.addInt8(0),this.startVector(1,m.length,1),this.bb.setPosition(this.space-=m.length),s=0;for(var a=this.space,o=this.bb.bytes();s<m.length;s++)o[a++]=m[s];return this.endVector()},g.Builder.prototype.createLong=function(p,m){return g.Long.create(p,m)},g.ByteBuffer=function(p){this.bytes_=p,this.position_=0},g.ByteBuffer.allocate=function(p){return new g.ByteBuffer(new Uint8Array(p))},g.ByteBuffer.prototype.clear=function(){this.position_=0},g.ByteBuffer.prototype.bytes=function(){return this.bytes_},g.ByteBuffer.prototype.position=function(){return this.position_},g.ByteBuffer.prototype.setPosition=function(p){this.position_=p},g.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},g.ByteBuffer.prototype.readInt8=function(p){return this.readUint8(p)<<24>>24},g.ByteBuffer.prototype.readUint8=function(p){return this.bytes_[p]},g.ByteBuffer.prototype.readInt16=function(p){return this.readUint16(p)<<16>>16},g.ByteBuffer.prototype.readUint16=function(p){return this.bytes_[p]|this.bytes_[p+1]<<8},g.ByteBuffer.prototype.readInt32=function(p){return this.bytes_[p]|this.bytes_[p+1]<<8|this.bytes_[p+2]<<16|this.bytes_[p+3]<<24},g.ByteBuffer.prototype.readUint32=function(p){return this.readInt32(p)>>>0},g.ByteBuffer.prototype.readInt64=function(p){return new g.Long(this.readInt32(p),this.readInt32(p+4))},g.ByteBuffer.prototype.readUint64=function(p){return new g.Long(this.readUint32(p),this.readUint32(p+4))},g.ByteBuffer.prototype.readFloat32=function(p){return g.int32[0]=this.readInt32(p),g.float32[0]},g.ByteBuffer.prototype.readFloat64=function(p){return g.int32[g.isLittleEndian?0:1]=this.readInt32(p),g.int32[g.isLittleEndian?1:0]=this.readInt32(p+4),g.float64[0]},g.ByteBuffer.prototype.writeInt8=function(p,m){this.bytes_[p]=m},g.ByteBuffer.prototype.writeUint8=function(p,m){this.bytes_[p]=m},g.ByteBuffer.prototype.writeInt16=function(p,m){this.bytes_[p]=m,this.bytes_[p+1]=m>>8},g.ByteBuffer.prototype.writeUint16=function(p,m){this.bytes_[p]=m,this.bytes_[p+1]=m>>8},g.ByteBuffer.prototype.writeInt32=function(p,m){this.bytes_[p]=m,this.bytes_[p+1]=m>>8,this.bytes_[p+2]=m>>16,this.bytes_[p+3]=m>>24},g.ByteBuffer.prototype.writeUint32=function(p,m){this.bytes_[p]=m,this.bytes_[p+1]=m>>8,this.bytes_[p+2]=m>>16,this.bytes_[p+3]=m>>24},g.ByteBuffer.prototype.writeInt64=function(p,m){this.writeInt32(p,m.low),this.writeInt32(p+4,m.high)},g.ByteBuffer.prototype.writeUint64=function(p,m){this.writeUint32(p,m.low),this.writeUint32(p+4,m.high)},g.ByteBuffer.prototype.writeFloat32=function(p,m){g.float32[0]=m,this.writeInt32(p,g.int32[0])},g.ByteBuffer.prototype.writeFloat64=function(p,m){g.float64[0]=m,this.writeInt32(p,g.int32[g.isLittleEndian?0:1]),this.writeInt32(p+4,g.int32[g.isLittleEndian?1:0])},g.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+g.SIZEOF_INT+g.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var p="",m=0;m<g.FILE_IDENTIFIER_LENGTH;m++)p+=String.fromCharCode(this.readInt8(this.position_+g.SIZEOF_INT+m));return p},g.ByteBuffer.prototype.__offset=function(p,m){var s=p-this.readInt32(p);return m<this.readInt16(s)?this.readInt16(s+m):0},g.ByteBuffer.prototype.__union=function(p,m){return p.bb_pos=m+this.readInt32(m),p.bb=this,p},g.ByteBuffer.prototype.__string=function(p,m){p+=this.readInt32(p);var s=this.readInt32(p),l="",d=0;if(p+=g.SIZEOF_INT,m===g.Encoding.UTF8_BYTES)return this.bytes_.subarray(p,p+s);for(;d<s;){var a,o=this.readUint8(p+d++);if(o<192)a=o;else{var t=this.readUint8(p+d++);if(o<224)a=(31&o)<<6|63&t;else{var e=this.readUint8(p+d++);a=o<240?(15&o)<<12|(63&t)<<6|63&e:(7&o)<<18|(63&t)<<12|(63&e)<<6|63&this.readUint8(p+d++)}}a<65536?l+=String.fromCharCode(a):(a-=65536,l+=String.fromCharCode(55296+(a>>10),56320+(1023&a)))}return l},g.ByteBuffer.prototype.__indirect=function(p){return p+this.readInt32(p)},g.ByteBuffer.prototype.__vector=function(p){return p+this.readInt32(p)+g.SIZEOF_INT},g.ByteBuffer.prototype.__vector_len=function(p){return this.readInt32(p+this.readInt32(p))},g.ByteBuffer.prototype.__has_identifier=function(p){if(p.length!=g.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+g.FILE_IDENTIFIER_LENGTH);for(var m=0;m<g.FILE_IDENTIFIER_LENGTH;m++)if(p.charCodeAt(m)!=this.readInt8(this.position_+g.SIZEOF_INT+m))return!1;return!0},g.ByteBuffer.prototype.createLong=function(p,m){return g.Long.create(p,m)}}},__webpack_module_cache__={};function __webpack_require__(v){var u=__webpack_module_cache__[v];if(u!==void 0)return u.exports;var b=__webpack_module_cache__[v]={exports:{}};return __webpack_modules__[v].call(b.exports,b,b.exports,__webpack_require__),b.exports}__webpack_require__.n=v=>{var u=v&&v.__esModule?()=>v.default:()=>v;return __webpack_require__.d(u,{a:u}),u},__webpack_require__.d=(v,u)=>{for(var b in u)__webpack_require__.o(u,b)&&!__webpack_require__.o(v,b)&&Object.defineProperty(v,b,{enumerable:!0,get:u[b]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(v,u)=>Object.prototype.hasOwnProperty.call(v,u),__webpack_require__.r=v=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(v,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(v,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports;const categories=["abandoned","abstract","adult","adventure","aerial","aerial view","aerospace industry","africa","agricultural field","agriculture","air show","air vehicle","aircraft wing","airplane","airport","airshow","alone","alpha","alpine","alps","ancient","animal","antique","architectural column","architectural dome","architecture","arid climate","art","asia","asian","astronomy","athlete","aurora borealis","aurora polaris","autumn","aviation","background","backgrounds","balance","ballet","balloon","bathroom","beach","beautiful","beauty","bedroom","bee","beetle","bicycle","big cat","bikini","bird","bird of prey","birds","black","black and white","black color","blackandwhite","blonde","blossom","blue","blue hour","blurred motion","bnw","boat","body","bokeh","bonding","botany","boudoir","boy","boys","bra","bright","brown","brunette","building","building exterior","built structure","bumper","bus","business","cable car","candid","canine","canon","canyon","car","car show","care","carefree","cargo container","castle","casual clothing","cathedral","catholicism","caucasian","celebration","chair","cheerful","child","christianity","chrome","church","city","city life","cityscape","classic","cliff","close up","closeup","clothing","cloud","clouds","cloudscape","coast","coastline","collector's car","color","colorful","colors","comfortable","commercial dock","commuter","composition","concept","confidence","connection","constellation","construction industry","container","container ship","convertible","cool attitude","couple","cozy","creative","culture","cultures","curtain","curve","cut out","cute","cycling","daisy","dancing","danger","daniel laan","dark","dawn","day","daylight","decoration","deer","desert","design","desire","destination","deutschland","diminishing perspective","direction","dog","dolomites","domestic bathroom","domestic cat","domestic life","domestic room","door","downtown district","dragonfly","dramatic","dramatic sky","dress","drink","driving","drone","drop","dusk","electric guitar","elegance","embracing","engine","enjoyment","environment","epic","erotic","europe","evening","evening gown","event","exercising","exhibition","exploration","eyes","facade","face","fall","family","famous place","fantasy","farm","fashion","fashionable","feather","feline","female","femininity","fender","field","fighter plane","film","fitness","five people","flexibility","flight","flower","flower head","flowering plant","flowers","flowing","flowing water","flying","focus on foreground","fog","food","food and drink","forest","formalwear","fort","four people","fragility","france","freedom","freight transportation","french culture","fresh","freshness","friendship","front view","fruit","fuel and power generation","fujifilm","full length","fun","fungus","galaxy","garden","geology","germany","girl","girls","glacier","glamour","glendor","glowing","gothic style","grace","grass","green","green color","growth","guitar","hair","handsome","handsome people","happiness","happy","harbor","hat","headlight","headshot","healthy","healthy lifestyle","heron","high angle view","high heels","hiking","hill","history","holiday","home","horizon","horizon over water","horse","house","human","ice","iceland","idyllic","illuminated","illustration","image focus technique","in bloom","individuality","indoor","indoors","industry","inflorescence","innocence","insect","invertebrate","islam","island","italian","italian culture","italy","japan","jeans","journey","joy","laanscapes","lake","land","land vehicle","landmark","landscape","large","leaf","legs","leisure activity","lepidoptera","life","lifestyle","lifestyles","light","lighthouse","lighting equipment","lights","lingerie","locomotive","long exposure","looking","looking at camera","love","low angle view","lush foliage","luxury","lying down","macro","majestic","male","malemodel","mammal","man","mature men","mature women","meadow","medieval","medium group of people","metal","mid adult men","mid adult women","midsection","military","military airplane","milky way","minimal","mist","mode of transport","model","modern","monochrome","monument","mood","moody","moon","moored","morning","moss","motion","motor vehicle","motorcycle","mountain","multi colored","museum","mushroom","music","musical instrument","naked","natural","natural light","nature","nautical vessel","nebula","new","night","nightscape","no people","northern lights","norway","nostalgia","nude","nyc","obsolete","ocean","office building exterior","old","on the move","one","one adult only","one person","orange","orange color","outdoor","outdoors","outer space","owl","palace","panorama","panoramic","panties","paris","park","passenger craft","passion","pattern","peak","people","perching","performance","person","petal","pets","photo","pier","pink","pink color","place of worship","plane","planespotter","planespotting","plant","plant stem","playing","plucking an instrument","poland","pollen","pollination","portrait","posing","pretty","propeller","protection","public park","public transportation","purebred dog","purple","rail transportation","railroad station","railroad station platform","railroad track","rain","real","rear view","red","reflection","reflections","relaxation","religion","remote location","residential building","residential district","restaurant","resting","retail","retro","retro style","riding","river","road","rock","rock formation","rock music","rocks","romance","romantic","rooftop","rural scene","rusty","sail","sailboat","sailing","sand","sand dune","scenery","scenic","scenics","science","sea","sea bird","seascape","season","seduction","seductive women","selective focus","senior men","sensual","sensuality","serious","sexy","shadow","shadows","shiny","ship","shipping","shopping","shore","silhouette","single flower","sitting","skin","sky","skyscraper","small","smile","smiling","snow","sofa","songbird","space and astronomy","spain","speed","spirituality","splashing","sport","sports car","sports clothing","sports training","spotter","spread wings","spring","springtime","staircase","stairs","stamen","standing","star field","stars","station","stationary","steam","steam train","stockings","stone material","store","storm","street","strength","stretching","string instrument","striped","studio","studio shot","style","suit","summer","sun","sunglasses","sunlight","sunny","sunrise","sunset","swimming","swimming pool","swimwear","switzerland","technology","teenage boys","teenage girls","texture","the way forward","three people","tits","toadstool","together","togetherness","tokyo","top","topless","tourism","tower","town","tradition","traditional","traffic","train","tranquil","transportation","travel","travel destinations","tree","tree trunk","trees","trip","tropical","tropical climate","twilight","two","two people","umbrella","uncultivated","undersea","underwater","underwear","urban","urban skyline","usa","vacation","vacations","valley","view","village","vintage","vintage car","vitality","vulnerability","waist up","walking","wall","wallpaper","warm","warm clothing","water","water bird","waterfall","waterfront","waves","weather","wedding","wedding dress","wellbeing","wet","wheel","white","white background","white color","wild","wilderness","wildlife","wind","window","winter","woman","women","woodland","woods","yacht","yellow","yoga","young"],_imports_0="/nuculabs-logo.png",Home_vue_vue_type_style_index_0_lang="",_export_sfc=(v,u)=>{const b=v.__vccOpts||v;for(const[g,p]of u)b[g]=p;return b},VChip$1="",makeTransitionProps$1=propsFactory({disabled:Boolean,group:Boolean,hideOnLeave:Boolean,leaveAbsolute:Boolean,mode:String,origin:String},"transition");function createCssTransition(v,u,b){return genericComponent()({name:v,props:makeTransitionProps$1({mode:b,origin:u}),setup(g,p){let{slots:m}=p;const s={onBeforeEnter(l){g.origin&&(l.style.transformOrigin=g.origin)},onLeave(l){if(g.leaveAbsolute){const{offsetTop:d,offsetLeft:a,offsetWidth:o,offsetHeight:t}=l;l._transitionInitialStyles={position:l.style.position,top:l.style.top,left:l.style.left,width:l.style.width,height:l.style.height},l.style.position="absolute",l.style.top=`${d}px`,l.style.left=`${a}px`,l.style.width=`${o}px`,l.style.height=`${t}px`}g.hideOnLeave&&l.style.setProperty("display","none","important")},onAfterLeave(l){if(g.leaveAbsolute&&(l!=null&&l._transitionInitialStyles)){const{position:d,top:a,left:o,width:t,height:e}=l._transitionInitialStyles;delete l._transitionInitialStyles,l.style.position=d||"",l.style.top=a||"",l.style.left=o||"",l.style.width=t||"",l.style.height=e||""}}};return()=>{const l=g.group?TransitionGroup:Transition;return h(l,{name:g.disabled?"":v,css:!g.disabled,...g.group?void 0:{mode:g.mode},...g.disabled?{}:s},m.default)}}})}function createJavascriptTransition(v,u){let b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:"in-out";return genericComponent()({name:v,props:{mode:{type:String,default:b},disabled:Boolean},setup(g,p){let{slots:m}=p;return()=>h(Transition,{name:g.disabled?"":v,css:!g.disabled,...g.disabled?{}:u},m.default)}})}function ExpandTransitionGenerator(){let v=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";const b=(arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1)?"width":"height",g=camelize(`offset-${b}`);return{onBeforeEnter(s){s._parent=s.parentNode,s._initialStyle={transition:s.style.transition,overflow:s.style.overflow,[b]:s.style[b]}},onEnter(s){const l=s._initialStyle;s.style.setProperty("transition","none","important"),s.style.overflow="hidden";const d=`${s[g]}px`;s.style[b]="0",s.offsetHeight,s.style.transition=l.transition,v&&s._parent&&s._parent.classList.add(v),requestAnimationFrame(()=>{s.style[b]=d})},onAfterEnter:m,onEnterCancelled:m,onLeave(s){s._initialStyle={transition:"",overflow:s.style.overflow,[b]:s.style[b]},s.style.overflow="hidden",s.style[b]=`${s[g]}px`,s.offsetHeight,requestAnimationFrame(()=>s.style[b]="0")},onAfterLeave:p,onLeaveCancelled:p};function p(s){v&&s._parent&&s._parent.classList.remove(v),m(s)}function m(s){const l=s._initialStyle[b];s.style.overflow=s._initialStyle.overflow,l!=null&&(s.style[b]=l),delete s._initialStyle}}createCssTransition("fab-transition","center center","out-in");createCssTransition("dialog-bottom-transition");createCssTransition("dialog-top-transition");createCssTransition("fade-transition");createCssTransition("scale-transition");createCssTransition("scroll-x-transition");createCssTransition("scroll-x-reverse-transition");createCssTransition("scroll-y-transition");createCssTransition("scroll-y-reverse-transition");createCssTransition("slide-x-transition");createCssTransition("slide-x-reverse-transition");const VSlideYTransition=createCssTransition("slide-y-transition");createCssTransition("slide-y-reverse-transition");createJavascriptTransition("expand-transition",ExpandTransitionGenerator());const VExpandXTransition=createJavascriptTransition("expand-x-transition",ExpandTransitionGenerator("",!0)),VAvatar$1="",VIcon$1="";function useColor(v){return destructComputed(()=>{const u=[],b={};return v.value.background&&(isCssColor(v.value.background)?b.backgroundColor=v.value.background:u.push(`bg-${v.value.background}`)),v.value.text&&(isCssColor(v.value.text)?(b.color=v.value.text,b.caretColor=v.value.text):u.push(`text-${v.value.text}`)),{colorClasses:u,colorStyles:b}})}function useTextColor(v,u){const b=computed(()=>({text:isRef(v)?v.value:u?v[u]:null})),{colorClasses:g,colorStyles:p}=useColor(b);return{textColorClasses:g,textColorStyles:p}}function useBackgroundColor(v,u){const b=computed(()=>({background:isRef(v)?v.value:u?v[u]:null})),{colorClasses:g,colorStyles:p}=useColor(b);return{backgroundColorClasses:g,backgroundColorStyles:p}}const predefinedSizes=["x-small","small","default","large","x-large"],makeSizeProps=propsFactory({size:{type:[String,Number],default:"default"}},"size");function useSize(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();return destructComputed(()=>{let b,g;return includes(predefinedSizes,v.size)?b=`${u}--size-${v.size}`:v.size&&(g={width:convertToUnit(v.size),height:convertToUnit(v.size)}),{sizeClasses:b,sizeStyles:g}})}const makeVIconProps=propsFactory({color:String,start:Boolean,end:Boolean,icon:IconValue,...makeComponentProps(),...makeSizeProps(),...makeTagProps({tag:"i"}),...makeThemeProps()},"VIcon"),VIcon=genericComponent()({name:"VIcon",props:makeVIconProps(),setup(v,u){let{attrs:b,slots:g}=u;const p=ref(),{themeClasses:m}=provideTheme(v),{iconData:s}=useIcon(computed(()=>p.value||v.icon)),{sizeClasses:l}=useSize(v),{textColorClasses:d,textColorStyles:a}=useTextColor(toRef(v,"color"));return useRender(()=>{var t,e;const o=(t=g.default)==null?void 0:t.call(g);return o&&(p.value=(e=flattenFragments(o).filter(n=>n.type===Text&&n.children&&typeof n.children=="string")[0])==null?void 0:e.children),createVNode(s.value.component,{tag:v.tag,icon:s.value.icon,class:["v-icon","notranslate",m.value,l.value,d.value,{"v-icon--clickable":!!b.onClick,"v-icon--start":v.start,"v-icon--end":v.end},v.class],style:[l.value?void 0:{fontSize:convertToUnit(v.size),height:convertToUnit(v.size),width:convertToUnit(v.size)},a.value,v.style],role:b.onClick?"button":void 0,"aria-hidden":!b.onClick},{default:()=>[o]})}),{}}}),VImg$1="",VResponsive$1="",makeDimensionProps=propsFactory({height:[Number,String],maxHeight:[Number,String],maxWidth:[Number,String],minHeight:[Number,String],minWidth:[Number,String],width:[Number,String]},"dimension");function useDimension(v){return{dimensionStyles:computed(()=>({height:convertToUnit(v.height),maxHeight:convertToUnit(v.maxHeight),maxWidth:convertToUnit(v.maxWidth),minHeight:convertToUnit(v.minHeight),minWidth:convertToUnit(v.minWidth),width:convertToUnit(v.width)}))}}function useAspectStyles(v){return{aspectStyles:computed(()=>{const u=Number(v.aspectRatio);return u?{paddingBottom:String(1/u*100)+"%"}:void 0})}}const makeVResponsiveProps=propsFactory({aspectRatio:[String,Number],contentClass:String,inline:Boolean,...makeComponentProps(),...makeDimensionProps()},"VResponsive"),VResponsive=genericComponent()({name:"VResponsive",props:makeVResponsiveProps(),setup(v,u){let{slots:b}=u;const{aspectStyles:g}=useAspectStyles(v),{dimensionStyles:p}=useDimension(v);return useRender(()=>{var m;return createVNode("div",{class:["v-responsive",{"v-responsive--inline":v.inline},v.class],style:[p.value,v.style]},[createVNode("div",{class:"v-responsive__sizer",style:g.value},null),(m=b.additional)==null?void 0:m.call(b),b.default&&createVNode("div",{class:["v-responsive__content",v.contentClass]},[b.default()])])}),{}}}),makeTransitionProps=propsFactory({transition:{type:[Boolean,String,Object],default:"fade-transition",validator:v=>v!==!0}},"transition"),MaybeTransition=(v,u)=>{let{slots:b}=u;const{transition:g,disabled:p,...m}=v,{component:s=Transition,...l}=typeof g=="object"?g:{};return h(s,mergeProps(typeof g=="string"?{name:p?"":g}:l,m,{disabled:p}),b)};function mounted$1(v,u){if(!SUPPORTS_INTERSECTION)return;const b=u.modifiers||{},g=u.value,{handler:p,options:m}=typeof g=="object"?g:{handler:g,options:{}},s=new IntersectionObserver(function(){var t;let l=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],d=arguments.length>1?arguments[1]:void 0;const a=(t=v._observe)==null?void 0:t[u.instance.$.uid];if(!a)return;const o=l.some(e=>e.isIntersecting);p&&(!b.quiet||a.init)&&(!b.once||o||a.init)&&p(o,l,d),o&&b.once?unmounted$1(v,u):a.init=!0},m);v._observe=Object(v._observe),v._observe[u.instance.$.uid]={init:!1,observer:s},s.observe(v)}function unmounted$1(v,u){var g;const b=(g=v._observe)==null?void 0:g[u.instance.$.uid];b&&(b.observer.unobserve(v),delete v._observe[u.instance.$.uid])}const Intersect={mounted:mounted$1,unmounted:unmounted$1},intersect=Intersect,makeVImgProps=propsFactory({alt:String,cover:Boolean,eager:Boolean,gradient:String,lazySrc:String,options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},sizes:String,src:{type:[String,Object],default:""},srcset:String,...makeVResponsiveProps(),...makeComponentProps(),...makeTransitionProps()},"VImg"),VImg=genericComponent()({name:"VImg",directives:{intersect},props:makeVImgProps(),emits:{loadstart:v=>!0,load:v=>!0,error:v=>!0},setup(v,u){let{emit:b,slots:g}=u;const p=shallowRef(""),m=ref(),s=shallowRef(v.eager?"loading":"idle"),l=shallowRef(),d=shallowRef(),a=computed(()=>v.src&&typeof v.src=="object"?{src:v.src.src,srcset:v.srcset||v.src.srcset,lazySrc:v.lazySrc||v.src.lazySrc,aspect:Number(v.aspectRatio||v.src.aspect||0)}:{src:v.src,srcset:v.srcset,lazySrc:v.lazySrc,aspect:Number(v.aspectRatio||0)}),o=computed(()=>a.value.aspect||l.value/d.value||0);watch(()=>v.src,()=>{t(s.value!=="idle")}),watch(o,(O,T)=>{!O&&T&&m.value&&c(m.value)}),onBeforeMount(()=>t());function t(O){if(!(v.eager&&O)&&!(SUPPORTS_INTERSECTION&&!O&&!v.eager)){if(s.value="loading",a.value.lazySrc){const T=new Image;T.src=a.value.lazySrc,c(T,null)}a.value.src&&nextTick(()=>{var T,A;if(b("loadstart",((T=m.value)==null?void 0:T.currentSrc)||a.value.src),(A=m.value)!=null&&A.complete){if(m.value.naturalWidth||n(),s.value==="error")return;o.value||c(m.value,null),e()}else o.value||c(m.value),r()})}}function e(){var O;r(),s.value="loaded",b("load",((O=m.value)==null?void 0:O.currentSrc)||a.value.src)}function n(){var O;s.value="error",b("error",((O=m.value)==null?void 0:O.currentSrc)||a.value.src)}function r(){const O=m.value;O&&(p.value=O.currentSrc||O.src)}let i=-1;function c(O){let T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:100;const A=()=>{clearTimeout(i);const{naturalHeight:P,naturalWidth:R}=O;P||R?(l.value=R,d.value=P):!O.complete&&s.value==="loading"&&T!=null?i=window.setTimeout(A,T):(O.currentSrc.endsWith(".svg")||O.currentSrc.startsWith("data:image/svg+xml"))&&(l.value=1,d.value=1)};A()}const f=computed(()=>({"v-img__img--cover":v.cover,"v-img__img--contain":!v.cover})),y=()=>{var A;if(!a.value.src||s.value==="idle")return null;const O=createVNode("img",{class:["v-img__img",f.value],src:a.value.src,srcset:a.value.srcset,alt:v.alt,sizes:v.sizes,ref:m,onLoad:e,onError:n},null),T=(A=g.sources)==null?void 0:A.call(g);return createVNode(MaybeTransition,{transition:v.transition,appear:!0},{default:()=>[withDirectives(T?createVNode("picture",{class:"v-img__picture"},[T,O]):O,[[vShow,s.value==="loaded"]])]})},w=()=>createVNode(MaybeTransition,{transition:v.transition},{default:()=>[a.value.lazySrc&&s.value!=="loaded"&&createVNode("img",{class:["v-img__img","v-img__img--preload",f.value],src:a.value.lazySrc,alt:v.alt},null)]}),x=()=>g.placeholder?createVNode(MaybeTransition,{transition:v.transition,appear:!0},{default:()=>[(s.value==="loading"||s.value==="error"&&!g.error)&&createVNode("div",{class:"v-img__placeholder"},[g.placeholder()])]}):null,_=()=>g.error?createVNode(MaybeTransition,{transition:v.transition,appear:!0},{default:()=>[s.value==="error"&&createVNode("div",{class:"v-img__error"},[g.error()])]}):null,S=()=>v.gradient?createVNode("div",{class:"v-img__gradient",style:{backgroundImage:`linear-gradient(${v.gradient})`}},null):null,I=shallowRef(!1);{const O=watch(o,T=>{T&&(requestAnimationFrame(()=>{requestAnimationFrame(()=>{I.value=!0})}),O())})}return useRender(()=>{const[O]=VResponsive.filterProps(v);return withDirectives(createVNode(VResponsive,mergeProps({class:["v-img",{"v-img--booting":!I.value},v.class],style:v.style},O,{aspectRatio:o.value,"aria-label":v.alt,role:v.alt?"img":void 0}),{additional:()=>createVNode(Fragment,null,[createVNode(y,null,null),createVNode(w,null,null),createVNode(S,null,null),createVNode(x,null,null),createVNode(_,null,null)]),default:g.default}),[[resolveDirective("intersect"),{handler:t,options:v.options},null,{once:!0}]])}),{currentSrc:p,image:m,state:s,naturalWidth:l,naturalHeight:d}}}),allowedDensities=[null,"default","comfortable","compact"],makeDensityProps=propsFactory({density:{type:String,default:"default",validator:v=>allowedDensities.includes(v)}},"density");function useDensity(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();return{densityClasses:computed(()=>`${u}--density-${v.density}`)}}const makeRoundedProps=propsFactory({rounded:{type:[Boolean,Number,String],default:void 0}},"rounded");function useRounded(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();return{roundedClasses:computed(()=>{const g=isRef(v)?v.value:v.rounded,p=[];if(g===!0||g==="")p.push(`${u}--rounded`);else if(typeof g=="string"||g===0)for(const m of String(g).split(" "))p.push(`rounded-${m}`);return p})}}const allowedVariants$1=["elevated","flat","tonal","outlined","text","plain"];function genOverlays(v,u){return createVNode(Fragment,null,[v&&createVNode("span",{key:"overlay",class:`${u}__overlay`},null),createVNode("span",{key:"underlay",class:`${u}__underlay`},null)])}const makeVariantProps=propsFactory({color:String,variant:{type:String,default:"elevated",validator:v=>allowedVariants$1.includes(v)}},"variant");function useVariant(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();const b=computed(()=>{const{variant:m}=unref(v);return`${u}--variant-${m}`}),{colorClasses:g,colorStyles:p}=useColor(computed(()=>{const{variant:m,color:s}=unref(v);return{[["elevated","flat"].includes(m)?"background":"text"]:s}}));return{colorClasses:g,colorStyles:p,variantClasses:b}}const makeVAvatarProps=propsFactory({start:Boolean,end:Boolean,icon:IconValue,image:String,...makeComponentProps(),...makeDensityProps(),...makeRoundedProps(),...makeSizeProps(),...makeTagProps(),...makeThemeProps(),...makeVariantProps({variant:"flat"})},"VAvatar"),VAvatar=genericComponent()({name:"VAvatar",props:makeVAvatarProps(),setup(v,u){let{slots:b}=u;const{themeClasses:g}=provideTheme(v),{colorClasses:p,colorStyles:m,variantClasses:s}=useVariant(v),{densityClasses:l}=useDensity(v),{roundedClasses:d}=useRounded(v),{sizeClasses:a,sizeStyles:o}=useSize(v);return useRender(()=>createVNode(v.tag,{class:["v-avatar",{"v-avatar--start":v.start,"v-avatar--end":v.end},g.value,p.value,l.value,d.value,a.value,s.value,v.class],style:[m.value,o.value,v.style]},{default:()=>{var t;return[v.image?createVNode(VImg,{key:"image",src:v.image,alt:"",cover:!0},null):v.icon?createVNode(VIcon,{key:"icon",icon:v.icon},null):(t=b.default)==null?void 0:t.call(b),genOverlays(!1,"v-avatar")]}})),{}}}),VChipGroup="",makeGroupProps=propsFactory({modelValue:{type:null,default:void 0},multiple:Boolean,mandatory:[Boolean,String],max:Number,selectedClass:String,disabled:Boolean},"group"),makeGroupItemProps=propsFactory({value:null,disabled:Boolean,selectedClass:String},"group-item");function useGroupItem(v,u){let b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;const g=getCurrentInstance("useGroupItem");if(!g)throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");const p=getUid();provide(Symbol.for(`${u.description}:id`),p);const m=inject(u,null);if(!m){if(!b)return m;throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${u.description}`)}const s=toRef(v,"value"),l=computed(()=>m.disabled.value||v.disabled);m.register({id:p,value:s,disabled:l},g),onBeforeUnmount(()=>{m.unregister(p)});const d=computed(()=>m.isSelected(p)),a=computed(()=>d.value&&[m.selectedClass.value,v.selectedClass]);return watch(d,o=>{g.emit("group:selected",{value:o})}),{id:p,isSelected:d,toggle:()=>m.select(p,!d.value),select:o=>m.select(p,o),selectedClass:a,value:s,disabled:l,group:m}}function useGroup(v,u){let b=!1;const g=reactive([]),p=useProxiedModel(v,"modelValue",[],e=>e==null?[]:getIds(g,wrapInArray(e)),e=>{const n=getValues(g,e);return v.multiple?n:n[0]}),m=getCurrentInstance("useGroup");function s(e,n){const r=e,i=Symbol.for(`${u.description}:id`),f=findChildrenWithProvide(i,m==null?void 0:m.vnode).indexOf(n);f>-1?g.splice(f,0,r):g.push(r)}function l(e){if(b)return;d();const n=g.findIndex(r=>r.id===e);g.splice(n,1)}function d(){const e=g.find(n=>!n.disabled);e&&v.mandatory==="force"&&!p.value.length&&(p.value=[e.id])}onMounted(()=>{d()}),onBeforeUnmount(()=>{b=!0});function a(e,n){const r=g.find(i=>i.id===e);if(!(n&&(r!=null&&r.disabled)))if(v.multiple){const i=p.value.slice(),c=i.findIndex(y=>y===e),f=~c;if(n=n??!f,f&&v.mandatory&&i.length<=1||!f&&v.max!=null&&i.length+1>v.max)return;c<0&&n?i.push(e):c>=0&&!n&&i.splice(c,1),p.value=i}else{const i=p.value.includes(e);if(v.mandatory&&i)return;p.value=n??!i?[e]:[]}}function o(e){if(v.multiple,p.value.length){const n=p.value[0],r=g.findIndex(f=>f.id===n);let i=(r+e)%g.length,c=g[i];for(;c.disabled&&i!==r;)i=(i+e)%g.length,c=g[i];if(c.disabled)return;p.value=[g[i].id]}else{const n=g.find(r=>!r.disabled);n&&(p.value=[n.id])}}const t={register:s,unregister:l,selected:p,select:a,disabled:toRef(v,"disabled"),prev:()=>o(g.length-1),next:()=>o(1),isSelected:e=>p.value.includes(e),selectedClass:computed(()=>v.selectedClass),items:computed(()=>g),getItemIndex:e=>getItemIndex(g,e)};return provide(u,t),t}function getItemIndex(v,u){const b=getIds(v,[u]);return b.length?v.findIndex(g=>g.id===b[0]):-1}function getIds(v,u){const b=[];return u.forEach(g=>{const p=v.find(s=>deepEqual(g,s.value)),m=v[g];(p==null?void 0:p.value)!=null?b.push(p.id):m!=null&&b.push(m.id)}),b}function getValues(v,u){const b=[];return u.forEach(g=>{const p=v.findIndex(m=>m.id===g);if(~p){const m=v[p];b.push(m.value!=null?m.value:p)}}),b}const VChipGroupSymbol=Symbol.for("vuetify:v-chip-group"),makeVChipGroupProps=propsFactory({column:Boolean,filter:Boolean,valueComparator:{type:Function,default:deepEqual},...makeComponentProps(),...makeGroupProps({selectedClass:"v-chip--selected"}),...makeTagProps(),...makeThemeProps(),...makeVariantProps({variant:"tonal"})},"VChipGroup");genericComponent()({name:"VChipGroup",props:makeVChipGroupProps(),emits:{"update:modelValue":v=>!0},setup(v,u){let{slots:b}=u;const{themeClasses:g}=provideTheme(v),{isSelected:p,select:m,next:s,prev:l,selected:d}=useGroup(v,VChipGroupSymbol);return provideDefaults({VChip:{color:toRef(v,"color"),disabled:toRef(v,"disabled"),filter:toRef(v,"filter"),variant:toRef(v,"variant")}}),useRender(()=>createVNode(v.tag,{class:["v-chip-group",{"v-chip-group--column":v.column},g.value,v.class],style:v.style},{default:()=>{var a;return[(a=b.default)==null?void 0:a.call(b,{isSelected:p,select:m,next:s,prev:l,selected:d.value})]}})),{}}});const makeVDefaultsProviderProps=propsFactory({defaults:Object,disabled:Boolean,reset:[Number,String],root:[Boolean,String],scoped:Boolean},"VDefaultsProvider"),VDefaultsProvider=genericComponent(!1)({name:"VDefaultsProvider",props:makeVDefaultsProviderProps(),setup(v,u){let{slots:b}=u;const{defaults:g,disabled:p,reset:m,root:s,scoped:l}=toRefs(v);return provideDefaults(g,{reset:m,root:s,scoped:l,disabled:p}),()=>{var d;return(d=b.default)==null?void 0:d.call(b)}}}),makeBorderProps=propsFactory({border:[Boolean,Number,String]},"border");function useBorder(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();return{borderClasses:computed(()=>{const g=isRef(v)?v.value:v.border,p=[];if(g===!0||g==="")p.push(`${u}--border`);else if(typeof g=="string"||g===0)for(const m of String(g).split(" "))p.push(`border-${m}`);return p})}}const makeElevationProps=propsFactory({elevation:{type:[Number,String],validator(v){const u=parseInt(v);return!isNaN(u)&&u>=0&&u<=24}}},"elevation");function useElevation(v){return{elevationClasses:computed(()=>{const b=isRef(v)?v.value:v.elevation,g=[];return b==null||g.push(`elevation-${b}`),g})}}function useLink(v,u){const b=resolveDynamicComponent("RouterLink"),g=computed(()=>!!(v.href||v.to)),p=computed(()=>(g==null?void 0:g.value)||hasEvent(u,"click")||hasEvent(v,"click"));if(typeof b=="string")return{isLink:g,isClickable:p,href:toRef(v,"href")};const m=v.to?b.useLink(v):void 0;return{isLink:g,isClickable:p,route:m==null?void 0:m.route,navigate:m==null?void 0:m.navigate,isActive:m&&computed(()=>{var s,l;return v.exact?(s=m.isExactActive)==null?void 0:s.value:(l=m.isActive)==null?void 0:l.value}),href:computed(()=>v.to?m==null?void 0:m.route.value.href:v.href)}}const makeRouterProps=propsFactory({href:String,replace:Boolean,to:[String,Object],exact:Boolean},"router"),VRipple="",stopSymbol=Symbol("rippleStop"),DELAY_RIPPLE=80;function transform(v,u){v.style.transform=u,v.style.webkitTransform=u}function isTouchEvent(v){return v.constructor.name==="TouchEvent"}function isKeyboardEvent(v){return v.constructor.name==="KeyboardEvent"}const calculate=function(v,u){var t;let b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},g=0,p=0;if(!isKeyboardEvent(v)){const e=u.getBoundingClientRect(),n=isTouchEvent(v)?v.touches[v.touches.length-1]:v;g=n.clientX-e.left,p=n.clientY-e.top}let m=0,s=.3;(t=u._ripple)!=null&&t.circle?(s=.15,m=u.clientWidth/2,m=b.center?m:m+Math.sqrt((g-m)**2+(p-m)**2)/4):m=Math.sqrt(u.clientWidth**2+u.clientHeight**2)/2;const l=`${(u.clientWidth-m*2)/2}px`,d=`${(u.clientHeight-m*2)/2}px`,a=b.center?l:`${g-m}px`,o=b.center?d:`${p-m}px`;return{radius:m,scale:s,x:a,y:o,centerX:l,centerY:d}},ripples={show(v,u){var n;let b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};if(!((n=u==null?void 0:u._ripple)!=null&&n.enabled))return;const g=document.createElement("span"),p=document.createElement("span");g.appendChild(p),g.className="v-ripple__container",b.class&&(g.className+=` ${b.class}`);const{radius:m,scale:s,x:l,y:d,centerX:a,centerY:o}=calculate(v,u,b),t=`${m*2}px`;p.className="v-ripple__animation",p.style.width=t,p.style.height=t,u.appendChild(g);const e=window.getComputedStyle(u);e&&e.position==="static"&&(u.style.position="relative",u.dataset.previousPosition="static"),p.classList.add("v-ripple__animation--enter"),p.classList.add("v-ripple__animation--visible"),transform(p,`translate(${l}, ${d}) scale3d(${s},${s},${s})`),p.dataset.activated=String(performance.now()),setTimeout(()=>{p.classList.remove("v-ripple__animation--enter"),p.classList.add("v-ripple__animation--in"),transform(p,`translate(${a}, ${o}) scale3d(1,1,1)`)},0)},hide(v){var m;if(!((m=v==null?void 0:v._ripple)!=null&&m.enabled))return;const u=v.getElementsByClassName("v-ripple__animation");if(u.length===0)return;const b=u[u.length-1];if(b.dataset.isHiding)return;b.dataset.isHiding="true";const g=performance.now()-Number(b.dataset.activated),p=Math.max(250-g,0);setTimeout(()=>{b.classList.remove("v-ripple__animation--in"),b.classList.add("v-ripple__animation--out"),setTimeout(()=>{var l;v.getElementsByClassName("v-ripple__animation").length===1&&v.dataset.previousPosition&&(v.style.position=v.dataset.previousPosition,delete v.dataset.previousPosition),((l=b.parentNode)==null?void 0:l.parentNode)===v&&v.removeChild(b.parentNode)},300)},p)}};function isRippleEnabled(v){return typeof v>"u"||!!v}function rippleShow(v){const u={},b=v.currentTarget;if(!(!(b!=null&&b._ripple)||b._ripple.touched||v[stopSymbol])){if(v[stopSymbol]=!0,isTouchEvent(v))b._ripple.touched=!0,b._ripple.isTouch=!0;else if(b._ripple.isTouch)return;if(u.center=b._ripple.centered||isKeyboardEvent(v),b._ripple.class&&(u.class=b._ripple.class),isTouchEvent(v)){if(b._ripple.showTimerCommit)return;b._ripple.showTimerCommit=()=>{ripples.show(v,b,u)},b._ripple.showTimer=window.setTimeout(()=>{var g;(g=b==null?void 0:b._ripple)!=null&&g.showTimerCommit&&(b._ripple.showTimerCommit(),b._ripple.showTimerCommit=null)},DELAY_RIPPLE)}else ripples.show(v,b,u)}}function rippleStop(v){v[stopSymbol]=!0}function rippleHide(v){const u=v.currentTarget;if(u!=null&&u._ripple){if(window.clearTimeout(u._ripple.showTimer),v.type==="touchend"&&u._ripple.showTimerCommit){u._ripple.showTimerCommit(),u._ripple.showTimerCommit=null,u._ripple.showTimer=window.setTimeout(()=>{rippleHide(v)});return}window.setTimeout(()=>{u._ripple&&(u._ripple.touched=!1)}),ripples.hide(u)}}function rippleCancelShow(v){const u=v.currentTarget;u!=null&&u._ripple&&(u._ripple.showTimerCommit&&(u._ripple.showTimerCommit=null),window.clearTimeout(u._ripple.showTimer))}let keyboardRipple=!1;function keyboardRippleShow(v){!keyboardRipple&&(v.keyCode===keyCodes.enter||v.keyCode===keyCodes.space)&&(keyboardRipple=!0,rippleShow(v))}function keyboardRippleHide(v){keyboardRipple=!1,rippleHide(v)}function focusRippleHide(v){keyboardRipple&&(keyboardRipple=!1,rippleHide(v))}function updateRipple(v,u,b){const{value:g,modifiers:p}=u,m=isRippleEnabled(g);if(m||ripples.hide(v),v._ripple=v._ripple??{},v._ripple.enabled=m,v._ripple.centered=p.center,v._ripple.circle=p.circle,isObject(g)&&g.class&&(v._ripple.class=g.class),m&&!b){if(p.stop){v.addEventListener("touchstart",rippleStop,{passive:!0}),v.addEventListener("mousedown",rippleStop);return}v.addEventListener("touchstart",rippleShow,{passive:!0}),v.addEventListener("touchend",rippleHide,{passive:!0}),v.addEventListener("touchmove",rippleCancelShow,{passive:!0}),v.addEventListener("touchcancel",rippleHide),v.addEventListener("mousedown",rippleShow),v.addEventListener("mouseup",rippleHide),v.addEventListener("mouseleave",rippleHide),v.addEventListener("keydown",keyboardRippleShow),v.addEventListener("keyup",keyboardRippleHide),v.addEventListener("blur",focusRippleHide),v.addEventListener("dragstart",rippleHide,{passive:!0})}else!m&&b&&removeListeners(v)}function removeListeners(v){v.removeEventListener("mousedown",rippleShow),v.removeEventListener("touchstart",rippleShow),v.removeEventListener("touchend",rippleHide),v.removeEventListener("touchmove",rippleCancelShow),v.removeEventListener("touchcancel",rippleHide),v.removeEventListener("mouseup",rippleHide),v.removeEventListener("mouseleave",rippleHide),v.removeEventListener("keydown",keyboardRippleShow),v.removeEventListener("keyup",keyboardRippleHide),v.removeEventListener("dragstart",rippleHide),v.removeEventListener("blur",focusRippleHide)}function mounted(v,u){updateRipple(v,u,!1)}function unmounted(v){delete v._ripple,removeListeners(v)}function updated(v,u){if(u.value===u.oldValue)return;const b=isRippleEnabled(u.oldValue);updateRipple(v,u,b)}const Ripple={mounted,unmounted,updated},makeVChipProps=propsFactory({activeClass:String,appendAvatar:String,appendIcon:IconValue,closable:Boolean,closeIcon:{type:IconValue,default:"$delete"},closeLabel:{type:String,default:"$vuetify.close"},draggable:Boolean,filter:Boolean,filterIcon:{type:String,default:"$complete"},label:Boolean,link:{type:Boolean,default:void 0},pill:Boolean,prependAvatar:String,prependIcon:IconValue,ripple:{type:[Boolean,Object],default:!0},text:String,modelValue:{type:Boolean,default:!0},onClick:EventProp(),onClickOnce:EventProp(),...makeBorderProps(),...makeComponentProps(),...makeDensityProps(),...makeElevationProps(),...makeGroupItemProps(),...makeRoundedProps(),...makeRouterProps(),...makeSizeProps(),...makeTagProps({tag:"span"}),...makeThemeProps(),...makeVariantProps({variant:"tonal"})},"VChip"),VChip=genericComponent()({name:"VChip",directives:{Ripple},props:makeVChipProps(),emits:{"click:close":v=>!0,"update:modelValue":v=>!0,"group:selected":v=>!0,click:v=>!0},setup(v,u){let{attrs:b,emit:g,slots:p}=u;const{t:m}=useLocale(),{borderClasses:s}=useBorder(v),{colorClasses:l,colorStyles:d,variantClasses:a}=useVariant(v),{densityClasses:o}=useDensity(v),{elevationClasses:t}=useElevation(v),{roundedClasses:e}=useRounded(v),{sizeClasses:n}=useSize(v),{themeClasses:r}=provideTheme(v),i=useProxiedModel(v,"modelValue"),c=useGroupItem(v,VChipGroupSymbol,!1),f=useLink(v,b),y=computed(()=>v.link!==!1&&f.isLink.value),w=computed(()=>!v.disabled&&v.link!==!1&&(!!c||v.link||f.isClickable.value)),x=computed(()=>({"aria-label":m(v.closeLabel),onClick(I){i.value=!1,g("click:close",I)}}));function _(I){var O;g("click",I),w.value&&((O=f.navigate)==null||O.call(f,I),c==null||c.toggle())}function S(I){(I.key==="Enter"||I.key===" ")&&(I.preventDefault(),_(I))}return()=>{const I=f.isLink.value?"a":v.tag,O=!!(v.appendIcon||v.appendAvatar),T=!!(O||p.append),A=!!(p.close||v.closable),P=!!(p.filter||v.filter)&&c,R=!!(v.prependIcon||v.prependAvatar),D=!!(R||p.prepend),$=!c||c.isSelected.value;return i.value&&withDirectives(createVNode(I,{class:["v-chip",{"v-chip--disabled":v.disabled,"v-chip--label":v.label,"v-chip--link":w.value,"v-chip--filter":P,"v-chip--pill":v.pill},r.value,s.value,$?l.value:void 0,o.value,t.value,e.value,n.value,a.value,c==null?void 0:c.selectedClass.value,v.class],style:[$?d.value:void 0,v.style],disabled:v.disabled||void 0,draggable:v.draggable,href:f.href.value,tabindex:w.value?0:void 0,onClick:_,onKeydown:w.value&&!y.value&&S},{default:()=>{var M;return[genOverlays(w.value,"v-chip"),P&&createVNode(VExpandXTransition,{key:"filter"},{default:()=>[withDirectives(createVNode("div",{class:"v-chip__filter"},[p.filter?withDirectives(createVNode(VDefaultsProvider,{key:"filter-defaults",disabled:!v.filterIcon,defaults:{VIcon:{icon:v.filterIcon}}},null),[[resolveDirective("slot"),p.filter,"default"]]):createVNode(VIcon,{key:"filter-icon",icon:v.filterIcon},null)]),[[vShow,c.isSelected.value]])]}),D&&createVNode("div",{key:"prepend",class:"v-chip__prepend"},[p.prepend?createVNode(VDefaultsProvider,{key:"prepend-defaults",disabled:!R,defaults:{VAvatar:{image:v.prependAvatar,start:!0},VIcon:{icon:v.prependIcon,start:!0}}},p.prepend):createVNode(Fragment,null,[v.prependIcon&&createVNode(VIcon,{key:"prepend-icon",icon:v.prependIcon,start:!0},null),v.prependAvatar&&createVNode(VAvatar,{key:"prepend-avatar",image:v.prependAvatar,start:!0},null)])]),createVNode("div",{class:"v-chip__content"},[((M=p.default)==null?void 0:M.call(p,{isSelected:c==null?void 0:c.isSelected.value,selectedClass:c==null?void 0:c.selectedClass.value,select:c==null?void 0:c.select,toggle:c==null?void 0:c.toggle,value:c==null?void 0:c.value.value,disabled:v.disabled}))??v.text]),T&&createVNode("div",{key:"append",class:"v-chip__append"},[p.append?createVNode(VDefaultsProvider,{key:"append-defaults",disabled:!O,defaults:{VAvatar:{end:!0,image:v.appendAvatar},VIcon:{end:!0,icon:v.appendIcon}}},p.append):createVNode(Fragment,null,[v.appendIcon&&createVNode(VIcon,{key:"append-icon",end:!0,icon:v.appendIcon},null),v.appendAvatar&&createVNode(VAvatar,{key:"append-avatar",end:!0,image:v.appendAvatar},null)])]),A&&createVNode("div",mergeProps({key:"close",class:"v-chip__close"},x.value),[p.close?createVNode(VDefaultsProvider,{key:"close-defaults",defaults:{VIcon:{icon:v.closeIcon,size:"x-small"}}},p.close):createVNode(VIcon,{key:"close-icon",icon:v.closeIcon,size:"x-small"},null)])]}}),[[resolveDirective("ripple"),w.value&&v.ripple,null]])}}}),VFileInput$1="",VCounter$1="",makeVCounterProps=propsFactory({active:Boolean,max:[Number,String],value:{type:[Number,String],default:0},...makeComponentProps(),...makeTransitionProps({transition:{component:VSlideYTransition}})},"VCounter"),VCounter=genericComponent()({name:"VCounter",functional:!0,props:makeVCounterProps(),setup(v,u){let{slots:b}=u;const g=computed(()=>v.max?`${v.value} / ${v.max}`:String(v.value));return useRender(()=>createVNode(MaybeTransition,{transition:v.transition},{default:()=>[withDirectives(createVNode("div",{class:["v-counter",v.class],style:v.style},[b.default?b.default({counter:g.value,max:v.max,value:v.value}):g.value]),[[vShow,v.active]])]})),{}}}),VField$1="",VLabel$1="",makeVLabelProps=propsFactory({text:String,clickable:Boolean,...makeComponentProps(),...makeThemeProps()},"VLabel"),VLabel=genericComponent()({name:"VLabel",props:makeVLabelProps(),setup(v,u){let{slots:b}=u;return useRender(()=>{var g;return createVNode("label",{class:["v-label",{"v-label--clickable":v.clickable},v.class],style:v.style},[v.text,(g=b.default)==null?void 0:g.call(b)])}),{}}}),makeVFieldLabelProps=propsFactory({floating:Boolean,...makeComponentProps()},"VFieldLabel"),VFieldLabel=genericComponent()({name:"VFieldLabel",props:makeVFieldLabelProps(),setup(v,u){let{slots:b}=u;return useRender(()=>createVNode(VLabel,{class:["v-field-label",{"v-field-label--floating":v.floating},v.class],style:v.style,"aria-hidden":v.floating||void 0},b)),{}}});function useInputIcon(v){const{t:u}=useLocale();function b(g){let{name:p}=g;const m={prepend:"prependAction",prependInner:"prependAction",append:"appendAction",appendInner:"appendAction",clear:"clear"}[p],s=v[`onClick:${p}`],l=s&&m?u(`$vuetify.input.${m}`,v.label??""):void 0;return createVNode(VIcon,{icon:v[`${p}Icon`],"aria-label":l,onClick:s},null)}return{InputIcon:b}}const makeFocusProps=propsFactory({focused:Boolean,"onUpdate:focused":EventProp()},"focus");function useFocus(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();const b=useProxiedModel(v,"focused"),g=computed(()=>({[`${u}--focused`]:b.value}));function p(){b.value=!0}function m(){b.value=!1}return{focusClasses:g,isFocused:b,focus:p,blur:m}}const VProgressLinear$1="";function useIntersectionObserver(v,u){const b=ref(),g=shallowRef(!1);if(SUPPORTS_INTERSECTION){const p=new IntersectionObserver(m=>{v==null||v(m,p),g.value=!!m.find(s=>s.isIntersecting)},u);onBeforeUnmount(()=>{p.disconnect()}),watch(b,(m,s)=>{s&&(p.unobserve(s),g.value=!1),m&&p.observe(m)},{flush:"post"})}return{intersectionRef:b,isIntersecting:g}}const oppositeMap={center:"center",top:"bottom",bottom:"top",left:"right",right:"left"},makeLocationProps=propsFactory({location:String},"location");function useLocation(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,b=arguments.length>2?arguments[2]:void 0;const{isRtl:g}=useRtl();return{locationStyles:computed(()=>{if(!v.location)return{};const{side:m,align:s}=parseAnchor(v.location.split(" ").length>1?v.location:`${v.location} center`,g.value);function l(a){return b?b(a):0}const d={};return m!=="center"&&(u?d[oppositeMap[m]]=`calc(100% - ${l(m)}px)`:d[m]=0),s!=="center"?u?d[oppositeMap[s]]=`calc(100% - ${l(s)}px)`:d[s]=0:(m==="center"?d.top=d.left="50%":d[{top:"left",bottom:"left",left:"top",right:"top"}[m]]="50%",d.transform={top:"translateX(-50%)",bottom:"translateX(-50%)",left:"translateY(-50%)",right:"translateY(-50%)",center:"translate(-50%, -50%)"}[m]),d})}}const makeVProgressLinearProps=propsFactory({absolute:Boolean,active:{type:Boolean,default:!0},bgColor:String,bgOpacity:[Number,String],bufferValue:{type:[Number,String],default:0},clickable:Boolean,color:String,height:{type:[Number,String],default:4},indeterminate:Boolean,max:{type:[Number,String],default:100},modelValue:{type:[Number,String],default:0},reverse:Boolean,stream:Boolean,striped:Boolean,roundedBar:Boolean,...makeComponentProps(),...makeLocationProps({location:"top"}),...makeRoundedProps(),...makeTagProps(),...makeThemeProps()},"VProgressLinear"),VProgressLinear=genericComponent()({name:"VProgressLinear",props:makeVProgressLinearProps(),emits:{"update:modelValue":v=>!0},setup(v,u){let{slots:b}=u;const g=useProxiedModel(v,"modelValue"),{isRtl:p,rtlClasses:m}=useRtl(),{themeClasses:s}=provideTheme(v),{locationStyles:l}=useLocation(v),{textColorClasses:d,textColorStyles:a}=useTextColor(v,"color"),{backgroundColorClasses:o,backgroundColorStyles:t}=useBackgroundColor(computed(()=>v.bgColor||v.color)),{backgroundColorClasses:e,backgroundColorStyles:n}=useBackgroundColor(v,"color"),{roundedClasses:r}=useRounded(v),{intersectionRef:i,isIntersecting:c}=useIntersectionObserver(),f=computed(()=>parseInt(v.max,10)),y=computed(()=>parseInt(v.height,10)),w=computed(()=>parseFloat(v.bufferValue)/f.value*100),x=computed(()=>parseFloat(g.value)/f.value*100),_=computed(()=>p.value!==v.reverse),S=computed(()=>v.indeterminate?"fade-transition":"slide-x-transition"),I=computed(()=>v.bgOpacity==null?v.bgOpacity:parseFloat(v.bgOpacity));function O(T){if(!i.value)return;const{left:A,right:P,width:R}=i.value.getBoundingClientRect(),D=_.value?R-T.clientX+(P-R):T.clientX-A;g.value=Math.round(D/R*f.value)}return useRender(()=>createVNode(v.tag,{ref:i,class:["v-progress-linear",{"v-progress-linear--absolute":v.absolute,"v-progress-linear--active":v.active&&c.value,"v-progress-linear--reverse":_.value,"v-progress-linear--rounded":v.rounded,"v-progress-linear--rounded-bar":v.roundedBar,"v-progress-linear--striped":v.striped},r.value,s.value,m.value,v.class],style:[{bottom:v.location==="bottom"?0:void 0,top:v.location==="top"?0:void 0,height:v.active?convertToUnit(y.value):0,"--v-progress-linear-height":convertToUnit(y.value),...l.value},v.style],role:"progressbar","aria-hidden":v.active?"false":"true","aria-valuemin":"0","aria-valuemax":v.max,"aria-valuenow":v.indeterminate?void 0:x.value,onClick:v.clickable&&O},{default:()=>[v.stream&&createVNode("div",{key:"stream",class:["v-progress-linear__stream",d.value],style:{...a.value,[_.value?"left":"right"]:convertToUnit(-y.value),borderTop:`${convertToUnit(y.value/2)} dotted`,opacity:I.value,top:`calc(50% - ${convertToUnit(y.value/4)})`,width:convertToUnit(100-w.value,"%"),"--v-progress-linear-stream-to":convertToUnit(y.value*(_.value?1:-1))}},null),createVNode("div",{class:["v-progress-linear__background",o.value],style:[t.value,{opacity:I.value,width:convertToUnit(v.stream?w.value:100,"%")}]},null),createVNode(Transition,{name:S.value},{default:()=>[v.indeterminate?createVNode("div",{class:"v-progress-linear__indeterminate"},[["long","short"].map(T=>createVNode("div",{key:T,class:["v-progress-linear__indeterminate",T,e.value],style:n.value},null))]):createVNode("div",{class:["v-progress-linear__determinate",e.value],style:[n.value,{width:convertToUnit(x.value,"%")}]},null)]}),b.default&&createVNode("div",{class:"v-progress-linear__content"},[b.default({value:x.value,buffer:w.value})])]})),{}}}),makeLoaderProps=propsFactory({loading:[Boolean,String]},"loader");function useLoader(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName();return{loaderClasses:computed(()=>({[`${u}--loading`]:v.loading}))}}function LoaderSlot(v,u){var g;let{slots:b}=u;return createVNode("div",{class:`${v.name}__loader`},[((g=b.default)==null?void 0:g.call(b,{color:v.color,isActive:v.active}))||createVNode(VProgressLinear,{active:v.active,color:v.color,height:"2",indeterminate:!0},null)])}const allowedVariants=["underlined","outlined","filled","solo","solo-inverted","solo-filled","plain"],makeVFieldProps=propsFactory({appendInnerIcon:IconValue,bgColor:String,clearable:Boolean,clearIcon:{type:IconValue,default:"$clear"},active:Boolean,centerAffix:{type:Boolean,default:void 0},color:String,baseColor:String,dirty:Boolean,disabled:{type:Boolean,default:null},error:Boolean,flat:Boolean,label:String,persistentClear:Boolean,prependInnerIcon:IconValue,reverse:Boolean,singleLine:Boolean,variant:{type:String,default:"filled",validator:v=>allowedVariants.includes(v)},"onClick:clear":EventProp(),"onClick:appendInner":EventProp(),"onClick:prependInner":EventProp(),...makeComponentProps(),...makeLoaderProps(),...makeRoundedProps(),...makeThemeProps()},"VField"),VField=genericComponent()({name:"VField",inheritAttrs:!1,props:{id:String,...makeFocusProps(),...makeVFieldProps()},emits:{"update:focused":v=>!0,"update:modelValue":v=>!0},setup(v,u){let{attrs:b,emit:g,slots:p}=u;const{themeClasses:m}=provideTheme(v),{loaderClasses:s}=useLoader(v),{focusClasses:l,isFocused:d,focus:a,blur:o}=useFocus(v),{InputIcon:t}=useInputIcon(v),{roundedClasses:e}=useRounded(v),{rtlClasses:n}=useRtl(),r=computed(()=>v.dirty||v.active),i=computed(()=>!v.singleLine&&!!(v.label||p.label)),c=getUid(),f=computed(()=>v.id||`input-${c}`),y=computed(()=>`${f.value}-messages`),w=ref(),x=ref(),_=ref(),S=computed(()=>["plain","underlined"].includes(v.variant)),{backgroundColorClasses:I,backgroundColorStyles:O}=useBackgroundColor(toRef(v,"bgColor")),{textColorClasses:T,textColorStyles:A}=useTextColor(computed(()=>v.error||v.disabled?void 0:r.value&&d.value?v.color:v.baseColor));watch(r,D=>{if(i.value){const $=w.value.$el,M=x.value.$el;requestAnimationFrame(()=>{const C=nullifyTransforms($),k=M.getBoundingClientRect(),z=k.x-C.x,G=k.y-C.y-(C.height/2-k.height/2),Y=k.width/.75,K=Math.abs(Y-C.width)>1?{maxWidth:convertToUnit(Y)}:void 0,ee=getComputedStyle($),oe=getComputedStyle(M),Q=parseFloat(ee.transitionDuration)*1e3||150,ae=parseFloat(oe.getPropertyValue("--v-field-label-scale")),re=oe.getPropertyValue("color");$.style.visibility="visible",M.style.visibility="hidden",animate($,{transform:`translate(${z}px, ${G}px) scale(${ae})`,color:re,...K},{duration:Q,easing:standardEasing,direction:D?"normal":"reverse"}).finished.then(()=>{$.style.removeProperty("visibility"),M.style.removeProperty("visibility")})})}},{flush:"post"});const P=computed(()=>({isActive:r,isFocused:d,controlRef:_,blur:o,focus:a}));function R(D){D.target!==document.activeElement&&D.preventDefault()}return useRender(()=>{var z,G,Y;const D=v.variant==="outlined",$=p["prepend-inner"]||v.prependInnerIcon,M=!!(v.clearable||p.clear),C=!!(p["append-inner"]||v.appendInnerIcon||M),k=p.label?p.label({...P.value,label:v.label,props:{for:f.value}}):v.label;return createVNode("div",mergeProps({class:["v-field",{"v-field--active":r.value,"v-field--appended":C,"v-field--center-affix":v.centerAffix??!S.value,"v-field--disabled":v.disabled,"v-field--dirty":v.dirty,"v-field--error":v.error,"v-field--flat":v.flat,"v-field--has-background":!!v.bgColor,"v-field--persistent-clear":v.persistentClear,"v-field--prepended":$,"v-field--reverse":v.reverse,"v-field--single-line":v.singleLine,"v-field--no-label":!k,[`v-field--variant-${v.variant}`]:!0},m.value,I.value,l.value,s.value,e.value,n.value,v.class],style:[O.value,A.value,v.style],onClick:R},b),[createVNode("div",{class:"v-field__overlay"},null),createVNode(LoaderSlot,{name:"v-field",active:!!v.loading,color:v.error?"error":v.color},{default:p.loader}),$&&createVNode("div",{key:"prepend",class:"v-field__prepend-inner"},[v.prependInnerIcon&&createVNode(t,{key:"prepend-icon",name:"prependInner"},null),(z=p["prepend-inner"])==null?void 0:z.call(p,P.value)]),createVNode("div",{class:"v-field__field","data-no-activator":""},[["filled","solo","solo-inverted","solo-filled"].includes(v.variant)&&i.value&&createVNode(VFieldLabel,{key:"floating-label",ref:x,class:[T.value],floating:!0,for:f.value},{default:()=>[k]}),createVNode(VFieldLabel,{ref:w,for:f.value},{default:()=>[k]}),(G=p.default)==null?void 0:G.call(p,{...P.value,props:{id:f.value,class:"v-field__input","aria-describedby":y.value},focus:a,blur:o})]),M&&createVNode(VExpandXTransition,{key:"clear"},{default:()=>[withDirectives(createVNode("div",{class:"v-field__clearable",onMousedown:K=>{K.preventDefault(),K.stopPropagation()}},[p.clear?p.clear():createVNode(t,{name:"clear"},null)]),[[vShow,v.dirty]])]}),C&&createVNode("div",{key:"append",class:"v-field__append-inner"},[(Y=p["append-inner"])==null?void 0:Y.call(p,P.value),v.appendInnerIcon&&createVNode(t,{key:"append-icon",name:"appendInner"},null)]),createVNode("div",{class:["v-field__outline",T.value]},[D&&createVNode(Fragment,null,[createVNode("div",{class:"v-field__outline__start"},null),i.value&&createVNode("div",{class:"v-field__outline__notch"},[createVNode(VFieldLabel,{ref:x,floating:!0,for:f.value},{default:()=>[k]})]),createVNode("div",{class:"v-field__outline__end"},null)]),S.value&&i.value&&createVNode(VFieldLabel,{ref:x,floating:!0,for:f.value},{default:()=>[k]})])])}),{controlRef:_}}});function filterFieldProps(v){const u=Object.keys(VField.props).filter(b=>!isOn(b)&&b!=="class"&&b!=="style");return pick(v,u)}const VInput$1="",VMessages$1="",makeVMessagesProps=propsFactory({active:Boolean,color:String,messages:{type:[Array,String],default:()=>[]},...makeComponentProps(),...makeTransitionProps({transition:{component:VSlideYTransition,leaveAbsolute:!0,group:!0}})},"VMessages"),VMessages=genericComponent()({name:"VMessages",props:makeVMessagesProps(),setup(v,u){let{slots:b}=u;const g=computed(()=>wrapInArray(v.messages)),{textColorClasses:p,textColorStyles:m}=useTextColor(computed(()=>v.color));return useRender(()=>createVNode(MaybeTransition,{transition:v.transition,tag:"div",class:["v-messages",p.value,v.class],style:[m.value,v.style],role:"alert","aria-live":"polite"},{default:()=>[v.active&&g.value.map((s,l)=>createVNode("div",{class:"v-messages__message",key:`${l}-${g.value}`},[b.message?b.message({message:s}):s]))]})),{}}}),FormKey=Symbol.for("vuetify:form");function useForm(){return inject(FormKey,null)}const makeValidationProps=propsFactory({disabled:{type:Boolean,default:null},error:Boolean,errorMessages:{type:[Array,String],default:()=>[]},maxErrors:{type:[Number,String],default:1},name:String,label:String,readonly:{type:Boolean,default:null},rules:{type:Array,default:()=>[]},modelValue:null,validateOn:String,validationValue:null,...makeFocusProps()},"validation");function useValidation(v){let u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:getCurrentInstanceName(),b=arguments.length>2&&arguments[2]!==void 0?arguments[2]:getUid();const g=useProxiedModel(v,"modelValue"),p=computed(()=>v.validationValue===void 0?g.value:v.validationValue),m=useForm(),s=ref([]),l=shallowRef(!0),d=computed(()=>!!(wrapInArray(g.value===""?null:g.value).length||wrapInArray(p.value===""?null:p.value).length)),a=computed(()=>!!(v.disabled??(m==null?void 0:m.isDisabled.value))),o=computed(()=>!!(v.readonly??(m==null?void 0:m.isReadonly.value))),t=computed(()=>v.errorMessages.length?wrapInArray(v.errorMessages).slice(0,Math.max(0,+v.maxErrors)):s.value),e=computed(()=>{let x=(v.validateOn??(m==null?void 0:m.validateOn.value))||"input";x==="lazy"&&(x="input lazy");const _=new Set((x==null?void 0:x.split(" "))??[]);return{blur:_.has("blur")||_.has("input"),input:_.has("input"),submit:_.has("submit"),lazy:_.has("lazy")}}),n=computed(()=>v.error||v.errorMessages.length?!1:v.rules.length?l.value?s.value.length||e.value.lazy?null:!0:!s.value.length:!0),r=shallowRef(!1),i=computed(()=>({[`${u}--error`]:n.value===!1,[`${u}--dirty`]:d.value,[`${u}--disabled`]:a.value,[`${u}--readonly`]:o.value})),c=computed(()=>v.name??unref(b));onBeforeMount(()=>{m==null||m.register({id:c.value,validate:w,reset:f,resetValidation:y})}),onBeforeUnmount(()=>{m==null||m.unregister(c.value)}),onMounted(async()=>{e.value.lazy||await w(!0),m==null||m.update(c.value,n.value,t.value)}),useToggleScope(()=>e.value.input,()=>{watch(p,()=>{if(p.value!=null)w();else if(v.focused){const x=watch(()=>v.focused,_=>{_||w(),x()})}})}),useToggleScope(()=>e.value.blur,()=>{watch(()=>v.focused,x=>{x||w()})}),watch(n,()=>{m==null||m.update(c.value,n.value,t.value)});function f(){g.value=null,nextTick(y)}function y(){l.value=!0,e.value.lazy?s.value=[]:w(!0)}async function w(){let x=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!1;const _=[];r.value=!0;for(const S of v.rules){if(_.length>=+(v.maxErrors??1))break;const O=await(typeof S=="function"?S:()=>S)(p.value);if(O!==!0){if(O!==!1&&typeof O!="string"){console.warn(`${O} is not a valid value. Rule functions must return boolean true or a string.`);continue}_.push(O||"")}}return s.value=_,r.value=!1,l.value=x,s.value}return{errorMessages:t,isDirty:d,isDisabled:a,isReadonly:o,isPristine:l,isValid:n,isValidating:r,reset:f,resetValidation:y,validate:w,validationClasses:i}}const makeVInputProps=propsFactory({id:String,appendIcon:IconValue,centerAffix:{type:Boolean,default:!0},prependIcon:IconValue,hideDetails:[Boolean,String],hint:String,persistentHint:Boolean,messages:{type:[Array,String],default:()=>[]},direction:{type:String,default:"horizontal",validator:v=>["horizontal","vertical"].includes(v)},"onClick:prepend":EventProp(),"onClick:append":EventProp(),...makeComponentProps(),...makeDensityProps(),...makeValidationProps()},"VInput"),VInput=genericComponent()({name:"VInput",props:{...makeVInputProps()},emits:{"update:modelValue":v=>!0},setup(v,u){let{attrs:b,slots:g,emit:p}=u;const{densityClasses:m}=useDensity(v),{rtlClasses:s}=useRtl(),{InputIcon:l}=useInputIcon(v),d=getUid(),a=computed(()=>v.id||`input-${d}`),o=computed(()=>`${a.value}-messages`),{errorMessages:t,isDirty:e,isDisabled:n,isReadonly:r,isPristine:i,isValid:c,isValidating:f,reset:y,resetValidation:w,validate:x,validationClasses:_}=useValidation(v,"v-input",a),S=computed(()=>({id:a,messagesId:o,isDirty:e,isDisabled:n,isReadonly:r,isPristine:i,isValid:c,isValidating:f,reset:y,resetValidation:w,validate:x})),I=computed(()=>{var O;return(O=v.errorMessages)!=null&&O.length||!i.value&&t.value.length?t.value:v.hint&&(v.persistentHint||v.focused)?v.hint:v.messages});return useRender(()=>{var R,D,$,M;const O=!!(g.prepend||v.prependIcon),T=!!(g.append||v.appendIcon),A=I.value.length>0,P=!v.hideDetails||v.hideDetails==="auto"&&(A||!!g.details);return createVNode("div",{class:["v-input",`v-input--${v.direction}`,{"v-input--center-affix":v.centerAffix},m.value,s.value,_.value,v.class],style:v.style},[O&&createVNode("div",{key:"prepend",class:"v-input__prepend"},[(R=g.prepend)==null?void 0:R.call(g,S.value),v.prependIcon&&createVNode(l,{key:"prepend-icon",name:"prepend"},null)]),g.default&&createVNode("div",{class:"v-input__control"},[(D=g.default)==null?void 0:D.call(g,S.value)]),T&&createVNode("div",{key:"append",class:"v-input__append"},[v.appendIcon&&createVNode(l,{key:"append-icon",name:"append"},null),($=g.append)==null?void 0:$.call(g,S.value)]),P&&createVNode("div",{class:"v-input__details"},[createVNode(VMessages,{id:o.value,active:A,messages:I.value},{message:g.message}),(M=g.details)==null?void 0:M.call(g,S.value)])])}),{reset:y,resetValidation:w,validate:x}}}),Refs=Symbol("Forwarded refs");function getDescriptor(v,u){let b=v;for(;b;){const g=Reflect.getOwnPropertyDescriptor(b,u);if(g)return g;b=Object.getPrototypeOf(b)}}function forwardRefs(v){for(var u=arguments.length,b=new Array(u>1?u-1:0),g=1;g<u;g++)b[g-1]=arguments[g];return v[Refs]=b,new Proxy(v,{get(p,m){if(Reflect.has(p,m))return Reflect.get(p,m);if(!(typeof m=="symbol"||m.startsWith("__"))){for(const s of b)if(s.value&&Reflect.has(s.value,m)){const l=Reflect.get(s.value,m);return typeof l=="function"?l.bind(s.value):l}}},has(p,m){if(Reflect.has(p,m))return!0;if(typeof m=="symbol"||m.startsWith("__"))return!1;for(const s of b)if(s.value&&Reflect.has(s.value,m))return!0;return!1},getOwnPropertyDescriptor(p,m){var l;const s=Reflect.getOwnPropertyDescriptor(p,m);if(s)return s;if(!(typeof m=="symbol"||m.startsWith("__"))){for(const d of b){if(!d.value)continue;const a=getDescriptor(d.value,m)??("_"in d.value?getDescriptor((l=d.value._)==null?void 0:l.setupState,m):void 0);if(a)return a}for(const d of b){const a=d.value&&d.value[Refs];if(!a)continue;const o=a.slice();for(;o.length;){const t=o.shift(),e=getDescriptor(t.value,m);if(e)return e;const n=t.value&&t.value[Refs];n&&o.push(...n)}}}}})}const makeVFileInputProps=propsFactory({chips:Boolean,counter:Boolean,counterSizeString:{type:String,default:"$vuetify.fileInput.counterSize"},counterString:{type:String,default:"$vuetify.fileInput.counter"},multiple:Boolean,showSize:{type:[Boolean,Number],default:!1,validator:v=>typeof v=="boolean"||[1e3,1024].includes(v)},...makeVInputProps({prependIcon:"$file"}),modelValue:{type:Array,default:()=>[],validator:v=>wrapInArray(v).every(u=>u!=null&&typeof u=="object")},...makeVFieldProps({clearable:!0})},"VFileInput"),VFileInput=genericComponent()({name:"VFileInput",inheritAttrs:!1,props:makeVFileInputProps(),emits:{"click:control":v=>!0,"mousedown:control":v=>!0,"update:focused":v=>!0,"update:modelValue":v=>!0},setup(v,u){let{attrs:b,emit:g,slots:p}=u;const{t:m}=useLocale(),s=useProxiedModel(v,"modelValue"),{isFocused:l,focus:d,blur:a}=useFocus(v),o=computed(()=>typeof v.showSize!="boolean"?v.showSize:void 0),t=computed(()=>(s.value??[]).reduce((T,A)=>{let{size:P=0}=A;return T+P},0)),e=computed(()=>humanReadableFileSize(t.value,o.value)),n=computed(()=>(s.value??[]).map(T=>{const{name:A="",size:P=0}=T;return v.showSize?`${A} (${humanReadableFileSize(P,o.value)})`:A})),r=computed(()=>{var A;const T=((A=s.value)==null?void 0:A.length)??0;return v.showSize?m(v.counterSizeString,T,e.value):m(v.counterString,T)}),i=ref(),c=ref(),f=ref(),y=computed(()=>l.value||v.active),w=computed(()=>["plain","underlined"].includes(v.variant));function x(){var T;f.value!==document.activeElement&&((T=f.value)==null||T.focus()),l.value||d()}function _(T){I(T)}function S(T){g("mousedown:control",T)}function I(T){var A;(A=f.value)==null||A.click(),g("click:control",T)}function O(T){T.stopPropagation(),x(),nextTick(()=>{s.value=[],callEvent(v["onClick:clear"],T)})}return watch(s,T=>{(!Array.isArray(T)||!T.length)&&f.value&&(f.value.value="")}),useRender(()=>{const T=!!(p.counter||v.counter),A=!!(T||p.details),[P,R]=filterInputAttrs(b),[{modelValue:D,...$}]=VInput.filterProps(v),[M]=filterFieldProps(v);return createVNode(VInput,mergeProps({ref:i,modelValue:s.value,"onUpdate:modelValue":C=>s.value=C,class:["v-file-input",{"v-text-field--plain-underlined":w.value},v.class],style:v.style,"onClick:prepend":_},P,$,{centerAffix:!w.value,focused:l.value}),{...p,default:C=>{let{id:k,isDisabled:z,isDirty:G,isReadonly:Y,isValid:K}=C;return createVNode(VField,mergeProps({ref:c,"prepend-icon":v.prependIcon,onMousedown:S,onClick:I,"onClick:clear":O,"onClick:prependInner":v["onClick:prependInner"],"onClick:appendInner":v["onClick:appendInner"]},M,{id:k.value,active:y.value||G.value,dirty:G.value,disabled:z.value,focused:l.value,error:K.value===!1}),{...p,default:ee=>{var ae;let{props:{class:oe,...Q}}=ee;return createVNode(Fragment,null,[createVNode("input",mergeProps({ref:f,type:"file",readonly:Y.value,disabled:z.value,multiple:v.multiple,name:v.name,onClick:re=>{re.stopPropagation(),x()},onChange:re=>{if(!re.target)return;const ne=re.target;s.value=[...ne.files??[]]},onFocus:x,onBlur:a},Q,R),null),createVNode("div",{class:oe},[!!((ae=s.value)!=null&&ae.length)&&(p.selection?p.selection({fileNames:n.value,totalBytes:t.value,totalBytesReadable:e.value}):v.chips?n.value.map(re=>createVNode(VChip,{key:re,size:"small",color:v.color},{default:()=>[re]})):n.value.join(", "))])])}})},details:A?C=>{var k,z;return createVNode(Fragment,null,[(k=p.details)==null?void 0:k.call(p,C),T&&createVNode(Fragment,null,[createVNode("span",null,null),createVNode(VCounter,{active:!!((z=s.value)!=null&&z.length),value:r.value},p.counter)])])}:void 0})}),forwardRefs({},i,c,f)}}),VGrid="",makeVContainerProps=propsFactory({fluid:{type:Boolean,default:!1},...makeComponentProps(),...makeTagProps()},"VContainer"),VContainer=genericComponent()({name:"VContainer",props:makeVContainerProps(),setup(v,u){let{slots:b}=u;const{rtlClasses:g}=useRtl();return useRender(()=>createVNode(v.tag,{class:["v-container",{"v-container--fluid":v.fluid},g.value,v.class],style:v.style},b)),{}}}),breakpointProps=(()=>breakpoints.reduce((v,u)=>(v[u]={type:[Boolean,String,Number],default:!1},v),{}))(),offsetProps=(()=>breakpoints.reduce((v,u)=>{const b="offset"+capitalize(u);return v[b]={type:[String,Number],default:null},v},{}))(),orderProps=(()=>breakpoints.reduce((v,u)=>{const b="order"+capitalize(u);return v[b]={type:[String,Number],default:null},v},{}))(),propMap$1={col:Object.keys(breakpointProps),offset:Object.keys(offsetProps),order:Object.keys(orderProps)};function breakpointClass$1(v,u,b){let g=v;if(!(b==null||b===!1)){if(u){const p=u.replace(v,"");g+=`-${p}`}return v==="col"&&(g="v-"+g),v==="col"&&(b===""||b===!0)||(g+=`-${b}`),g.toLowerCase()}}const ALIGN_SELF_VALUES=["auto","start","end","center","baseline","stretch"],makeVColProps=propsFactory({cols:{type:[Boolean,String,Number],default:!1},...breakpointProps,offset:{type:[String,Number],default:null},...offsetProps,order:{type:[String,Number],default:null},...orderProps,alignSelf:{type:String,default:null,validator:v=>ALIGN_SELF_VALUES.includes(v)},...makeComponentProps(),...makeTagProps()},"VCol"),VCol=genericComponent()({name:"VCol",props:makeVColProps(),setup(v,u){let{slots:b}=u;const g=computed(()=>{const p=[];let m;for(m in propMap$1)propMap$1[m].forEach(l=>{const d=v[l],a=breakpointClass$1(m,l,d);a&&p.push(a)});const s=p.some(l=>l.startsWith("v-col-"));return p.push({"v-col":!s||!v.cols,[`v-col-${v.cols}`]:v.cols,[`offset-${v.offset}`]:v.offset,[`order-${v.order}`]:v.order,[`align-self-${v.alignSelf}`]:v.alignSelf}),p});return()=>{var p;return h(v.tag,{class:[g.value,v.class],style:v.style},(p=b.default)==null?void 0:p.call(b))}}}),ALIGNMENT=["start","end","center"],SPACE=["space-between","space-around","space-evenly"];function makeRowProps(v,u){return breakpoints.reduce((b,g)=>{const p=v+capitalize(g);return b[p]=u(),b},{})}const ALIGN_VALUES=[...ALIGNMENT,"baseline","stretch"],alignValidator=v=>ALIGN_VALUES.includes(v),alignProps=makeRowProps("align",()=>({type:String,default:null,validator:alignValidator})),JUSTIFY_VALUES=[...ALIGNMENT,...SPACE],justifyValidator=v=>JUSTIFY_VALUES.includes(v),justifyProps=makeRowProps("justify",()=>({type:String,default:null,validator:justifyValidator})),ALIGN_CONTENT_VALUES=[...ALIGNMENT,...SPACE,"stretch"],alignContentValidator=v=>ALIGN_CONTENT_VALUES.includes(v),alignContentProps=makeRowProps("alignContent",()=>({type:String,default:null,validator:alignContentValidator})),propMap={align:Object.keys(alignProps),justify:Object.keys(justifyProps),alignContent:Object.keys(alignContentProps)},classMap={align:"align",justify:"justify",alignContent:"align-content"};function breakpointClass(v,u,b){let g=classMap[v];if(b!=null){if(u){const p=u.replace(v,"");g+=`-${p}`}return g+=`-${b}`,g.toLowerCase()}}const makeVRowProps=propsFactory({dense:Boolean,noGutters:Boolean,align:{type:String,default:null,validator:alignValidator},...alignProps,justify:{type:String,default:null,validator:justifyValidator},...justifyProps,alignContent:{type:String,default:null,validator:alignContentValidator},...alignContentProps,...makeComponentProps(),...makeTagProps()},"VRow"),VRow=genericComponent()({name:"VRow",props:makeVRowProps(),setup(v,u){let{slots:b}=u;const g=computed(()=>{const p=[];let m;for(m in propMap)propMap[m].forEach(s=>{const l=v[s],d=breakpointClass(m,s,l);d&&p.push(d)});return p.push({"v-row--no-gutters":v.noGutters,"v-row--dense":v.dense,[`align-${v.align}`]:v.align,[`justify-${v.justify}`]:v.justify,[`align-content-${v.alignContent}`]:v.alignContent}),p});return()=>{var p;return h(v.tag,{class:["v-row",g.value,v.class],style:v.style},(p=b.default)==null?void 0:p.call(b))}}}),VProgressCircular$1="",makeVProgressCircularProps=propsFactory({bgColor:String,color:String,indeterminate:[Boolean,String],modelValue:{type:[Number,String],default:0},rotate:{type:[Number,String],default:0},width:{type:[Number,String],default:4},...makeComponentProps(),...makeSizeProps(),...makeTagProps({tag:"div"}),...makeThemeProps()},"VProgressCircular"),VProgressCircular=genericComponent()({name:"VProgressCircular",props:makeVProgressCircularProps(),setup(v,u){let{slots:b}=u;const g=20,p=2*Math.PI*g,m=ref(),{themeClasses:s}=provideTheme(v),{sizeClasses:l,sizeStyles:d}=useSize(v),{textColorClasses:a,textColorStyles:o}=useTextColor(toRef(v,"color")),{textColorClasses:t,textColorStyles:e}=useTextColor(toRef(v,"bgColor")),{intersectionRef:n,isIntersecting:r}=useIntersectionObserver(),{resizeRef:i,contentRect:c}=useResizeObserver(),f=computed(()=>Math.max(0,Math.min(100,parseFloat(v.modelValue)))),y=computed(()=>Number(v.width)),w=computed(()=>d.value?Number(v.size):c.value?c.value.width:Math.max(y.value,32)),x=computed(()=>g/(1-y.value/w.value)*2),_=computed(()=>y.value/w.value*x.value),S=computed(()=>convertToUnit((100-f.value)/100*p));return watchEffect(()=>{n.value=m.value,i.value=m.value}),useRender(()=>createVNode(v.tag,{ref:m,class:["v-progress-circular",{"v-progress-circular--indeterminate":!!v.indeterminate,"v-progress-circular--visible":r.value,"v-progress-circular--disable-shrink":v.indeterminate==="disable-shrink"},s.value,l.value,a.value,v.class],style:[d.value,o.value,v.style],role:"progressbar","aria-valuemin":"0","aria-valuemax":"100","aria-valuenow":v.indeterminate?void 0:f.value},{default:()=>[createVNode("svg",{style:{transform:`rotate(calc(-90deg + ${Number(v.rotate)}deg))`},xmlns:"http://www.w3.org/2000/svg",viewBox:`0 0 ${x.value} ${x.value}`},[createVNode("circle",{class:["v-progress-circular__underlay",t.value],style:e.value,fill:"transparent",cx:"50%",cy:"50%",r:g,"stroke-width":_.value,"stroke-dasharray":p,"stroke-dashoffset":0},null),createVNode("circle",{class:"v-progress-circular__overlay",fill:"transparent",cx:"50%",cy:"50%",r:g,"stroke-width":_.value,"stroke-dasharray":p,"stroke-dashoffset":S.value},null)]),b.default&&createVNode("div",{class:"v-progress-circular__content"},[b.default({value:f.value})])]})),{}}}),WIDTH=224,DIMS=[1,3,WIDTH,WIDTH],MAX_LENGTH=DIMS[0]*DIMS[1]*DIMS[2]*DIMS[3],MAX_SIGNED_VALUE=255,_sfc_main=defineComponent({name:"HomeView",data(){return{session:null,isRunning:!1,tags:[]}},methods:{onFileChange(v){this.isRunning=!0;let b=(v.target||window.event.src).files;if(FileReader&&b&&b.length){let g=new FileReader;g.onload=()=>this.onLoadImage(g),g.readAsDataURL(b[0])}},onLoadImage(v){let u=document.getElementById("input-image");u.onload=()=>this.handleImage(u,WIDTH),u.src=v.result},async handleImage(v,u){const b=await this.processImage(v,u),g=await this.imageDataToTensor(b,DIMS);await this.runModel(g)},async processImage(v,u){const b=document.createElement("canvas");let g=b.getContext("2d");return b.width=u,b.height=b.width*(v.height/v.width),g.drawImage(v,0,0,b.width,b.height),g.getImageData(0,0,u,u).data},async imageDataToTensor(v,u){const[b,g,p]=[[],[],[]];for(let d=0;d<v.length;d+=4)b.push(v[d]),g.push(v[d+1]),p.push(v[d+2]);const m=b.concat(g).concat(p);let s=m.length;const l=new Float32Array(MAX_LENGTH);for(let d=0;d<s;d++)l[d]=m[d]/MAX_SIGNED_VALUE;return new ort_minExports.Tensor("float32",l,u)},async runModel(v){try{const u=await ort_minExports.InferenceSession.create("resnet34_10_epochs.onnx"),b={"input.1":v},g=await u.run(b);let p=[];for(let m=0;m<g[368].data.length;m++)g[368].data[m]>-.5&&p.push(categories[m]);this.tags=p}catch(u){console.error(u)}finally{this.isRunning=!1}}}}),_hoisted_1=createBaseVNode("h1",null,"Image Tagger",-1),_hoisted_2=createBaseVNode("p",{class:"py-1"}," This is a simple image tagging application. It allows you to upload images and tag them with keywords. ",-1),_hoisted_3=createBaseVNode("p",{class:"py-1"}," The model prediction is done on the client browser using ONNX runtime. ",-1),_hoisted_4=createBaseVNode("p",{class:"py-1"}," Your images are not sent to any server and your privacy is respected. ",-1),_hoisted_5=createBaseVNode("br",null,null,-1),_hoisted_6={class:"py-10"},_hoisted_7=createBaseVNode("img",{src:_imports_0,id:"input-image",class:"fixed-image",alt:"Input image"},null,-1);function _sfc_render(v,u,b,g,p,m){return openBlock(),createBlock(VContainer,null,{default:withCtx(()=>[createVNode(VRow,null,{default:withCtx(()=>[createVNode(VCol,{cols:"12"},{default:withCtx(()=>[_hoisted_1,_hoisted_2,_hoisted_3,_hoisted_4]),_:1})]),_:1}),createVNode(VRow,null,{default:withCtx(()=>[createVNode(VCol,{cols:"12"},{default:withCtx(()=>[createVNode(VFileInput,{id:"file-in",label:"File input",class:"max-30-width",onChange:v.onFileChange},null,8,["onChange"]),_hoisted_5,createBaseVNode("div",_hoisted_6,[v.isRunning?(openBlock(),createBlock(VProgressCircular,{key:0,indeterminate:"",size:37,width:5})):createCommentVNode("",!0),(openBlock(!0),createElementBlock(Fragment,null,renderList(v.tags,s=>(openBlock(),createBlock(VChip,{key:s,"prepend-icon":"mdi-tag",size:"large",class:"mx-1"},{default:withCtx(()=>[createTextVNode(toDisplayString(s),1)]),_:2},1024))),128))])]),_:1}),createVNode(VCol,{cols:"6"},{default:withCtx(()=>[_hoisted_7]),_:1})]),_:1})]),_:1})}const Home=_export_sfc(_sfc_main,[["render",_sfc_render]]);export{Home as default};
